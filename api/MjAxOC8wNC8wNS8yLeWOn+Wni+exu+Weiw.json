{"title":"2-原始类型","date":"2018-04-05T04:18:10.000Z","link":"2018/04/05/2-原始类型","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:48:31.019Z","content":"<h2 id=\"1-原始值和引用值\">1.原始值和引用值<a href=\"2018/04/05/2-原始类型#1-原始值和引用值\"></a></h2><p>原始值是存储在栈中的简单数据段，它们的值直接存储在变量访问的位置。</p>\n<p>引用值是存储在堆中的对象，存储在变量处的值是一个指针，执行存储对象的内存处。</p>\n<p>为变量赋值时，ECMAScript解释程序必须判断该值是原始类型的，还是引用类型的。</p>\n<p>ECMAScript原始类型的值包括5种，分别是<code>undefined</code>、<code>Null</code>、<code>Bollean</code>、<code>Number</code>、和<code>String</code>。</p>\n<p>ECMAScript引用类型包括：<code>Object类</code>、<code>Array类</code>、<code>Date类</code>、<code>RegExp类</code>和<code>Function类</code>等。</p>\n<p>当遇到引用值时，所处理的就是对象。</p>\n<p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反的，放在变量的栈空间中的值是该对象存放在堆中的地址。因为地址的大小是固定的，把它存储在栈中对变量性能无任何负面影响。</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_1.png\" alt=\" \" class=\"article-img\"></p>\n<p>判断变量的类型的几种方式：</p>\n<h3 id=\"1-1-typeof：\">1.1.typeof：<a href=\"2018/04/05/2-原始类型#1-1-typeof：\"></a></h3><p>对于变量或值调用typeof运算符将返回下列值之一：</p>\n<ul>\n<li><p><code>&#39;undefined&#39;</code>：如果变量时Undefined类型</p>\n</li>\n<li><p><code>&#39;boolean&#39;</code>：如果变量是Boolean类型</p>\n</li>\n<li><p><code>&#39;number&#39;</code>：如果变量是Number类型</p>\n</li>\n<li><p><code>&#39;string&#39;</code>：如果变量是String类型</p>\n</li>\n<li><p><code>&#39;object&#39;</code>：如果变量是一种引用类型或Null类型。</p>\n</li>\n</ul>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_2.png\" alt=\" \" class=\"article-img\"></p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_3.png\" alt=\" \" class=\"article-img\"></p>\n<p>大家可能对<code>typeof null</code>的结果为<code>&quot;object&quot;</code>持有怀疑态度，这实际上是JavaScript最初实现中的一个错误，然后被ECMAScript沿用了。现在<code>NULL</code>被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。</p>\n<p>注意：比较适合用于检查原始值的类型，不适合用于检查原始值得数组类型，原因大家也看到了，对于引用类型的值它只能返回object。</p>\n<h3 id=\"1-2-toString-call\">1.2.toString.call()<a href=\"2018/04/05/2-原始类型#1-2-toString-call\"></a></h3><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toString.call([]) // &quot;[object Array]&quot;</span><br><span class=\"line\">toString.call(&apos;&apos;)  // &quot;[object String]&quot;</span><br><span class=\"line\">toString.call(/[^9]/) //&quot;[object RegExp]&quot;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"1-3-constructor\">1.3.constructor<a href=\"2018/04/05/2-原始类型#1-3-constructor\"></a></h3><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[];</span><br><span class=\"line\">arr.constructor; //f Array() &#123; [native code] &#125;</span><br><span class=\"line\">var str=&apos;12&apos;</span><br><span class=\"line\">str.constructor //f String() &#123; [native code] &#125;</span><br></pre></td></tr></table></div></figure>\n<p>注意：<code>constructor</code>是不太严谨的，它是一个可读可写的属性</p>\n<h3 id=\"1-4-instanceof\">1.4.instanceof<a href=\"2018/04/05/2-原始类型#1-4-instanceof\"></a></h3><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ ] instanceof Array  //true</span><br><span class=\"line\"></span><br><span class=\"line\">(/[0-9]/) instanceof RegExp  //true在旧的浏览器不太支持</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"2-原始类型\">2.原始类型<a href=\"2018/04/05/2-原始类型#2-原始类型\"></a></h2><h3 id=\"2-1-Undefined类型\">2.1.Undefined类型<a href=\"2018/04/05/2-原始类型#2-1-Undefined类型\"></a></h3><p><code>Undefined</code>类型只有一个值，也就是<code>undefined.</code>当声明的变量未初始化时，该变量的默认值为<code>undefined</code>。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ying;   //声明变量ying，但是没有赋初值，该变量将被赋值给undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">ying==undefined //true</span><br><span class=\"line\"></span><br><span class=\"line\">typeof ying //&quot;undefined&quot;</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_4.png\" alt=\" \" class=\"article-img\"></p>\n<p>注意：值<code>undefined</code>并不同于未定义的值，未定义的值就是没有用var声明的值，但是typeof运算符并不会区分这两种值，仍然返回的是<code>undefined</code>。</p>\n<p>前提：并没有用var声明变量yang</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yang  // &quot;undefined&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">yang==undefined  //Uncaught ReferenceError: yang is not defined</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_5.png\" alt=\" \" class=\"article-img\"></p>\n<p>从结果中我们可以明显的看出即使是未定义的值，它的typeof的返回值也是undefined，但是如果对未定义过的变量使用除了<code>typeof</code>之外的运算符的话<code>(==)</code>，会报错,因为其他运算符只能用于已声明的变量上。</p>\n<p>注意：当函数无明确返回值时，返回值也是undefined。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun()&#123;&#125; //该函数没有明确的返回值</span><br><span class=\"line\"></span><br><span class=\"line\">fun()==undefined  //true</span><br><span class=\"line\"></span><br><span class=\"line\">typeof fun   //&quot;function&quot;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-2-NULL类型\">2.2.NULL类型<a href=\"2018/04/05/2-原始类型#2-2-NULL类型\"></a></h3><p>Null类型也只有一个值，也就是null。值undefined实际上是从值null派生来的，因此ECMAScript把它们定义为相等。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null==undefined   //true</span><br></pre></td></tr></table></div></figure>\n<p>注意：尽管这两个值相等，但它们的含义不同。undefined是声明了变量但未对其初始化时赋予该变量的值，null则用于表示尚未存在的对象。</p>\n<h3 id=\"2-3-Boolean类型\">2.3.Boolean类型<a href=\"2018/04/05/2-原始类型#2-3-Boolean类型\"></a></h3><p>Boolean类型它有两个值true和false,即使false不等于0，0也可以在必要时被转换成false。</p>\n<h3 id=\"2-4-Number类型\">2.4.Number类型<a href=\"2018/04/05/2-原始类型#2-4-Number类型\"></a></h3><p>Number类型既可以表示32位的整数，还可以表示64位的浮点数。直接输入的任何数字都被看做是Number类型的字面量。</p>\n<p><code>var num=1;</code></p>\n<p>typeof整数也可以表示为八进制或者十六进制的字面量</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num=070; //八进制</span><br><span class=\"line\"></span><br><span class=\"line\">var num=0x1f; //十六进制</span><br></pre></td></tr></table></div></figure>\n<p>注意：尽管所有整数都可以表示为八进制或者十六进制的字面量，但所有数学运算返回的都是十进制结果。</p>\n<p>浮点值必须要包括小数点和小数点后的一位数字。</p>\n<p><code>var num=1.0;</code></p>\n<p>对于非常大或非常小的数，可以用科学计数法表示浮点值。科学计数法可以把一个数表示为数字(包括十进制数字)加e(或E)，后面加乘以10的倍数。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num=3.125e10;</span><br><span class=\"line\"></span><br><span class=\"line\">var num=3-e17;</span><br></pre></td></tr></table></div></figure>\n<p><strong>关于特殊值：</strong></p>\n<ul>\n<li><p><code>Number.MIN_VALUE</code> //5e-324</p>\n</li>\n<li><p><code>Number.MAX_VALUE</code>  //1.7976931348623157e+308</p>\n</li>\n</ul>\n<p>定义了Number值集合的外边界，所有ECMAScript数都必须在这两个值中间,但是计算生成的数值结果可以不落在这两个数之间。</p>\n<p>当计算生成的数大于<code>Number.MAX_VALUE</code>，它将被赋予值<code>Number.POSITIVE_INFINITY</code></p>\n<p>当计算生成的数小于<code>Number.MIN_VALUE</code>，它将被赋予值<code>Number.NEGATIVE_INFINITY</code></p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.POSITIVE_INFINITY==Infinity  //true</span><br><span class=\"line\"></span><br><span class=\"line\">Number.NEGATIVE_INFINITY==Infinity  //true</span><br></pre></td></tr></table></div></figure>\n<p>isFinit()方法：判断一个数是有穷的还是无穷的</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num=some_really_large_number;</span><br><span class=\"line\"></span><br><span class=\"line\">if(isFinit(num))&#123;</span><br><span class=\"line\">    console.log(&quot;这个数是有穷的&quot;)</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    console.log(&quot;这个数是无穷的&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>NAN:表示非数</li>\n</ul>\n<p>NAN是个奇怪的特殊值，一般来说在不同数据类型之间转换失败时，比如把字符串类型<code>(&quot;blue&quot;)</code>转换成数值就会失败，因为没有与之等价的数值。</p>\n<p><code>Number(&quot;blue&quot;)  //NaN (将字符串&quot;blue&quot;转换成Number类型,转换失败)</code></p>\n<p>NAN它与自身不相等。</p>\n<p><code>NaN==NaN   //false</code></p>\n<p>我们可以使用<code>isNaN()</code>函数来判断一个数的数据类型是不是非数。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNaN(&quot;blue&quot;) //true</span><br><span class=\"line\"></span><br><span class=\"line\">isNaN(&quot;1&quot;)  //false</span><br><span class=\"line\"></span><br><span class=\"line\">isNaN(1)  //false</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-5-String类型\">2.5.String类型<a href=\"2018/04/05/2-原始类型#2-5-String类型\"></a></h3><p>String类型，它是唯一没有固定大小的原始类型，可以用字符串存储0或更多的Unicode字符，由16位整数表示。</p>\n<p>字符串中每个字符都有特定的位置，首字符从位置0开始，第二个字符在位置1，以此类推，这意味着字符串中的最后一个字符的位置一定是字符串的长度减1。</p>\n","prev":{"title":"2-引用类型","link":"2018/04/07/2-引用类型"},"next":{"title":"2-函数","link":"2018/04/02/2-函数"},"plink":"http://yoursite.com/2018/04/05/2-原始类型/","toc":[{"title":"1.原始值和引用值","id":"1-原始值和引用值","index":"1","children":[{"title":"1.1.typeof：","id":"1-1-typeof：","index":"1.1"},{"title":"1.2.toString.call()","id":"1-2-toString-call","index":"1.2"},{"title":"1.3.constructor","id":"1-3-constructor","index":"1.3"},{"title":"1.4.instanceof","id":"1-4-instanceof","index":"1.4"}]},{"title":"2.原始类型","id":"2-原始类型","index":"2","children":[{"title":"2.1.Undefined类型","id":"2-1-Undefined类型","index":"2.1"},{"title":"2.2.NULL类型","id":"2-2-NULL类型","index":"2.2"},{"title":"2.3.Boolean类型","id":"2-3-Boolean类型","index":"2.3"},{"title":"2.4.Number类型","id":"2-4-Number类型","index":"2.4"},{"title":"2.5.String类型","id":"2-5-String类型","index":"2.5"}]}]}