{"title":"3-4-Git分支","date":"2018-08-15T08:28:10.000Z","link":"2018/08/15/3-4.Git分支","tags":["Git"],"categories":["前端"],"updated":"2018-10-12T14:48:13.849Z","content":"<h3 id=\"5-1-推送\">5.1.推送<a href=\"2018/08/15/3-4.Git分支#5-1-推送\"></a></h3><p>当想要公开分享一个分支时，需要将其推送到具有写入权限的远程仓库上，本地的分支并不会自动地与远程仓库同步，必须显示地推送想要分享到分支。</p>\n<p>命令：<code>git push (remote)(branch)</code></p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin my_ying</span><br><span class=\"line\">Counting objects: 9, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (9/9), done.</span><br><span class=\"line\">Writing objects: 100% (9/9), 3.90 KiB | 0 bytes/s, done.</span><br><span class=\"line\">Total 9 (delta 5), reused 0 (delta 0)</span><br><span class=\"line\">remote: Resolving deltas: 100% (5/5), completed with 5 local objects.</span><br><span class=\"line\">To git@github.com:Alicesii/Git.git</span><br><span class=\"line\">   dbd8323..58b5dbd  master -&gt; master</span><br><span class=\"line\">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></div></figure>\n<p>其他人从服务器上抓取数据时，它们会在本地生成一个远程分支origin/my_ying，指向服务器的<code>my_ying</code>分支的引用。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin</span><br><span class=\"line\">remote: Counting objects: 7, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (2/2), done.</span><br><span class=\"line\">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class=\"line\">Unpacking objects: 100% (3/3), done.</span><br><span class=\"line\">From https://github.com/my_ying</span><br><span class=\"line\"> * [new branch] my_ying -&gt; oriin/server</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"5-2-跟踪分支\">5.2.跟踪分支<a href=\"2018/08/15/3-4.Git分支#5-2-跟踪分支\"></a></h3><p>从一个远程分支检索出一个本地分支会自动创建<code>&quot;跟踪分支&quot;</code>，跟踪分支是与远程分支有直接关系的本地分支。也就是说，Git能自动识别去哪个服务器上抓取，合并到哪个分支。</p>\n<p>当克隆一个仓库时，Git会自动创建一个跟踪origin/master的master分支。</p>\n<p>当在本地初始化一个仓库时(<code>git init</code>命令)，Git也会自动创建一个空的跟踪分支。</p>\n<p><code>git branch</code>命名+<code>-vv</code>选项，可以查看设置的所有跟踪分支。这会将所有的本地分支列出来并且包含更多的信息。也就是说如果每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -vv</span><br><span class=\"line\">  iss16 7e424c3 [origin/iss16: ahead 2] forgot the bracke</span><br><span class=\"line\">  master c9dff3c [origin/master] fif-Camera</span><br><span class=\"line\">* my_ying f8674d9 [origin/my_ying: ahead 3, behind 1] this</span><br><span class=\"line\">should do it</span><br><span class=\"line\">  testing 5ea463a trying something n</span><br></pre></td></tr></table></div></figure>\n<h6 id=\"说明：\">说明：<a href=\"2018/08/15/3-4.Git分支#说明：\"></a></h6><ul>\n<li><p><code>iss16</code>分支正在跟踪origin/my_ying并且<code>&quot;ahead&quot;</code>是2，意味着本地有两个提交还没有推送到服务器上。</p>\n</li>\n<li><p><code>master</code>分支正在跟踪origin/master分支并且是最新的.</p>\n</li>\n<li><p><code>my_ying</code>分支正在跟踪master服务器上的<code>my_ying</code>分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。</p>\n</li>\n<li><p><code>testing</code>分支并没有跟踪任何远程分支。</p>\n</li>\n</ul>\n<h3 id=\"5-3-拉取\">5.3.拉取<a href=\"2018/08/15/3-4.Git分支#5-3-拉取\"></a></h3><p><code>git pull</code>命令：从远程仓库拉取到本地仓库。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin</span><br><span class=\"line\">remote: Counting objects: 7, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (2/2), done.</span><br><span class=\"line\">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class=\"line\">Unpacking objects: 100% (3/3), done.</span><br><span class=\"line\">From https://github.com/my_ying</span><br><span class=\"line\"> * [new branch] my_ying -&gt; oriin/server</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"5-4-删除远程分支\">5.4.删除远程分支<a href=\"2018/08/15/3-4.Git分支#5-4-删除远程分支\"></a></h3><p><code>git push</code>命令+<code>--delete选项</code>+分支名称：删除远程分支。</p>\n<p>如果已经通过远程分支做完了所有工作，并且这个特性分支已经合并到了远程仓库的master分支，就可以从服务器上删除这个没有用的分支了。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --delete my_ying</span><br><span class=\"line\">To https://github.com/my_ying</span><br><span class=\"line\"> - [deleted] my_ying</span><br></pre></td></tr></table></div></figure>\n<p>这个命令只是从服务器上移除这个指针，Git服务器通常会保留数据一段时间直到垃圾回收运行。</p>\n<h2 id=\"6-变基\">6.变基<a href=\"2018/08/15/3-4.Git分支#6-变基\"></a></h2><p>整合不同分支的修改主要有两种方法：<code>&quot;merge&quot;</code>(融合)和<code>&quot;rebase&quot;</code>(变基)。</p>\n<h3 id=\"6-1-变基的基本操作\">6.1.变基的基本操作<a href=\"2018/08/15/3-4.Git分支#6-1-变基的基本操作\"></a></h3><h4 id=\"6-1-1-merge命令的回顾\">6.1.1.<code>merge</code>命令的回顾<a href=\"2018/08/15/3-4.Git分支#6-1-1-merge命令的回顾\"></a></h4><p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_21.png\" alt=\" \" class=\"article-img\"></p>\n<p>分支的提交历史</p>\n<p><code>&quot;merge&quot;</code>命令是指它会把两个分支的最新快照(c3和c4)以及二者最近的共同祖先(c2)进行三方合并，合并的结果是生成一个新的快照(并提交)。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_36.png\" alt=\" \"><br>通过合并操作来整合分支的历史</p>\n<h4 id=\"6-1-2-rebase-变基\">6.1.2.<code>rebase</code>(变基)<a href=\"2018/08/15/3-4.Git分支#6-1-2-rebase-变基\"></a></h4><p><code>rebase</code>命令是指：将提交到某一个分支上的所有修改都移至另一个分支上，也就是说可以提取在C4中引入的补丁和修改，然后在C3的基础上应用一次。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout my_ying</span><br><span class=\"line\">$ git rebase master</span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Applying: added staged command</span><br></pre></td></tr></table></div></figure>\n<h6 id=\"原理：\">原理：<a href=\"2018/08/15/3-4.Git分支#原理：\"></a></h6><p>首先找到这两个分支(当前分支my_ying、变基操作的目标基底分支master)的最近共同祖先C2，然后对比当前分支相对于该分支的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底C3，最后以此将之前另存为临时文件的修改依序应用。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_37.png\" alt=\" \"><br>将C4中的修改变基到C3上</p>\n<p>这时，就可以切回到master分支，进行一次快进合并。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git merge my_ying</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_38.png\" alt=\" \"><br>master分支的快进合并</p>\n<p>这时，<code>C4＇</code>指向的快照就和使用<code>merge</code>命令例子中C5指向的快照一模一样，<code>&quot;merge&quot;</code>和<code>&quot;rebase&quot;</code>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。其实我们可以发现，尽管实际的开发工作是并行的，但是它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>\n","prev":{"title":"3-5-Git分支","link":"2018/08/17/3-5-Git分支"},"next":{"title":"3-3-Git分支","link":"2018/08/13/3-3-Git分支"},"plink":"http://yoursite.com/2018/08/15/3-4.Git分支/","toc":[{"title":"6.变基","id":"6-变基","index":"1","children":[{"title":"6.1.变基的基本操作","id":"6-1-变基的基本操作","index":"1.1","children":[{"title":"6.1.1.<code>merge</code>命令的回顾","id":"6-1-1-merge命令的回顾","index":"1.1.1"},{"title":"6.1.2.<code>rebase</code>(变基)","id":"6-1-2-rebase-变基","index":"1.1.2"}]}]}]}