{"title":"3-修改对象","date":"2018-04-27T09:17:57.000Z","link":"2018/04/27/3-修改对象","tags":["JavaScript"],"categories":["前端"],"updated":"2019-08-25T13:07:42.344Z","content":"<h2 id=\"修改对象\">修改对象<a href=\"2018/04/27/3-修改对象#修改对象\"></a></h2><h3 id=\"1-创建新方法\">1.创建新方法<a href=\"2018/04/27/3-修改对象#1-创建新方法\"></a></h3><p>可用prototype属性为任何已有的类定义新方法。</p>\n<p>举例：</p>\n<ul>\n<li>1、<code>Number类的toString()</code>方法，如果给它传递一个基数16，它将输出十六进制的字符串。我们可以自定义一个输出十六进制的函数toHexString().</li>\n</ul>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.prototype.toHexString=function()&#123;</span><br><span class=\"line\">     console.log(this); //Number &#123;345&#125;</span><br><span class=\"line\">\treturn this.toString(16);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var num=345;</span><br><span class=\"line\">console.log(num.toHexString()); //159</span><br></pre></td></tr></table></div></figure>\n<p>这里的this指向Number的实例。</p>\n<ul>\n<li>2、给Array类添加enqueue()方法和dequeue()方法</li>\n</ul>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.enqueue=function(item)&#123;</span><br><span class=\"line\">\tthis.push(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Array.prototype.dequeue=function()&#123;</span><br><span class=\"line\">   return this.shift();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>3、判断某个项在数组中的位置。</li>\n</ul>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.indexOf=function(item)&#123;</span><br><span class=\"line\">\tfor(var i=0;i&lt;this.length;i++)&#123;</span><br><span class=\"line\">\t\tif(item==this[i])&#123;</span><br><span class=\"line\">\t\t\treturn i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>indexOf()方法：在数组中检索每个项,直到发现与传进来的项相等的项为止，如果找到相等的项，就返回该项的位置，否则返回-1.</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">cosole.log(arr.indexOf(&quot;c&quot;)); //2</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>4、Object.prototype属性</li>\n</ul>\n<p>如果想要给ECMAScript中的每个本地对象添加新方法，必须在Object对象的prototype属性上定义它。因为所有的本地对象都继承了Object对象，所以对Object对象做任何改变，都会反映在所有的本地对象中。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.showvalue=function()&#123;</span><br><span class=\"line\">   console.log(this.valueOf());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var str=&quot;deded&quot;;</span><br><span class=\"line\">var num=123;</span><br><span class=\"line\">console.log(str.showvalue()); //deded</span><br><span class=\"line\">console.log(num.showvalue()); ///123</span><br></pre></td></tr></table></div></figure>\n<p>String和Number对象都从Object对象继承了showvalue()方法，分别在它们对象上调用该方法。</p>\n<h3 id=\"2-重定义已有方法\">2.重定义已有方法<a href=\"2018/04/27/3-修改对象#2-重定义已有方法\"></a></h3><p>我们既然能给已有的类定义新的方法，也可重定义已有的方法。</p>\n<ul>\n<li>1、举例：修改Function类的toString()方法。</li>\n</ul>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.toString=function()&#123;</span><br><span class=\"line\">\treturn &quot;我是重新定义的方法&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function hel()&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(hel.toString());  //我是重新定义的方法</span><br></pre></td></tr></table></div></figure>\n<p>我们应该知道Function的toString()方法通常输出的是函数的源代码，但在上述代码中我们修改了toString()方法，让它返回其他的字符串值。</p>\n<p>toString()方法的原始功能怎么办？我们就这么轻易地修改了….toString()指向的原始函数将被无用存储单元回收程序回收,完全被废弃了，没有能够恢复原始函数的办法，这样的做法是极其危险的。</p>\n<p>解决办法:在覆盖原始方法之前，比较安全的做法是用变量存储它的指针，以方便以后的使用。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.newtoString=Function.prototype.toString;</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.toString=function()&#123;</span><br><span class=\"line\">\tif(this.newtoString().length&gt;100)&#123;</span><br><span class=\"line\">\t    return &quot;该函数代码太长了&quot;;</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    return this.newtoString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function hel()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   console.log(&quot;helloworld&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(hel.toString());</span><br></pre></td></tr></table></div></figure>\n<p>把对当前的toString()方法的引用保存在属性newtoString中，然后新定义的toString()方法覆盖了原始的toString()方法的功能。新方法将检查该函数源代码的长度是否大于100，如果是，就返回提示信息该函数代码太长了，如果不是就返回函数的源代码。<br><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_14.png\" alt=\" \"></p>\n","prev":{"title":"3-字符换的链接","link":"2018/04/30/3-字符串的连接"},"next":{"title":"3-定义类和对象","link":"2018/04/25/3-定义类或对象"},"plink":"http://yoursite.com/2018/04/27/3-修改对象/","toc":[{"title":"修改对象","id":"修改对象","index":"1","children":[{"title":"1.创建新方法","id":"1-创建新方法","index":"1.1"},{"title":"2.重定义已有方法","id":"2-重定义已有方法","index":"1.2"}]}]}