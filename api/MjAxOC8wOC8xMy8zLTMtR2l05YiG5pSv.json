{"title":"3-3-Git分支","date":"2018-08-12T23:08:59.000Z","link":"2018/08/13/3-3-Git分支","tags":["Git"],"categories":["前端"],"updated":"2018-10-12T14:48:16.535Z","content":"<h2 id=\"3-分支管理\">3.分支管理<a href=\"2018/08/13/3-3-Git分支#3-分支管理\"></a></h2><p><code>git branch</code>命令在不加任何参数运行时，会得到当前所有分值的一个列表。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">  iss16</span><br><span class=\"line\">  * master</span><br><span class=\"line\">  feature</span><br></pre></td></tr></table></div></figure>\n<p><code>*</code>字符：代表现在正处于哪一个分支(master分支)，也就是当前HEAD指针所指向的分支。如果在这时提交，master分支会随着新的工作向前移动。</p>\n<p><code>git branch -v</code>命令：查看每一个分支的最后一次提交。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -v</span><br><span class=\"line\"> iss16 93b412c new branch</span><br><span class=\"line\"> * master  0f704f0 master</span><br><span class=\"line\"> feature bb5c431 anther brabch</span><br></pre></td></tr></table></div></figure>\n<p><code>--merged</code>选项过滤列表中已经合并到当前分支的分支。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --merged</span><br><span class=\"line\">  iss16</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></div></figure>\n<p>在该列表中分支名字前没有<code>*</code>号的分支可以使用<code>git branch -d</code>命令删除。</p>\n<p><code>--no-merged</code>选项过滤列表中尚未合并到当前分支的分支。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --no-merged</span><br><span class=\"line\">  feature</span><br></pre></td></tr></table></div></figure>\n<p>使用<code>git branch -d</code>命令删除feature命令时会失败。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d feature</span><br><span class=\"line\">error: The branch &apos;feature&apos; is not fully merged.</span><br><span class=\"line\">If you are sure you want to delete it, run &apos;git branch -D feature&apos;.</span><br></pre></td></tr></table></div></figure>\n<p>可以使用<code>&#39;git branch -D&#39;</code>命名删除feature分支，但是会丢掉在该分支上的工作。</p>\n<h2 id=\"4-分支开发工作流\">4.分支开发工作流<a href=\"2018/08/13/3-3-Git分支#4-分支开发工作流\"></a></h2><h3 id=\"4-1-长期分支-master分支\">4.1.长期分支(master分支)<a href=\"2018/08/13/3-3-Git分支#4-1-长期分支-master分支\"></a></h3><p>在整个项目开发周期的不同阶段，可以拥有多个开放的分支，可以定期地把某些特性分支合并入其他分支中。</p>\n<p>一般情况下，在master分支上保留完全稳定的代码，有可能仅是已经发布或即将发布的代码，可能有一些名字为develop或next的平行分支，被用来做后续开发或者测试稳定性。</p>\n<p>develop或next分支不需要保持绝对稳定，一旦达到稳定状态，就需要被合并到master分支。</p>\n<p>在确保已完成的特性分支(短期分支[iss16])能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支，等待下一次的发布。</p>\n<p>稳定分支的指针总是在提交历史中落后一大截，前沿分支的指针比较靠前。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_25.png\" alt=\" \"><br>渐进稳定分支的线形图。</p>\n<p>就像流水线一样，经过测试的提交会被提交到更加稳定的流水线。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_26.png\" alt=\" \"><br>渐进稳定分支的流水线视图</p>\n<h3 id=\"4-2-特性分支\">4.2.特性分支<a href=\"2018/08/13/3-3-Git分支#4-2-特性分支\"></a></h3><p>特性分支是一种短期分支，它被用来实现单一特性或其相关工作。</p>\n<p>在特性分支(iss16和hotfix分支)中提交一些更新，并且把它们合并到主干分支之后，又删除了特性分支。这样做能使你快速并且完整地进行上下文切换，因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关。</p>\n<p>举例：</p>\n<p>你在master分支上工作到C1，这时为了解决问题<code>#18</code>而新建iss91分支，在iss91分支上工作到C4，对于问题<code>#18</code>你又有了新的想法，所有你再新建一个iss91v2分支试图用另一种方法解决问题#18，接着你回到master分支工作了一会儿，你又冒出了一个不太确定的想法，于是你在C10的时候新建一个dumbidea分支，并在上面解决该问题。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_27.png\" alt=\" \"><br>拥有多个特性分支的提交历史</p>\n<p>假如你决定使用iss91v2分支和dumbidea分支中的方案的其中一个，就可以丢掉和iss91分支(丢弃C5和C6提交)，然后把另外两个分支合并入主干分支。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_28.png\" alt=\" \"><br>合并dumbidea分支和iss91v2分支</p>\n<h2 id=\"5-远程分支\">5.远程分支<a href=\"2018/08/13/3-3-Git分支#5-远程分支\"></a></h2><p>远程跟踪分支是远程分支状态的引用，它们是不能移动的本地分支，当不论做任何操作时，它们会自动移动。</p>\n<p>命名形式：(remote)/(branch)</p>\n<p>举例：查看最后一次与远程仓库origin通信时master分支的状态，可以查看origin/master分支。</p>\n<p>假设从Git服务器git.ying.com上克隆一个项目，Git的pull命令会为你自动将其命名为origin，拉取它的所有数据，创建一个指向它的master分支的指针，并且在本地将其命名为origin/master。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_29.png\" alt=\" \"><br>克隆之后的服务器与本地仓库</p>\n<p>如果你在本地的master分支做了一些工作，在同一时间，其他人推送提交到git.ying.com服务器并更新了它的master分支，这时会发生两种状况。</p>\n<ul>\n<li>第一种情况：与origin服务器连接</li>\n</ul>\n<p>提交历史将向不同的方向前进。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_30.png\" alt=\" \" class=\"article-img\"></p>\n<ul>\n<li>第二种情况：没有与origin服务器连接</li>\n</ul>\n<p>origin/master指针不会移动</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_31.png\" alt=\" \"><br>本地与远程的工作分叉</p>\n<p><code>git pull origin</code>命令：向远程仓库同步你的工作。</p>\n<p><code>git pull origin</code>命令：查找<code>&quot;origin&quot;</code>是哪一个服务器(git.ying.com)，从中抓取本地没有的数据，并且更新本地数据库，移动origin/master指针指向新的、更新后的位置。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_32.png\" alt=\" \"><br><code>git pull</code>命令更新远程仓库地引用</p>\n<p>举例：</p>\n<p>假设存在另一个内部的Git服务器，用于开发新的项目，这个服务器位于<code>git.my_ying.com</code>，我们可以添加另一个新的远程仓库引用到当前新的项目。</p>\n<p><code>git remote add</code>命令：添加一个新的远程仓库引用到当前的项目，远程仓库的命名为<code>my_ying</code>。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_33.png\" alt=\" \"><br>添加另一个远程仓库</p>\n<p>运行<code>git pull origin</code>命令来抓取远程仓库<code>my_ying</code>而本地没有的数据，这台服务器上现有的数据是origin服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支<code>my_ying/master</code>指向<code>my_ying</code>的master分支。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_34.png\" alt=\" \"><br>远程跟踪分支<code>my_ying/master</code></p>\n","prev":{"title":"3-4-Git分支","link":"2018/08/15/3-4.Git分支"},"next":{"title":"3-2-Git分支","link":"2018/08/11/3-2-Git分支"},"plink":"http://yoursite.com/2018/08/13/3-3-Git分支/","toc":[{"title":"3.分支管理","id":"3-分支管理","index":"1"},{"title":"4.分支开发工作流","id":"4-分支开发工作流","index":"2","children":[{"title":"4.1.长期分支(master分支)","id":"4-1-长期分支-master分支","index":"2.1"},{"title":"4.2.特性分支","id":"4-2-特性分支","index":"2.2"}]},{"title":"5.远程分支","id":"5-远程分支","index":"3"}]}