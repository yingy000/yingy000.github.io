{"title":"3-作用域","date":"2018-04-17T13:10:35.000Z","link":"2018/04/17/3-作用域","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:47:59.568Z","content":"<h2 id=\"作用域\">作用域<a href=\"2018/04/17/3-作用域#作用域\"></a></h2><p>作用域：某些变量的使用范围</p>\n<h3 id=\"1-公用、受保护和私有作用域\">1.公用、受保护和私有作用域<a href=\"2018/04/17/3-作用域#1-公用、受保护和私有作用域\"></a></h3><p>在传统的面向对象程序语言中存在公用、受保护和私有作用域。</p>\n<p>公用作用域中的对象属性和方法可以从对象外部访问。</p>\n<p>私有作用域中的属性和方法只能在对象内部访问，并且它的子类也不能访问这些属性和方法。</p>\n<p>受保护作用域的属性和方法外部不能访问，对象内部和它的子类可以访问。</p>\n<p>在ECMAScript中只存在就是公有作用域，这就意味着所有对象的所有属性和方法都是公用的。</p>\n<p>但是在ECMAScript中存在着一个约定俗成的规约，”有效的属性作用域模式”，说明哪些属性和方法应该被看做是私有的。这种规约规定在属性名前后加下划线。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.__name__=&quot;张三&quot;;   //属性name是私有的。</span><br></pre></td></tr></table></div></figure>\n<p>注意：下划线并不改变这些属性是公用属性的事实，只是人为的约定应该把该属性看作是私有的。</p>\n<h3 id=\"2-静态作用域并非静态的\">2.静态作用域并非静态的<a href=\"2018/04/17/3-作用域#2-静态作用域并非静态的\"></a></h3><p>静态作用域定义的属性和方法任何时候都能从同一个位置访问。</p>\n<p>严格来说，ECMAScript并没有静态作用域，不过它可以给构造函数提供属性和方法。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;a&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a.aside=function()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;aside&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a();    //a</span><br><span class=\"line\"></span><br><span class=\"line\">a.aside();    //aside</span><br></pre></td></tr></table></div></figure>\n<p>方法aside()实际上是函数a的方法，可以调用a()函数输出<code>&quot;a&quot;</code>，也可以调用a.aside()方法输出<code>&quot;aside&quot;</code>，即便如此，<code>aside()</code>也是<code>a()</code>公用作用域的方法，而不是静态方法。</p>\n<p>重申一下：构造函数只是函数、函数是对象，对象可以有属性和方法。</p>\n<h3 id=\"3-关键字this\">3.关键字this<a href=\"2018/04/17/3-作用域#3-关键字this\"></a></h3><p>关于this，会有一个另外专门的一个文章，链接地址：<a href=\"https://yingy0.github.io/2018/07/14/this/\" target=\"_blank\" rel=\"noopener\">https://yingy0.github.io/2018/07/14/this/</a></p>\n","prev":{"title":"3-面向对象","link":"2018/04/19/3-面向对象"},"next":{"title":"2-运算符","link":"2018/04/15/2-运算符"},"plink":"http://yoursite.com/2018/04/17/3-作用域/","toc":[{"title":"作用域","id":"作用域","index":"1","children":[{"title":"1.公用、受保护和私有作用域","id":"1-公用、受保护和私有作用域","index":"1.1"},{"title":"2.静态作用域并非静态的","id":"2-静态作用域并非静态的","index":"1.2"},{"title":"3.关键字this","id":"3-关键字this","index":"1.3"}]}]}