{"title":"3-5-Git分支","date":"2018-08-16T16:42:58.000Z","link":"2018/08/17/3-5-Git分支","tags":["Git"],"categories":["前端"],"updated":"2018-10-12T14:48:09.715Z","content":"<h3 id=\"6-2-一个变基的例子\">6.2.一个变基的例子<a href=\"2018/08/17/3-5-Git分支#6-2-一个变基的例子\"></a></h3><p>在对两个分支进行变基时，也可以指定另外的一个分支进行应用，就像从一个特性分支里再分出一个特性分支的提交历史。</p>\n<h6 id=\"举例：\">举例：<a href=\"2018/08/17/3-5-Git分支#举例：\"></a></h6><p>创建了一个特性分支server，为服务器添加了一些功能，提交了C3和C4，然后在C3上创建了特性分支client，为客户端添加了一些功能，提交了C8和C9，最后，回到了server分支，又提交了C10。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_39.png\" alt=\" \"><br>从一个特性分支里再分出一个特性分支的提交历史</p>\n<h4 id=\"6-2-1-git-rebase命名-onto选项的使用\">6.2.1.git rebase命名 + <code>--onto选项</code>的使用<a href=\"2018/08/17/3-5-Git分支#6-2-1-git-rebase命名-onto选项的使用\"></a></h4><p>如果希望将client中的修改合并到主分支并发布，但是并不想合并server中的修改，也就是说，选中在client分支里但不在server分支里的修改(C8和C9)，将它们变基到master分支上。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase --onto master server client</span><br></pre></td></tr></table></div></figure>\n<p>取出cilent分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们变基到master分支上。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_40.png\" alt=\" \"><br>截取特性分支上的另一个特性分支，然后变基到其他分支</p>\n<p>这时，就可以切回到master分支，进行一次快进合并。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git merge client</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_41.png\" alt=\" \"><br>快速合并master分支，使之包含来自cilent分支的修改</p>\n<h4 id=\"6-2-2-git-rebase-basebranch-topbranch-命令\">6.2.2.git rebase  [basebranch]  [topbranch]命令<a href=\"2018/08/17/3-5-Git分支#6-2-2-git-rebase-basebranch-topbranch-命令\"></a></h4><p>git rebase  [basebranch]  [topbranch]命令可以直接将特性分支(server)变基到目标分支(master)上。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase master server</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_42.png\" alt=\" \"><br>将server中的修改变基到master上</p>\n<p>这时，就可以切回到master分支，进行一次快进合并。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git merge server</span><br></pre></td></tr></table></div></figure>\n<p>这时，client和server分支中的修改都已经整合到主分支中了，可以删除掉client和server分支了。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d client</span><br><span class=\"line\">$ git branch -d server</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_43.png\" alt=\" \"><br>最终的提交历史</p>\n<h3 id=\"6-3-变更的风险\">6.3.变更的风险<a href=\"2018/08/17/3-5-Git分支#6-3-变更的风险\"></a></h3><h4 id=\"6-3-1-变基的准则—不要对在你的仓库外有副本的分支执行变基\">6.3.1.变基的准则—不要对在你的仓库外有副本的分支执行变基<a href=\"2018/08/17/3-5-Git分支#6-3-1-变基的准则—不要对在你的仓库外有副本的分支执行变基\"></a></h4><p>变基操作实质是丢弃一些现有的提交，然后相应地新建一些内容但实际上不同的提交。如果已经将提交推送至某个仓库，其他人已经从该仓库拉取提交并进行了后续工作，如果再使用<code>git rebase</code>命令重新整理提交并再次推送，这时候就会变得一团糟。</p>\n<h6 id=\"举例：-在公开的仓库上执行变基操作\">举例：(在公开的仓库上执行变基操作)<a href=\"2018/08/17/3-5-Git分支#举例：-在公开的仓库上执行变基操作\"></a></h6><p>假设从一个中央服务器克隆并且在它的基础上进行一些开发，提交历史如下。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_44.png\" alt=\" \"><br>克隆一个仓库，然后在它的基础上进行了一些开发</p>\n<p>然后，其他人向中央服务器提交了一些修改，其中包括一次合并，这时，又一次抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_45.png\" alt=\" \"><br>抓取别人的提交，合并到自己的开发分支</p>\n<p>突然，这个人又决定把合并操作回滚，改用变基，使用<code>git push --force</code>命令更新了服务器上的提交历史。更新之后，如果再从服务器上抓取更新，就会发现会多出一些新的提交历史。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_46.png\" alt=\" \"><br>有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</p>\n<p>此时，如果执行<code>git pull</code>命令，将会合并来自两条提交历史的内容，生成一个新的和并提交。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_47.png\" alt=\" \"><br>将相同的内容又合并了一次，生成了一个新的提交</p>\n<p>如果执行<code>git log</code>命令，会发现有两个提交的作者、日期、日志。并且是一样的，这会是非常混乱的。</p>\n<h4 id=\"6-3-2-用变基解决变基\">6.3.2.用变基解决变基<a href=\"2018/08/17/3-5-Git分支#6-3-2-用变基解决变基\"></a></h4><p>如果团队中的某人强制推送并覆盖了一些你所基于的提交，我们需要知道你做了哪些修改，以及他们覆盖了哪些提交。</p>\n<h6 id=\"举例-有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\">举例(有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交)<a href=\"2018/08/17/3-5-Git分支#举例-有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交\"></a></h6><ul>\n<li><p>检查哪些提交是自己分支上独有的(C2，C3，C4，C6，C7)</p>\n</li>\n<li><p>检查其中哪些提交不是合并操作的结果(C2，C3，C4)</p>\n</li>\n<li><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支(只有C2和C3，C4就是C4´)</p>\n</li>\n<li><p>把查到的这些提交应用到my_ying/master上面</p>\n</li>\n</ul>\n<p>此时，将相同的内容又合并了一次，生成了一个新的提交中不同的结果，也就是说，在一个被变基然后强制推送的分支上再次执行变基。</p>\n<p><img src=\"https://www.cnblogs.com/images/cnblogs_com/cliy-10/1268239/o_48.png\" alt=\" \"><br>在一个被变基然后强制推送的分支上再次执行变基</p>\n<h4 id=\"6-3-3-变基VS合并\">6.3.3.变基VS合并<a href=\"2018/08/17/3-5-Git分支#6-3-3-变基VS合并\"></a></h4><p>仓库的提交历史就是记录实际发生过什么，它是针对历史的文档，不能乱改，也就是说，只对尚未推送或分享给别人的本地修改指向变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才是最好的选择。</p>\n","prev":{"title":"MTK的发展史","link":"2018/08/29/MKT的发展史"},"next":{"title":"3-4-Git分支","link":"2018/08/15/3-4.Git分支"},"plink":"http://yoursite.com/2018/08/17/3-5-Git分支/"}