{"title":"动态类型语言和鸭子类型","date":"2018-05-07T04:10:30.000Z","link":"2018/05/07/动态类型语言和鸭子类型","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:46:22.374Z","content":"<blockquote>\n<p>JavaScript没有提供传统面向对象语言中的类式继承，而是通过prototype原型委托的方式来实现对象与对象之间的继承。JavaScript也没有在语言层面提供对抽象类和接口的支持。那JavaScript是怎么实现面向对象的机制，我们十分有必要的了解一下。</p>\n</blockquote>\n<h2 id=\"1-动态类型语言\">1.动态类型语言<a href=\"2018/05/07/动态类型语言和鸭子类型#1-动态类型语言\"></a></h2><h3 id=\"1-1-动态类型语言的特点\">1.1.动态类型语言的特点<a href=\"2018/05/07/动态类型语言和鸭子类型#1-1-动态类型语言的特点\"></a></h3><ul>\n<li><p>1.动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。</p>\n</li>\n<li><p>2.动态类型语言的优点是编写的代码数量更少，看起来更加简洁，程序员可以把精力更多地放在业务逻辑上面。</p>\n</li>\n<li><p>3.动态类型语言的缺点是无法保证变量的类型从而在程序的运行期有可能发生跟类型相关的错误。这好像在商店里买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味</p>\n</li>\n<li><p>4.动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性，由于无需进行类型检测， 我们可以尝试调用任何对象的任意方法，，而无需去考虑它原本是否被设计为拥有该方法。</p>\n</li>\n<li><p>5.在JavaScript中当我们对一个变量赋值时，显然不需要考虑它的类型，因此JavaScript是典型的动态类型语言。</p>\n</li>\n</ul>\n<h3 id=\"1-2-静态类型语言的特点\">1.2.静态类型语言的特点<a href=\"2018/05/07/动态类型语言和鸭子类型#1-2-静态类型语言的特点\"></a></h3><ul>\n<li><p>1、静态类型语言在编译时便已确定变量的类型</p>\n</li>\n<li><p>2、静态类型语言的优点是在编译时就能发现类型不匹配的错误，编译器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作。</p>\n</li>\n<li><p>3、静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段而不是编写程序的目的。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的经理从思考业务逻辑上分散开来。</p>\n</li>\n</ul>\n<h2 id=\"2-鸭子类型\">2.鸭子类型<a href=\"2018/05/07/动态类型语言和鸭子类型#2-鸭子类型\"></a></h2><p>鸭子类型的通俗说法：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。</p>\n<p>从前在JavaScript王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全全国，终于找到999只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_22.png\" alt=\" \" class=\"article-img\"></p>\n<p>这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为而不关注对象本身也就是关注HAS-A而不是IS-A。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var duck=&#123; //鸭子对象</span><br><span class=\"line\">\tduckSinging:function()&#123;</span><br><span class=\"line\">      console.log(&quot;嘎嘎嘎&quot;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var chicken=&#123; //鸡对象</span><br><span class=\"line\">\tduckSinging:function()&#123;</span><br><span class=\"line\">\tconsol.log(&quot;嘎嘎嘎&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var choir=[];</span><br><span class=\"line\"></span><br><span class=\"line\">function joinchoir(animal)&#123;</span><br><span class=\"line\">\tif(typeof animal.duckSinging===&quot;function&quot;)&#123;</span><br><span class=\"line\">\t choir.push(animal);</span><br><span class=\"line\">\t console.log(&quot;欢迎加入合唱团&quot;);</span><br><span class=\"line\">\t console.log(&quot;合唱团已有成员数量&quot;+choir.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">joinchoir(duck);    //欢迎加入合唱团  合唱团已有成员数量1</span><br><span class=\"line\">joinchoir(chicken); //欢迎加入合唱团   合唱团已有成员数量2</span><br></pre></td></tr></table></div></figure>\n<p>对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有duckSinging方法。</p>\n<p>在动态类型语言中，利用鸭子类型的思想，我们很容易实现<code>&quot;面向接口编程，而不是面向实现编程&quot;</code></p>\n<p>一个对象如果有push和pop方法，并且这些方法提供了正确的实现，它就可以被当做栈来使用。</p>\n<p>一个对象如果有length属性，也可以按照下标存取属性，最好还有slice和splice等方法，这个对象就可以被当做数组来使用。</p>\n<h2 id=\"3-补充知识：HAS-A和IS-A\">3.补充知识：HAS-A和IS-A<a href=\"2018/05/07/动态类型语言和鸭子类型#3-补充知识：HAS-A和IS-A\"></a></h2><p>传统的面向对象是这样描述IS-A和HAS-A原则的：</p>\n<p>public继承是一个接口继承，保持is-a原则，每个父类可用的成员对子类也可用，因为每个子类对象也都是一个父类对象。</p>\n<p>protetced/private继承是一个实现继承，基类的部分成员并非完全成为子类接口的一部分，是has-a 的关系原则。</p>\n","prev":{"title":"多态","link":"2018/05/08/多态"},"next":{"title":"4-基于库的继承","link":"2018/05/06/4-基于库的继承"},"plink":"http://yoursite.com/2018/05/07/动态类型语言和鸭子类型/","toc":[{"title":"1.动态类型语言","id":"1-动态类型语言","index":"1","children":[{"title":"1.1.动态类型语言的特点","id":"1-1-动态类型语言的特点","index":"1.1"},{"title":"1.2.静态类型语言的特点","id":"1-2-静态类型语言的特点","index":"1.2"}]},{"title":"2.鸭子类型","id":"2-鸭子类型","index":"2"},{"title":"3.补充知识：HAS-A和IS-A","id":"3-补充知识：HAS-A和IS-A","index":"3"}]}