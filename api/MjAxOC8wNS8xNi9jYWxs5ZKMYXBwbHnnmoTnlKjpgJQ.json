{"title":"call和apply的用途","date":"2018-05-16T11:00:20.000Z","link":"2018/05/16/call和apply的用途","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:47:34.662Z","content":"<h2 id=\"call和apply的用途\">call和apply的用途<a href=\"2018/05/16/call和apply的用途#call和apply的用途\"></a></h2><h3 id=\"1-改变this指向\">1.改变this指向<a href=\"2018/05/16/call和apply的用途#1-改变this指向\"></a></h3><p>call和apply最常见的用途是改变函数内部的this指向</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj1=&#123;</span><br><span class=\"line\">\tname: &quot;张三&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2=&#123;</span><br><span class=\"line\">\tname: &quot;李四&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.name=&quot;window&quot;;</span><br><span class=\"line\">function showname()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">showname()  //window(this指向window)</span><br><span class=\"line\">showname.call(obj1); //张三(this指向obj1)</span><br><span class=\"line\">showname.apply(obj2); //李四(this指向obj2)</span><br></pre></td></tr></table></div></figure>\n<p>当执行showname.call(obj1);时，showname函数体内的this就指向obj1对象，</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showname()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;相当于</span><br><span class=\"line\">function showname()&#123;</span><br><span class=\"line\">\tconsole.log(obj1.name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们经常会遇到this指向被不经意改变的场景：</p>\n<p>比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;div&quot;).onclick=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.id); //div</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>假如该事件函数中有一个内部函数func，在事件内部调用func函数时，func函数内部的this这时指向了window，而不是我们期望的div.</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.id=&quot;window&quot;;</span><br><span class=\"line\">document.getElementById(&quot;div&quot;).onclick=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.id); //div</span><br><span class=\"line\">\t\tfunction func()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.id); //window</span><br><span class=\"line\">\t\tconsole.log(this==window); //true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  func();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们可以用call来修正func函数内的this，使其指向this。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&quot;div&quot;).onclick=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.id); //div</span><br><span class=\"line\">\t\tfunction func()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.id); //div</span><br><span class=\"line\">\t\tconsole.log(this==div); //true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  func.call(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-Function-prototype-bind\">2.Function.prototype.bind()<a href=\"2018/05/16/call和apply的用途#2-Function-prototype-bind\"></a></h3><p>bind()方法的主要作用就是将函数绑定至某个对象，bind方法()会创建一个函数，函数体内this对象的值会被绑定到传入bind()函数的值。</p>\n<p>主流的浏览器都实现了内置的Function.prototype.bind()，用来指定函数内部的this指向。</p>\n<p>我们可以自己模拟一个bind()方法。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind=function(context)&#123;</span><br><span class=\"line\">\tvar that=this;  //保存原函数</span><br><span class=\"line\">\treturn function()&#123; //返回一个新的函数</span><br><span class=\"line\">\t return that.apply(context,arguments);</span><br><span class=\"line\">\t //执行新的函数的时候，会把之前传入的context当做新函数体内的this。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj=&#123;</span><br><span class=\"line\">\tname:&quot;张三&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);//张三</span><br><span class=\"line\">&#125;.bind(obj);</span><br><span class=\"line\">func();</span><br></pre></td></tr></table></div></figure>\n<p>通过Function.prototype.bind包装func函数，并且传入一个对象context当做参数，这个context对象就是我们想修正的this对象。</p>\n<p>在Function.prototype.bind的内部实现中，我们先把func函数的引用保存下来，然后返回一个新的函数。当我们将来在执行func函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，<code>that.apply(context,arguments)</code>这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。</p>\n<p>我们可以封装一个更复杂的bind()方法，可以往func含糊是中预先填入一些参数。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.bind=function()&#123;</span><br><span class=\"line\">\tvar that=this;  //保存原函数</span><br><span class=\"line\">\t    context=[].shift.call(arguments); //取得外部传入的构造器(arguments=&gt;obj)</span><br><span class=\"line\">\t    args=[].slice.call(arguments);//剩下的参数转换成数组</span><br><span class=\"line\">\treturn function()&#123; //返回一个新的函数</span><br><span class=\"line\">\t   return that.apply(context,[].concat.call(args,[].slice.call(arguments)));</span><br><span class=\"line\">\t //执行新的函数的时候，会把之前传入的context当做新函数体内的this。</span><br><span class=\"line\">\t //并且组合两次分别传入的context当做新函数体内的this</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj=&#123;</span><br><span class=\"line\">\tname:&quot;张三&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func=function(a,b,c,d)&#123;</span><br><span class=\"line\">\tconsole.log(this.name);//张三</span><br><span class=\"line\">\tconsole.log([a,b,c,d]); //[1, 2, 3,4]</span><br><span class=\"line\">&#125;.bind(obj,1,2);</span><br><span class=\"line\">func(3,4);</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"3-借用其他对象的方法\">3.借用其他对象的方法<a href=\"2018/05/16/call和apply的用途#3-借用其他对象的方法\"></a></h3><h5 id=\"3-1-借用构造函数\">3.1.借用构造函数<a href=\"2018/05/16/call和apply的用途#3-1-借用构造函数\"></a></h5><p>基于混合的对象冒充和原型方式实现继承</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B(name)&#123; //一定要带参数</span><br><span class=\"line\">\tA.call(this,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype=new A();</span><br><span class=\"line\">var b=new B(&quot;李四&quot;);</span><br><span class=\"line\">console.log(b.showname());  //李四</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.__proto__==B.prototype) //true</span><br><span class=\"line\">console.log(B.prototype.__proto__==A.prototype) //true</span><br></pre></td></tr></table></div></figure>\n<p>通过借用构造函数，我们可以实现继承的效果。</p>\n<p>函数的参数列表arguments是一个类数组，虽然它也有”下标”，但它并非真正的数组，所以不能像数组一样，进行排序操作或者往集合里添加一个新的元素,这时我们通常会借用Array.prototype对象上的方法。</p>\n<p>举例：</p>\n<p>往arguments中添加一个新的元素，通常会借用<code>Array.prototype.push.</code></p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">\tArray.prototype.push.call(arguments,3);</span><br><span class=\"line\">\tconsole.log(arguments);  //[1,2,3]</span><br><span class=\"line\">&#125;)(1,2);</span><br></pre></td></tr></table></div></figure>\n<p>想要整理arguments中的元素，通常会借用<code>Array.prototype.sort</code></p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">\tArray.prototype.sort.call(arguments);</span><br><span class=\"line\">\tconsole.log(arguments);  //[1,2,3]</span><br><span class=\"line\">&#125;)(5,2,6,1); //[1, 2, 5, 6]</span><br></pre></td></tr></table></div></figure>\n<h5 id=\"3-2-关于Array-prototype-push方法\">3.2.关于Array.prototype.push方法<a href=\"2018/05/16/call和apply的用途#3-2-关于Array-prototype-push方法\"></a></h5><p>Google-V8引擎源码中关于push方法的封装</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ArrayPush() &#123;</span><br><span class=\"line\">  var n = TO_UINT32(this.length); // 被push的对象的length</span><br><span class=\"line\">  var m = %_ArgumentsLength(); // push 的参数个数</span><br><span class=\"line\">  for (var i=0; i&lt;m; i++) &#123;</span><br><span class=\"line\">     this[i+n] = %_Arguments(i); //复制元素(1)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  this.length=n+m; // 修正length属性的值(2)</span><br><span class=\"line\">  return this.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<p>通过上述代码可以看出Array.prototype.push方法实际上是一个属性复制的过程，把参数按照下标依次添加到被push的对象上面，顺便修改了这个对象的length属性。至于被修改的对象是谁，到底是数组还是类数组对象，这并不重要。</p>\n<p>所以我们可以把”任意”对象传入Array.prototype.push;</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=&#123;&#125;;</span><br><span class=\"line\">Array.prototype.push.call(a,&quot;first&quot;,&quot;second&quot;);</span><br><span class=\"line\">console.log(a.length); //2</span><br><span class=\"line\">console.log(a[0]); //first</span><br></pre></td></tr></table></div></figure>\n<p>其实这里的<code>&quot;任意&quot;</code>对象是有条件限制的：</p>\n<ul>\n<li><p>对象本身要可以存取属性</p>\n</li>\n<li><p>对象的length属性可读写</p>\n</li>\n</ul>\n<p>如果借用Array.prototype.push方法的不是一个object类型的数据，而是一个number类型的数据，会有什么效果？</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=0;</span><br><span class=\"line\">Array.prototype.push.call(a,&quot;first&quot;,&quot;second&quot;);</span><br><span class=\"line\">console.log(a.length); //undefined</span><br><span class=\"line\">console.log(a[0]); //firsundefined</span><br></pre></td></tr></table></div></figure>\n<p>我们无法在number类型上存取其他数据，所以一个number类型的数据不可能借用到Array.prototype.push方法</p>\n<p>函数的length属性只是一个只读的属性，表示形参的个数，如果把一个函数传入Array.prototype.push会发生什么呢？</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function func()&#123;&#125;</span><br><span class=\"line\">Array.prototype.push.call(func,&quot;first&quot;,&quot;second&quot;);</span><br><span class=\"line\">console.log(func.length); //Cannot assign to read only property &apos;length&apos; of function &apos;function func()&#123;&#125;&apos;</span><br></pre></td></tr></table></div></figure>\n","prev":{"title":"闭包","link":"2018/05/18/闭包"},"next":{"title":"call和apply","link":"2018/05/15/call和apply"},"plink":"http://yoursite.com/2018/05/16/call和apply的用途/","toc":[{"title":"call和apply的用途","id":"call和apply的用途","index":"1","children":[{"title":"1.改变this指向","id":"1-改变this指向","index":"1.1"},{"title":"2.Function.prototype.bind()","id":"2-Function-prototype-bind","index":"1.2"},{"title":"3.借用其他对象的方法","id":"3-借用其他对象的方法","index":"1.3"}]}]}