{"title":"闭包的作用","date":"2018-05-20T15:20:20.000Z","link":"2018/05/20/闭包的作用","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:46:13.828Z","content":"<h2 id=\"闭包的作用\">闭包的作用<a href=\"2018/05/20/闭包的作用#闭包的作用\"></a></h2><h3 id=\"1-封装变量\">1.封装变量<a href=\"2018/05/20/闭包的作用#1-封装变量\"></a></h3><p>闭包可以帮助把一些不需要暴露在全局的变量封装成<code>&quot;私有变量&quot;</code></p>\n<p>举例：我们有一个可以计算乘积的函数</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mult()&#123;</span><br><span class=\"line\">\tvar s=1;</span><br><span class=\"line\">  for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class=\"line\">     s=s*arguments[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mult(2,3,4);  //24</span><br></pre></td></tr></table></div></figure>\n<p>mult函数接受一些number类型的参数，并返回这些参数的乘积。但是对于有些函数的调用是相同参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高函数的性能。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cache=[];</span><br><span class=\"line\"></span><br><span class=\"line\">function mult()&#123;</span><br><span class=\"line\">  var args=Array.prototype.join.call(arguments,&apos;,&apos;);</span><br><span class=\"line\">  if(cache[args])&#123;</span><br><span class=\"line\">    return cache[args];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  var s=1;</span><br><span class=\"line\">  for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class=\"line\">     s=s*arguments[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return cache[args]=s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(mult(2,3,4));  //24</span><br><span class=\"line\">console.log(mult(2,3,4))  //24</span><br></pre></td></tr></table></div></figure>\n<p>变量cache仅在mutl函数内部被使用，与其让cache变量与mult函数一起平行地暴露在全局作用域下，还不如把变量cache封装在mult函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function mult()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">var cache=[];</span><br><span class=\"line\">return function()&#123;</span><br><span class=\"line\">  var args=Array.prototype.join.call(arguments,&apos;,&apos;);</span><br><span class=\"line\">  if(args in cache)&#123;</span><br><span class=\"line\">    return cache[args];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  var s=1;</span><br><span class=\"line\">  for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class=\"line\">     s=s*arguments[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return cache[args]=s;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></div></figure>\n<p>我们应该尽量让每一个函数中只有一个功能，尽量保证单一职责原则。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function mult()&#123;</span><br><span class=\"line\">  var cache=[];</span><br><span class=\"line\">  function calc=function()&#123;</span><br><span class=\"line\">   var s=1;</span><br><span class=\"line\">  for(var i=0;i&lt;arguments.length;i++)&#123;</span><br><span class=\"line\">     s=s*arguments[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return function()&#123;</span><br><span class=\"line\">  var args=Array.prototype.join.call(arguments,&apos;,&apos;);</span><br><span class=\"line\">  if(args in cache)&#123;</span><br><span class=\"line\">    return cache[args]=calc.apply(null,arguments);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-延续局部变量的寿命\">2.延续局部变量的寿命<a href=\"2018/05/20/闭包的作用#2-延续局部变量的寿命\"></a></h3><p>img对象常常用于进行数据上报</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function report(scr)&#123;</span><br><span class=\"line\">  var img=new Image();</span><br><span class=\"line\">  img.src=src;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">report(&quot;http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_15.png&quot;);</span><br></pre></td></tr></table></div></figure>\n<p>通过查询后台的记录我们可以发现，一些低版本浏览器的实现存在Bug，在这些低版本浏览器下使用report函数进行数据上报会丢失30%左右的数据，这也就意味着，report函数并不是每一次都成功发起了HTTP请求。</p>\n<p>丢失数据的原因是img是report函数中的局部变量，当report函数的调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出HTTP请求，所以请求就会丢失掉。</p>\n<p>我们可以利用闭包将img变量的作用域一直保存在内存中。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function report(scr)&#123;</span><br><span class=\"line\">  var img=new Image();</span><br><span class=\"line\">  img.src=src;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">report(&quot;http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_15.png&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">  var imgs=[];</span><br><span class=\"line\">  return function(src)&#123;</span><br><span class=\"line\">  var img=new Image();</span><br><span class=\"line\">  imgs.push(img);</span><br><span class=\"line\">  img.src=src;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></div></figure>","prev":{"title":"jQuery选择器详解","link":"2018/06/02/jQuery选择器"},"next":{"title":"闭包","link":"2018/05/18/闭包"},"plink":"http://yoursite.com/2018/05/20/闭包的作用/","toc":[{"title":"闭包的作用","id":"闭包的作用","index":"1","children":[{"title":"1.封装变量","id":"1-封装变量","index":"1.1"},{"title":"2.延续局部变量的寿命","id":"2-延续局部变量的寿命","index":"1.2"}]}]}