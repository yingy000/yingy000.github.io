{"title":"4-继承的实现","date":"2018-05-04T02:20:32.000Z","link":"2018/05/04/4-继承的实现","tags":["JavaScript"],"categories":["前端"],"updated":"2019-08-25T11:36:01.611Z","content":"<blockquote>\n<p>真正的面向对象语言必须必须支持继承机制，所谓的继承就是一个类能够重用(继承)另一个类的方法和属性。JavaScript中是怎么实现继承的呢？</p>\n</blockquote>\n<h1 id=\"继承\">继承<a href=\"2018/05/04/4-继承的实现#继承\"></a></h1><h2 id=\"1-继承机制的实现\">1.继承机制的实现<a href=\"2018/05/04/4-继承的实现#1-继承机制的实现\"></a></h2><p>要用ECMAScript实现继承机制，我们首先要知道什么是基类？</p>\n<p>基类：所有自定义的类都可以作为基类，出于安全考虑，本地类和宿主者不能作为基类，这样可以防止公用访问编辑过的浏览器级的代码。</p>\n<p>选定基类后，就可以创建它的子类了，是否使用基类就完全由你决定了，你也可以创建一个不能直接使用的基类，它只是用于给子类提供通用的函数，在这种情况下，基类被看做抽象类。</p>\n<p>创建的子类将继承父类的所有属性和方法，包括构造函数及方法的实现。所有属性和方法都是公用的，子类可直接访问这些方法。子类还可以添加超类中没有的新属性和方法，也可以覆盖超类中的属性和方法。</p>\n<h2 id=\"2-继承的方法\">2.继承的方法<a href=\"2018/05/04/4-继承的实现#2-继承的方法\"></a></h2><h3 id=\"2-1-对象的冒充\">2.1.对象的冒充<a href=\"2018/05/04/4-继承的实现#2-1-对象的冒充\"></a></h3><p>构造原始的ECMAScript时，根本没打算设计对象冒充，它是在开发者开始理解函数的工作方式，尤其是如何在函数环境中使用this关键字后才发展而来的。</p>\n<p>原理：构造函数使用this关键字给所有属性和方法赋值，因为构造函数只是一个函数，所以可以把构造函数当成参数传递给另外一个函数，然后调用它，这样另外一个函数就有了该构造函数中定义的属性和方法。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">\tthis.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function B()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>关键this的指向总是构造函数当前创建的对象，在该方法中，this指向的是所属的对象。这个原理是把基类(函数A())作为常规函数来建立继承机制，而不是作为构造函数。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">\tthis.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B(name)&#123;</span><br><span class=\"line\">\tthis.newextend= A;</span><br><span class=\"line\">\tthis.newextend(name);</span><br><span class=\"line\">\tdelete this.newextend;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>上述代码中，为函数B()赋予了方法newextend(函数名只是指向它的指针)，然后调用该方法，给它传递参数name，最后删除对函数A()的引用，这样以后就不能再调用它。</p>\n<p>所有新属性和新方法都必须在删除了对基函数的引用之后定义，不然会覆盖超类的相关属性和方法。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">\tthis.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B(name,age)&#123;</span><br><span class=\"line\">\tthis.newextend=A;</span><br><span class=\"line\">\tthis.newextend(name);</span><br><span class=\"line\">\tdelete this.newextend;</span><br><span class=\"line\">\tthis.age=age;</span><br><span class=\"line\">\tthis.showage=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>我们需要测试一下，这样的继承方式是不是有效的。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=new A(&quot;张三&quot;);</span><br><span class=\"line\">var b=new B(&quot;李四&quot;,&quot;20&quot;);</span><br><span class=\"line\">console.log(a.showname());  //张三</span><br><span class=\"line\">console.log(b.showname());  //李四</span><br><span class=\"line\">console.log(b.showage());   //20</span><br></pre></td></tr></table></div></figure>\n<p>对象冒充可以支持多重继承，是不是很惊喜，很意外。</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_15.png\" alt=\" \" class=\"article-img\"></p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassZ()&#123;</span><br><span class=\"line\">\tthis.newextend=ClassX;</span><br><span class=\"line\">\tthis.newextend();</span><br><span class=\"line\">\tdelete this.newextend;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.newextend=ClassY;</span><br><span class=\"line\">\tthis.newextend();</span><br><span class=\"line\">\tdelete this.newextend;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>缺点：如果ClassX和ClassY具有同名的属性和方法，ClassY具有高优先级。</p>\n<h3 id=\"2-2-call-方法\">2.2.call()方法<a href=\"2018/05/04/4-继承的实现#2-2-call-方法\"></a></h3><p>call()方法与对象冒充机制十分类似，它的第一个参数用作this的对象，其他参数都直接传递给函数自身。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showcolor(before,after)&#123;</span><br><span class=\"line\">    console.log(before+this.color+after);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj=new Object();</span><br><span class=\"line\">obj.color=&quot;pink&quot;;</span><br><span class=\"line\">showcolor.call(obj,&quot;颜色是&quot;,&quot;,非常漂亮&quot;); //颜色是pink,非常漂亮</span><br></pre></td></tr></table></div></figure>\n<p>上述函数中，函数showcolor()在对象外定义，它不属于任何对象，this的指向是window。所以调用call()方法，改变该函数的this指向，第一个参数是obj,所以this指向obj对象。第二个参数和第三个参数与showcolor()函数中的参数before和after匹配。</p>\n<p>call()方法与对象冒充方式结合使用</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">\tthis.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B(name,age)&#123;</span><br><span class=\"line\">\tA.call(this,name);</span><br><span class=\"line\">\tthis.age=age;</span><br><span class=\"line\">\tthis.showage=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a=new A(&quot;张三&quot;);</span><br><span class=\"line\">var b=new B(&quot;李四&quot;,&quot;20&quot;);</span><br><span class=\"line\">console.log(a.showname());  //张三</span><br><span class=\"line\">console.log(b.showname());  //李四</span><br><span class=\"line\">console.log(b.showage());   //20</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-3-apply-方法\">2.3.apply()方法<a href=\"2018/05/04/4-继承的实现#2-3-apply-方法\"></a></h3><p>apply()方法和call()方法的效果是相同的，都是改变this的指向，唯一的不同就是参数的形式不同。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showcolor(before,after)&#123;</span><br><span class=\"line\">    console.log(before+this.color+after);</span><br><span class=\"line\">    console.log(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj=new Object();</span><br><span class=\"line\">obj.color=&quot;pink&quot;;</span><br><span class=\"line\">showcolor.apply(obj,[&quot;颜色是&quot;,&quot;,非常漂亮&quot;]); //颜色是pink,非常漂亮</span><br><span class=\"line\">showcolor.apply(obj,new Array(&quot;颜色是&quot;,&quot;,非常漂亮&quot;)); //颜色是pink,非常漂亮</span><br></pre></td></tr></table></div></figure>\n<p>上述函数中，函数showcolor()在对象外定义，它不属于任何对象，this的指向是window。所以调用apply()方法，改变该函数的this指向，第一个参数是obj,所以this指向obj对象。第二个参数是由两个字符串构成的数组与showcolor()函数中的参数before和after匹配。</p>\n<p>apply()方法与对象冒充方式结合使用</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">\tthis.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B(name,age)&#123;</span><br><span class=\"line\">\tA.apply(this,[name]);</span><br><span class=\"line\">\tthis.age=age;</span><br><span class=\"line\">\tthis.showage=function()&#123;</span><br><span class=\"line\">\t\tconsole.log(this.age);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a=new A(&quot;张三&quot;);</span><br><span class=\"line\">var b=new B(&quot;李四&quot;,&quot;20&quot;);</span><br><span class=\"line\">console.log(a.showname());  //张三</span><br><span class=\"line\">console.log(b.showname());  //李四</span><br><span class=\"line\">console.log(b.showage());   //20</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-4-原型链\">2.4.原型链<a href=\"2018/05/04/4-继承的实现#2-4-原型链\"></a></h3><p>在ECMAScript中继承就是基于原型链实现的。</p>\n<p>prototype对象是个模板，要实例化的对象都以这个模板为基础，这也就意味着，prototype对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.name=&quot;张三&quot;;</span><br><span class=\"line\">A.prototype.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function B()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype=new A();</span><br></pre></td></tr></table></div></figure>\n<p>原型链的神奇之处就在于<code>B.prototype=new A();</code></p>\n<p>这行代码，把B的prototype属性设置成A的实例，这是十分有意义的，因为想要A()函数的所有属性和方法，但又不想将它们逐个赋予B的prototype属性，以整体的形式把A的实例设置成B的prototype属性，这是最好的方法了。</p>\n<p>注意：我们可能发现，调用A()的构造函数时，没有给它传递参数，也没有必要给它传递参数，这在原型链中是标准做法，要确保构造函数没有任何参数。</p>\n<p>与对象冒充的方式相似，子类的所有属性和方法都必须出现在prototype属性被赋值后，因为在它之前赋值的所有方法都会被删除。</p>\n<p>原因：因为prototype属性被替换成了新对象，添加了新方法的原始对象将被销毁，不存在了。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.name=&quot;张三&quot;;</span><br><span class=\"line\">A.prototype.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function B()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype=new A();</span><br><span class=\"line\">B.prototype.age=20;</span><br><span class=\"line\">B.prototype.showage=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a=new A();</span><br><span class=\"line\">var b=new B();</span><br><span class=\"line\">b.name=&quot;李四&quot;</span><br><span class=\"line\">console.log(a.showname());//张三</span><br><span class=\"line\">console.log(b.showname()); //李四</span><br><span class=\"line\">console.log(b.showage());//20</span><br><span class=\"line\"></span><br><span class=\"line\">我们可以使用instanceOf运算符检查给定变量指向的对象的类型。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b instanceof  B)  //true</span><br><span class=\"line\">console.log(a instanceof A)  //true</span><br><span class=\"line\">console.log(b instanceof A)  //true</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"2-5-混合的对象冒充和原型方式\">2.5.混合的对象冒充和原型方式<a href=\"2018/05/04/4-继承的实现#2-5-混合的对象冒充和原型方式\"></a></h3><p>混合的对象冒充和原型方式指的是用对象冒充继承构造函数的属性，用原型链继承prototype对象的方法。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A(name)&#123;</span><br><span class=\"line\">\tthis.name=name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.showname=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function B(name,age)&#123;</span><br><span class=\"line\">\tA.call(this,name);</span><br><span class=\"line\">\tthis.age=age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">B.prototype=new A();</span><br><span class=\"line\">B.prototype.showage=function()&#123;</span><br><span class=\"line\">\tconsole.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a=new A(&quot;张三&quot;);</span><br><span class=\"line\">var b=new B(&quot;李四&quot;,20);</span><br><span class=\"line\">console.log(a.showname());//张三</span><br><span class=\"line\">console.log(b.showname()); //李四</span><br><span class=\"line\">console.log(b.showage());//20</span><br></pre></td></tr></table></div></figure>\n<p>在上述例子中，继承机制主要由下面两句代码实现</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A.call(this,name);</span><br><span class=\"line\">B.prototype=new A();</span><br></pre></td></tr></table></div></figure>\n<p>第一句：在B()构造函数中，用对象冒充继承A()类的name属性<br>第二句：用原型链继承A()类的方法。</p>\n<p>我们可以再次使用instanceOf运算符检查给定变量指向的对象的类型。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(b instanceof  B)  //true</span><br><span class=\"line\">console.log(a instanceof A)  //true</span><br><span class=\"line\">console.log(b instanceof A)  //true</span><br></pre></td></tr></table></div></figure>\n","prev":{"title":"4-继承实例","link":"2018/05/05/4-继承实例"},"next":{"title":"3-字符换的链接","link":"2018/04/30/3-字符串的连接"},"plink":"http://yoursite.com/2018/05/04/4-继承的实现/","toc":[{"title":"继承","id":"继承","index":"1","children":[{"title":"1.继承机制的实现","id":"1-继承机制的实现","index":"1.1"},{"title":"2.继承的方法","id":"2-继承的方法","index":"1.2","children":[{"title":"2.1.对象的冒充","id":"2-1-对象的冒充","index":"1.2.1"},{"title":"2.2.call()方法","id":"2-2-call-方法","index":"1.2.2"},{"title":"2.3.apply()方法","id":"2-3-apply-方法","index":"1.2.3"},{"title":"2.4.原型链","id":"2-4-原型链","index":"1.2.4"},{"title":"2.5.混合的对象冒充和原型方式","id":"2-5-混合的对象冒充和原型方式","index":"1.2.5"}]}]}]}