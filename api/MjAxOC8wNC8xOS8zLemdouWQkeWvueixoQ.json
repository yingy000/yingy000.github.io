{"title":"3-面向对象","date":"2018-04-19T09:15:30.000Z","link":"2018/04/19/3-面向对象","tags":["JavaScript"],"categories":["前端"],"updated":"2018-10-12T14:41:27.541Z","content":"<p>ECMA-262(ECMAScript5.1的规范)把对象定义为<code>&quot;属性的无序集合&quot;</code>，每个属性存放一个原始值、对象或函数。也就是说，对象是无特定顺序的值的数组。但它更通用的定义是基于代码的名词(人、地点或事物)表示。</p>\n<p>对象定义存放在构造函数中，构造函数并不是一种特殊函数，它只不过是用于创建对象的常规函数。</p>\n<h2 id=\"1-面向对象特征\">1.面向对象特征<a href=\"2018/04/19/3-面向对象#1-面向对象特征\"></a></h2><p>封装—把相关的信息（无论数据或方法）存储在对象中的能力</p>\n<p>聚集—把一个对象存储在另一个对象内的能力</p>\n<p>继承—由另一个类得到另一个对象内的能力</p>\n<p>多态—编写以多种方法运行的函数或方法的的能力</p>\n<h2 id=\"2-对象的构成\">2.对象的构成<a href=\"2018/04/19/3-面向对象#2-对象的构成\"></a></h2><p>在ECMAScript中，对象由特性<code>(attribute)</code>构成，特性可以是原始值，也可以是引用值，如果特性存放的是函数，它将被看作是对象的方法，否则该特性被看作属性。</p>\n<h2 id=\"3-对象应用\">3.对象应用<a href=\"2018/04/19/3-面向对象#3-对象应用\"></a></h2><h3 id=\"3-1-声明和实例化\">3.1.声明和实例化<a href=\"2018/04/19/3-面向对象#3-1-声明和实例化\"></a></h3><p>对象是由关键字new后跟要实例化的类的名字创建的。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj=new Object();</span><br></pre></td></tr></table></div></figure>\n<p>创建了一个Object类的实例，并把它存储在变量obj中</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=new String();</span><br></pre></td></tr></table></div></figure>\n<p>创建了一个String类的实例，并把它存储在变量str中</p>\n<p>如果构造函数无参数，括号则不是必须的。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj=new Object;</span><br><span class=\"line\"></span><br><span class=\"line\">var str=new String;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"3-2-对象引用\">3.2.对象引用<a href=\"2018/04/19/3-面向对象#3-2-对象引用\"></a></h3><p>在ECMAScript中，不能访问对象的物理表示，只能访问对象的引用。每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。</p>\n<h3 id=\"3-3-对象废除\">3.3.对象废除<a href=\"2018/04/19/3-面向对象#3-3-对象废除\"></a></h3><p>ECMAScript有<code>&quot;无用存储单元收集程序&quot;</code>，意味着不必专门销毁对象来释放内存。当再没有对该对象的引用时，称该对象被废除了。</p>\n<p>运用<code>&quot;无用存储单元收集程序&quot;</code>时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序都会自动运行，释放所有的局部变量，还有在一些其他不可预知的情况下，无用存储单元收集程序也会运行。</p>\n<p>把对象的所有引用都设置为null，可以强制性的废对象。</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj=new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">obj=null;</span><br></pre></td></tr></table></div></figure>\n<p>当变量obj设置为null后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。</p>\n<h3 id=\"3-4-早绑定和晚绑定\">3.4.早绑定和晚绑定<a href=\"2018/04/19/3-面向对象#3-4-早绑定和晚绑定\"></a></h3><p>不太懂，还有待研究。</p>\n<p>绑定：把对象的接口与对象实例结合在一起的方法。</p>\n<p>早绑定：在实例化对象之前定义它的特定和方法，这样编译器或解释程序就能提前转换机器代码。</p>\n<p>晚绑定：指的是编译器或解释程序在运行前，不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。ECMAScript中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p>\n","prev":{"title":"3-宿主对象","link":"2018/04/20/3-对象的类型-宿主对象"},"next":{"title":"3-作用域","link":"2018/04/17/3-作用域"},"plink":"http://yoursite.com/2018/04/19/3-面向对象/","toc":[{"title":"1.面向对象特征","id":"1-面向对象特征","index":"1"},{"title":"2.对象的构成","id":"2-对象的构成","index":"2"},{"title":"3.对象应用","id":"3-对象应用","index":"3","children":[{"title":"3.1.声明和实例化","id":"3-1-声明和实例化","index":"3.1"},{"title":"3.2.对象引用","id":"3-2-对象引用","index":"3.2"},{"title":"3.3.对象废除","id":"3-3-对象废除","index":"3.3"},{"title":"3.4.早绑定和晚绑定","id":"3-4-早绑定和晚绑定","index":"3.4"}]}]}