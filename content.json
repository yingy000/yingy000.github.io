{"meta":{"title":"天使在人间の博客","subtitle":null,"description":null,"author":"Yang Ying","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"RGB格式文件","slug":"C-2018-10-25","date":"2018-10-25T13:26:53.000Z","updated":"2018-10-15T12:42:58.089Z","comments":true,"path":"2018/10/25/C-2018-10-25/","link":"","permalink":"http://yoursite.com/2018/10/25/C-2018-10-25/","excerpt":"","text":"","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像文件格式","slug":"图像文件格式","permalink":"http://yoursite.com/tags/图像文件格式/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"YUV格式文件","slug":"C-2018-10-24","date":"2018-10-24T09:50:18.000Z","updated":"2018-10-15T12:42:56.795Z","comments":true,"path":"2018/10/24/C-2018-10-24/","link":"","permalink":"http://yoursite.com/2018/10/24/C-2018-10-24/","excerpt":"","text":"","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像文件格式","slug":"图像文件格式","permalink":"http://yoursite.com/tags/图像文件格式/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"拜耳阵列","slug":"C-2018-10-23","date":"2018-10-23T03:59:30.000Z","updated":"2018-10-15T09:52:20.266Z","comments":true,"path":"2018/10/23/C-2018-10-23/","link":"","permalink":"http://yoursite.com/2018/10/23/C-2018-10-23/","excerpt":"","text":"","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像文件格式","slug":"图像文件格式","permalink":"http://yoursite.com/tags/图像文件格式/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"Sublime之常用命令","slug":"C-2018-10-22","date":"2018-10-22T08:53:29.000Z","updated":"2018-10-15T03:58:49.678Z","comments":true,"path":"2018/10/22/C-2018-10-22/","link":"","permalink":"http://yoursite.com/2018/10/22/C-2018-10-22/","excerpt":"","text":"1.goto_line2.insert_snippet3.prompt_select_project4.run_macro_file5.insert6.move_to","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之Extending Sublime Text","slug":"C-2018-10-19","date":"2018-10-19T15:08:50.000Z","updated":"2018-10-12T13:00:32.082Z","comments":true,"path":"2018/10/19/C-2018-10-19/","link":"","permalink":"http://yoursite.com/2018/10/19/C-2018-10-19/","excerpt":"","text":"8.Extending Sublime Text(扩展Sublime)8.1.Commands(命令)8.1.1.Command Dispatching(命令调度)一般情况下，命令绑定到应用程序对象，窗口对象或视图对象。 8.1.2.Anatomy of a Command(命令分析)123view.run_command(&quot;goto_line&quot;, &#123;&quot;line&quot;: 10&#125;) //查看第10行代码view.run_command(&apos;insert_snippet&apos;, &#123;&quot;contents&quot;: &quot;&lt;$SELECTION&gt;&quot;&#125;) //插入代码段view.window().run_command(&quot;prompt_select_project&quot;) // 8.1.3.Reference for commands(命令参考)文件格式：.sublime-command文件 参考命令文档：https://docs.sublimetext.info/en/latest/reference/commands.html 8.2.Macros(宏)宏是包含命令序列的基本自动化设施。 宏文件是具有扩展名的JSON文件.sublime-macro，在Sublime中附带了一组提供核心功能的宏。 打开方式：Tools | Macros 图55 8.2.1.How to Record Macros(如何编辑宏)需要将扩展名为.sublime-macro的文件放在Packages/User文件夹下即可，这时在Sublime主界面中就会出现Tools | Macros下出现一个新的宏。 图56 宏文件的格式： 1234[ &#123;&quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;hardeol&quot;&#125;&#125;, &#123;&quot;command&quot;: &quot;insert&quot;, &quot;args&quot;: &#123;&quot;characters&quot;: &quot;\\n&quot;&#125;&#125;] 参考命令文档：https://docs.sublimetext.info/en/latest/reference/commands.html 8.2.2.Where to Store Macros(存储宏的位置)存储位置：Tools | Macros | &lt;PackageName&gt; 8.3.智能模板有时可能需要一次又一次地使用某些短文本片段，这时就可以创建一个智能模板，插入文本中并且适应其上下文。 创建新代码段的方式：Tools | Developer | New Snippet 存储位置：Packages/User文件夹 它们是带有.sublime-snippet扩展名的简化XML文件 8.3.1.片段文件格式典型智能模板格式：123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[Type your snippet here]]&gt;&lt;/content&gt; &lt;!-- Optional: Tab trigger to activate the snippet --&gt; &lt;tabTrigger&gt;xyzzy&lt;/tabTrigger&gt; &lt;!-- Optional: Scope the tab trigger will be active in --&gt; &lt;scope&gt;source.python&lt;/scope&gt; &lt;!-- Optional: Description to show in the menu --&gt; &lt;description&gt;My Fancy Snippet&lt;/description&gt;&lt;/snippet&gt; snippet元素包含Sublime需要的所有信息，以便知道要插入什么，是否插入以及何时插入。 1.content 2.tabTrigger 3.scope 4.description 8.3.2.片段功能片段可以以环境变量的形式访问上下文信息","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之color schemes","slug":"C-2018-10-18","date":"2018-10-18T07:43:47.000Z","updated":"2018-10-15T12:42:17.858Z","comments":true,"path":"2018/10/18/C-2018-10-18/","link":"","permalink":"http://yoursite.com/2018/10/18/C-2018-10-18/","excerpt":"","text":"7.配色方案7.1.Overview(介绍)颜色方案定义用于在Sublime视图中突出显示源代码的颜色，并定义在编辑区域中找到的不同元素的样式：background、selection等。 7.2.File Format(文件格式) 7.3.Where to Store Color Schemes(存储配色方案的位置)Preferences → Color Scheme 所有配色方案文件共享相同的最顶层结构 7.4.Structure of a Color Scheme File(颜色方案文件的结构)所有配色方案文件共享相同的最顶层结构。 7.4.1.Topmost Elements in Color Schemes Files(颜色方案文件中最顶层的元素)1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;Monokai&lt;/string&gt; &lt;key&gt;settings&lt;/key&gt; &lt;array&gt; &lt;!-- INSERT DICTIONARIES WITH COLOR SETTINGS HERE --&gt; &lt;/array&gt; &lt;key&gt;uuid&lt;/key&gt; &lt;string&gt;D8D5E82E-3D5B-46B5-B38E-8C841C21347D&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; name：可选的，配色方案的名称。 settings：用于进一步配色设置的容器 uuid：可选的，文件的唯一标识符 7.4.2.Sub-elements of Settings(设置的子元素)Global Settings(全局设置)12345678910111213&lt;array&gt; &lt;dict&gt; &lt;key&gt;settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;background&lt;/key&gt; &lt;string&gt;#272822&lt;/string&gt; &lt;key&gt;caret&lt;/key&gt; &lt;string&gt;#F8F8F0&lt;/string&gt; ... &lt;/dict&gt; &lt;/dict&gt;...&lt;/array&gt; 1.General foreground：视图的默认前景色 background：视图的默认背景色 invisibles caret：插入符号的颜色 lineHighlight：插入符号所在的颜色 2.Brackets bracketContentsOptions bracketContentsForeground bracketsOptions bracketsForeground 3.Tags tagsOptions tagsForeground 4.Find(查找) findHighlight：与当前搜索匹配的区域的背景颜色 findHighlightForeground：与当前搜索匹配的区域的前景颜色 5.Gutter gutter gutterForeground(前景色) 6.Selection(选择) selection：选择区域的颜色 selectionBorder：选取的边界颜色 inactiveSelection：非活动选择的颜色 7.Guides(指南) guide：显示指南的颜色以指示嵌套级别。 activeGuide：指南的颜色与插入符号对其 stackGuide：当前指南的父指南级别的颜色 8.Highlighted Regions(突出显示的区域) highlight highlightForeground 9.shadow(阴影) shadow：滚动缓冲区时阴影效果的颜色 shadowWith：滚动缓冲区时阴影效果的宽度 大于32的值会导致阴影被隐藏，默认值为8。 Scoped Settings(范围设置)范围设置是指与特定范围关联的设置。 123456789101112131415&lt;array&gt; ... &lt;dict&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;Comment&lt;/string&gt; &lt;key&gt;scope&lt;/key&gt; &lt;string&gt;comment&lt;/string&gt; &lt;key&gt;settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;foreground&lt;/key&gt; &lt;string&gt;#75715E&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; ...&lt;/array&gt; name：项目的描述性名称 scope：目标范围名称 settings：设置容器，它的有效取值为fontStyle、foreground、background。 fontStyle：以空格分割的字体样式列表 foreground：前景色 background：背景色 7.5.Minimal Scope Coverage(最小范围覆盖范围)7.6.Sublime Text Settings Related to Color(与颜色方案相关的Sublime文本设置)7.6.1.View Settings(查看设置)文件位置：Packages/Color Scheme - Default/Monokai.tmTheme","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之Menus","slug":"C-2018-10-17","date":"2018-10-17T14:07:50.000Z","updated":"2018-10-15T12:42:34.188Z","comments":true,"path":"2018/10/17/C-2018-10-17/","link":"","permalink":"http://yoursite.com/2018/10/17/C-2018-10-17/","excerpt":"","text":"6.4.Menus(菜单)6.4.1.File Format(文件格式) 举例：1234567891011121314151617181920212223242526[ &#123; &quot;caption&quot;: &quot;Edit&quot;, &quot;mnemonic&quot;: &quot;E&quot;, &quot;id&quot;: &quot;edit&quot;, &quot;children&quot;: [ &#123; &quot;command&quot;: &quot;undo&quot;, &quot;mnemonic&quot;: &quot;U&quot; &#125;, &#123; &quot;command&quot;: &quot;redo_or_repeat&quot;, &quot;mnemonic&quot;: &quot;R&quot; &#125;, &#123; &quot;caption&quot;: &quot;Undo Selection&quot;, &quot;children&quot;: [ &#123; &quot;command&quot;: &quot;soft_undo&quot; &#125;, &#123; &quot;command&quot;: &quot;soft_redo&quot; &#125; ] &#125;, &#123; &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;clipboard&quot; &#125;, &#123; &quot;command&quot;: &quot;copy&quot;, &quot;mnemonic&quot;: &quot;C&quot; &#125;, &#123; &quot;command&quot;: &quot;cut&quot;, &quot;mnemonic&quot;: &quot;t&quot; &#125;, &#123; &quot;command&quot;: &quot;paste&quot;, &quot;mnemonic&quot;: &quot;P&quot; &#125;, &#123; &quot;command&quot;: &quot;paste_and_indent&quot;, &quot;mnemonic&quot;: &quot;I&quot; &#125;, &#123; &quot;command&quot;: &quot;paste_from_history&quot;, &quot;caption&quot;: &quot;Paste from History&quot; &#125; ] &#125;] 作用于(图像) 6.4.2.&quot;Menu Items&quot; object(菜单项对象)菜单项的所有属性： command：选择菜单项时要调用的命令的名称。 args：命令参数的对象 caption：要在菜单中显示的文本(标题) children：&quot;菜单项&quot;对象列表(子菜单) mnemonic：用于菜单加速器的单个字符 id：菜单项的唯一字符串识别符 为了正常运行，每个菜单项都必须至少定义children、Id、command或者caption 使用规则： 带子菜单的菜单项无法调用命令。 如果没有提供caption(标题)，则从命令的description方法推断出标题，如果既未提供标题也为提供命令，则标题将为空字符串。 用于mnemonic的字符必须包含在项目的标题中，mnemonic区分大小写。 菜单项可以通过其引用的命令隐藏或禁用。 6.4.3.Available Menus(可用菜单)文件的文件名.sublime-menu指定要在应用程序中修改的菜单。 当单击状态栏的相应部分时，会打开以下四个菜单 Encoding Line Endings Indentations Syntax 6.4.4.Separators(分隔符)分隔符时带有标题的菜单项，&quot;-&quot;没有子菜单，它们通常用于对具有类似目的或其他相关目的的菜单项进行分组。分隔符无法调用命令，子菜单的存在会导致菜单分隔符呈现为常规项目，并使用单个连字符作为其标题。 6.4.4.Menu Merging(菜单合并).sublime-menu文件以英文字母的顺序加载，除非指定了ID，否则将连接具有相同名称的菜单文件。 从根文件夹开始按字典顺序加载同一包中的菜单文件，然后以相同的方式遍历子文件夹。 注意：菜单的标准非ID部分中声明的用户包中的菜单项始终插入到其他包中的任何标准项之后。 Items IDs当菜单项指定ID时，将搜索菜单中的单独部分，如果不存在，就在菜单末尾创建，这个ID查找仅仅是前进的， ID确定部分的名称，具有匹配ID的菜单项将是此部分中的第一项，然后文件中的后续项目将附加到ID的部分，直到找到具有ID的另一个项目。 举例：目前有以下主菜单： 123456[ &#123; &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;clipboard&quot; &#125;, &#123; &quot;command&quot;: &quot;copy&quot; &#125;, &#123; &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;selection&quot; &#125;, &#123; &quot;command&quot;: &quot;select_all&quot; &#125;] 如果希望在添加条目后插入菜单条目粘贴(clipboard)，需要创建插入文本： 1234[ &#123; &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;clipboard&quot; &#125;, &#123; &quot;command&quot;: &quot;paste&quot; &#125;] 6.4.5.Submenus(子菜单)每个菜单项都可以有一个子菜单，将鼠标指针悬停在具有子菜单的菜单项上将显示在其下分组的项目，子菜单是具有自己的ID层次结构的独立菜单。 6.4.6.The Main Menu(主菜单)主菜单的根菜单代表菜单栏中的菜单项。 6.4.7.Interface for Commands(命令接口)菜单项可以是动态的： hidden(隐藏) disabled checked(检查) assigned a different caption(分配不同的标题) 不是很理解？？ 6.4.8.Context Menus in the Side Bar(侧栏中的上下文菜单)在侧栏的菜单中，它们提供不同的上下文信息，对于所选项目(一个或者多个)，选定的目录和文件作为列表传递给files参数中的指定命令。 6.5.Color Schemes(配色方案)配色方案是指突出显示源代码并定义编辑区域中某些项目的颜色，比如说背景、前景、装订线、插入符号、选择等。 6.5.1.Selecting a Color Scheme(选择配色方案)设置方式：Preferences → Color Scheme","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之Key Bindings","slug":"C-2018-10-16","date":"2018-10-16T07:08:28.000Z","updated":"2018-10-12T13:01:30.936Z","comments":true,"path":"2018/10/16/C-2018-10-16/","link":"","permalink":"http://yoursite.com/2018/10/16/C-2018-10-16/","excerpt":"","text":"6.3.Key Bindings(键绑定)6.3.3.Structure of a Key Binding(键绑定的结构)键映射是键绑定的数组，在键映射中都必须是所有的有效元素。 Keys：一组区分大小写的键，可以使用+符号制定修饰符。 Command：要执行的命令的名称。 args：要传递给的参数字典commamd，键必须是参数的名称command context：确定特定上下文的一系列条件 举例： 12345678 &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;insert_snippet&quot;, &quot;args&quot;: &#123;&quot;contents&quot;: &quot;\\n\\t$0\\n&quot;&#125;, &quot;context&quot;: [ &#123; &quot;key&quot;: &quot;setting.auto_indent&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125;, &#123; &quot;key&quot;: &quot;selection_empty&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true, &quot;match_all&quot;: true &#125;, &#123; &quot;key&quot;: &quot;preceding_text&quot;, &quot;operator&quot;: &quot;regex_contains&quot;, &quot;operand&quot;: &quot;\\\\&#123;$&quot;, &quot;match_all&quot;: true &#125;, &#123; &quot;key&quot;: &quot;following_text&quot;, &quot;operator&quot;: &quot;regex_contains&quot;, &quot;operand&quot;: &quot;^\\\\&#125;&quot;, &quot;match_all&quot;: true &#125; ]&#125; 6.3.4.Structure of a Context(上下文的结构)上下文根据插入符的位置或某个其他状态确定是否启用了给定的键绑定。 key：要查询其值得上下文的名称 operator：要对其key值执行的测试类型，默认为equal。 operand：返回的结果将key根据此值进行测试。 match_all：要求测试成功进行所有选择，默认为false。 6.3.5.Context Keys(上下文秘钥) auto_complete_visible：true(如果自动完成列表可见，则返回) has_next_field：true(如果下一个片段字段可用，则返回) has_prev_field：true 如果前一个片段字段可用，则返回。 num_selections：返回选择的数量。 overlay_visible：true 如果任何叠加层可见，则返回。 panel_visible：true 如果任何面板可见，则返回。 following_text：测试所选文本及其后面的文本，直到行尾。 preceding_text：测试直到并包括选择的行上的文本。 selection_empty：true 如果选择是空区域，则返回。 setting.x：返回x设置的值。 x可以是任何字符串。 text：将测试限制为所选文本。 selector：返回当前范围的名称。 panel_has_focus：true 如果面板具有输入焦点，则返回。 panel：true 如果给定的面板operand是可见的，则返回。 相同的键绑定可以映射到多个上下文，因此单个按键序列可以在不同的时间产生不同的结果。 举例：12345 &#123; &quot;keys&quot;: [&quot;escape&quot;], &quot;command&quot;: &quot;clear_fields&quot;, &quot;context&quot;: [ &#123; &quot;key&quot;: &quot;has_next_field&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125; ]&#125; 如果有可用的下一个片段字段，ESC键绑定将转换为清除片段字段并恢复正常编辑。 6.3.6.Context Operators(上下文运算符) equal， not_equal（测试平等） regex_match， not_regex_match 匹配正则表达式（完全匹配） regex_contains， not_regex_contains 匹配正则表达式（部分匹配） 6.3.7.Bindable Keys(可绑定键)所有有效名称的列表： up down right left insert home end pageup pagedown backspace delete tab enter pause escape space keypad0 keypad1 keypad2 keypad3 keypad4 keypad5 keypad6 keypad7 keypad8 keypad9 keypad_period keypad_divide keypad_multiply keypad_minus keypad_plus keypad_enter clear f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 f19 f20 sysreq break context_menu browser_back browser_forward browser_refresh browser_stop browser_search browser_favorites browser_home 6.3.8.Modifiers(修饰符) shift ctrl alt super(Windows键，命令键……) 6.3.9.Order of Preference for Key Bindings(键绑定的优先顺序)键盘映射文件中的键绑定从底部到顶部进行评估，第一个匹配的上下文优先级最高。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之Customizing Sublime Text","slug":"C-2018-10-15","date":"2018-10-15T13:05:14.000Z","updated":"2018-10-12T13:06:31.106Z","comments":true,"path":"2018/10/15/C-2018-10-15/","link":"","permalink":"http://yoursite.com/2018/10/15/C-2018-10-15/","excerpt":"","text":"6.Customizing Sublime Text(自定义Sublime文本)6.1.Setting(设置)6.1.1.Format(格式)设置文件使用JSON并具有.sublime-settings扩展名 6.1.2.Types of Settings(设置类型)每个.sublime-settings文件的名称决定了它的用途，名称可以是描述性的，也可以与设置文件控制的内容相关。 举例： Preferences (Windows).sublime-settings Minimap.sublime-settings Python.sublime-settings等 6.1.3.How to Access and Edit Common Settings Files(如何访问和编辑常用设置文件)Preferences | Settings - User 6.1.4.Order of Precedence of .sublime-settings Files(.sublime-settings文件的优先顺序)任何给定的设置文件Packages/User最终都会覆盖同名的所有其他设置文件，也就是说，我们只需要将自己创建的.sublime-settings文件最终需要放在Packages/User文件夹中即可。 文件的优先级排序 Packages/Default/Preferences.sublime-settings Packages/Default/Preferences (Windows).sublime-settings Packages/User/Preferences.sublime-settings Packages/Python/Python.sublime-settings Packages/User/Python.sublime-settings Session data for the current file Auto adjusted settings 6.1.5.Global Editor Settings and Global File Settings(全局编辑器设置和全局文件设置)全局文件存储在Preferences.sublime-settings和文件中 6.1.6.File Type Settings(文件类型设置)如果要定位特定文件类型，请在文件类型的语法定义后命名.sublime-settings文件。 6.1.7.The Settings Hierarchy(设置层次结构)Sublime Text在Windows上处理Python文件设置的假设层次结构的顺序 Packages/Default/Preferences.sublime-settings Packages/Default/Preferences (Windows).sublime-settings Packages/AnyOtherPackage/Preferences.sublime-settings Packages/AnyOtherPackage/Preferences (Windows).sublime-settings Packages/User/Preferences.sublime-settings 当前项目的设置 Packages/Python/Python.sublime-settings Packages/Python/Python (Windows).sublime-settings Packages/User/Python.sublime-settings 当前文件的会话数据 自动调整设置 6.1.8.Where to Store User Settings(Once Again)(存储用户设置的位置)将相应的.sublime-settings文件放入Packages/User中 6.2.Indentation(缩进)缩进设置确定制表位的大小，并控制制表键是否应插入制表符或空格。 6.2.1.设置tab_size Integer. The number of spaces a tab is considered equal to. 翻译：整数，选项卡被视为等于的空格数 translate_tabs_to_spaces Boolean, if true, spaces will be inserted up to the next tab stop when tab is pressed, rather than inserting a tab character. 翻译：布尔值，如果为true，则在按下选项卡时，空格将插入到下一个制表位，而不是插入制表符。 detect_indentation Boolean, if true (the default), tab_size and translate_tabs_to_spaces will be calculated automatically when loading a file. 翻译：Boolean，如果为true（默认值），则在加载文件时将自动计算tab_size和translate_tabs_to_spaces use_tab_stops Boolean, If translate_tabs_to_spaces is true, use_tab_stops will make tab and backspace insert/delete up to the next tab stop. 翻译：Boolean，如果translate_tabs_to_spaces为true，则use_tab_stops将使tab和退格插入/删除到下一个制表位。 6.2.2.自动缩进auto_indent Boolean, enabled by default. Enables auto indent. 翻译：布尔值，默认启用，启用自动缩进。 smart_indent Boolean, enabled by default. Makes auto indent a little smarter, e.g., by indenting the next line after an if statement in C. 翻译：布尔值，默认启用，使自动缩进更智能一些，例如，通过在C语句中的if语句后缩进下一行。 trim_automatic_white_space Boolean, enabled by default. Trims white space added by auto_indent when moving the caret off the line. 翻译：布尔值，默认启用，在将插入符号移离线条时，修剪auto_indent添加的空白区域。 indent_to_bracket Boolean, disabled by default. Adds whitespace up to the first open bracket when indenting. Use when indenting like this: 翻译：布尔值，默认情况下禁用。在缩进时将空格添加到第一个开括号。在缩进时使用如下： 12use_indent_to_bracket（to_indent， like_this）; 6.3.Key Bindings(键绑定)6.3.1.File Format(文件格式)键绑定存储在.sublime-keymap文件中并在JSON中定义，键映射文件可以放在包中的任何位置。 在同一个软件包中，可能存在用于Linux、OSX和Windows的单独秘钥映射文件，以便更好地集成OS。 6.3.2.Naming Keymap Files(命名键映射文件)文件位置：C:\\Users\\dell\\AppData\\Roaming\\Sublime Text 3\\Packages\\User 为了覆盖默认键绑定或添加新建绑定，应该使用具有更高优先级的单独键盘映射文件。 文件名称：Default.sublime-keymap 不同平台： Default (Windows).sublime-keymap Default (Linux).sublime-keymap Default (OSX).sublime-keymap","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之基本概念","slug":"C-2018-10-12","date":"2018-10-12T10:34:01.000Z","updated":"2018-10-12T14:44:09.246Z","comments":true,"path":"2018/10/12/C-2018-10-12/","link":"","permalink":"http://yoursite.com/2018/10/12/C-2018-10-12/","excerpt":"","text":"1.基本的概念1.1.软件包目录查看已经安装的软件包目录：Preferences → Browse Packages… 位置：C:\\Users\\dell\\AppData\\Roaming\\Sublime Text 3\\Packages 1.2.数据目录数据目录的位置：%APPDATA%\\Sublime Text 3 1.3.用户包目录用户目录的位置：Packages/User 1.4.Sublime是可编程的Sublime使具有编程技巧的用户能够将自己的功能添加到编辑器中，怎么添加？？？ Sublime Text通过应用程序编程接口（API）公开其内部，程序员可以使用Python编程语言进行交互。编辑器中包含一个嵌入式Python解释器。嵌入式解释器可用于检查编辑器的设置，并在开发插件时快速测试API调用。 1.5.控制台Sublime将信息输出到控制台，在主菜单中选择View → Show Console可以打开控制台。 1.6.Sublime的配置文件2.编辑2.1.多个选择按住Ctrl+D键 2.2.将多个选择转换为行按住Ctrl+L键 2.3.列选择Ctrl+Alt+向上 3.搜索和替换3.1.搜索-单个文件 3.2.搜索-多个文件 3.2.常用表达1(?:Sw|P)i(?:tch|s&#123;2&#125;)\\s(?:it\\s)?of&#123;2&#125;! 3.4.在Sublime文本中使用正则表达式需要在命令面板中激活一下 4.构建系统(批处理)4.1.含义构建系统(build system)是用来从源代码生成用户可以使用的目标(targets)的自动化工具。目标可以包括库、可执行文件、或者生成的脚本等等。 4.2.文件格式构建系统是JSON文件并具有扩展名.sublime-build。 4.3.举例12345&#123; &quot;cmd&quot;: [&quot;python&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;&#125; 4.3.1.cmdRequired. This option contains the actual command line to be executed: 此选项包含要执行的实际命令行 1python -u /path/to/current/file.ext 4.3.2.file_regex1A Perl-style regular expression to capture error information from an external program’s output. This information is used to help you navigate through error instances with F4. 翻译： Perl样式的正则表达式，用于从外部程序的输出中捕获错误信息，此信息用于帮助您浏览错误实例F4。 4.3.3.selector12If the Tools | Build System | Automatic option is set, Sublime Text will automatically find the corresponding build system for the active file by matching selector to the file’s scope. 翻译：如果 工具| 构建系统| 设置了自动选项，Sublime Text将通过匹配selector文件的范围自动找到活动文件的相应构建系统。 4.4.存储构建系统的位置构建系统必须位于Packages文件夹下的某个位置，许多软件包都包含自己的构建系统，也就是位于Packages/User下。 4.5.运行构建系统可以通过按F7或从Tools → Build来运行构建系统。 5.文件管理和导航5.1.项目项目元数据存储在带有.sublime-project扩展名的JSON文件中。只要有.sublime-project文件，也会存在辅助.sublime-workspace文件。 5.1.1.创建项目Project → Save Project As…. 5.1.2.打开项目 Projects → Switch Project… Projects → Open Recent Projects → Quick Switch Project…. 5.1.3.项目文件的高级配置5.1.4.与侧栏和项目相关的设置binary_file_patterns：通配符列表 位置：Preferences -&gt; Settings - Default C:\\Users\\dell\\AppData\\Roaming\\Sublime Text 3\\Packages\\User 5.1.5.工作区工作区包含与项目关联的会话数据，其中包括有关已打开文件，窗格布局，查找历史记录等的信息等。 工作区元数据存储在带有.sublime-workspace扩展名的JSON文件中。 5.2.文件导航5.2.1.Goto Anything5.2.2.Goto Anything Operators举例: 123models:100This instructs Sublime Text to first search for a file whose path matches models, and then to go to line 100 in said file. 翻译： 这指示Sublime Text首先搜索路径匹配的文件models，然后转到所述文件中的第100行。 5.2.3.Supported Operators(支持的运算符) @symbol #item :line_number 5.2.4.Sidebar(侧栏)侧栏通过其上下文菜单提供基本文件管理操作。 从侧边栏打开的文件会创建半瞬态视图，半瞬态视图显示为新选项卡，半瞬态视图的选项卡标题以斜体显示。在打开新的半瞬态视图之前，同一窗格中的任何其他预先存在的半瞬态视图将自动关闭。 半瞬态视图和瞬态视图的区别 5.2.5.Panes(窗格)通过View → Layout可以设置多种形式的窗格","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime之命令面板","slug":"C-2018-10-11","date":"2018-10-11T15:09:38.000Z","updated":"2018-10-12T13:01:49.090Z","comments":true,"path":"2018/10/11/C-2018-10-11/","link":"","permalink":"http://yoursite.com/2018/10/11/C-2018-10-11/","excerpt":"","text":"1.About2.Autoprefix CSS3.Bookmarks4.BracketHighlighter5.Build6.Changelog7.Code Folding8.Color Picker9.Convert Case10.DocBlockr11.Emmet12.File13.FileDiffs14.Git15.HTML16.","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime编辑器的了解","slug":"C-2018-10-10","date":"2018-10-10T12:52:52.000Z","updated":"2018-10-12T13:01:59.720Z","comments":true,"path":"2018/10/10/C-2018-10-10/","link":"","permalink":"http://yoursite.com/2018/10/10/C-2018-10-10/","excerpt":"","text":"1.主界面 use Multiple Selection to rename varibales quickly 使用多个选择来快速重命名变量 Quickly jump to files and functions with Goto Anything 快速跳转到文件和函数的任何东西 Navigate source using Goto Definition 使用Goto定义导航源 Unsurpassed performance 无与伦比的性能 2.名词的解释2.1.Goto Anything(转到任何东西)12345678Use Goto Anything to open files with only a few keystrokes, and instantly jump to symbols, lines or words.Triggered with Ctrl+P, it is possible to:Type part of a file name to open it.Type @ to jump to symbols, # to search within the file, and : to go to a line number.These shortcuts can be combined, so tp@rf may take you to a function read_file within a file text_parser.py. Similarly, tp:100 would take you to line 100 of the same file. 翻译： 使用Goto Anything只需几次击键即可打开文件，并立即跳转到符号，行或单词。 使用Ctrl + P触发，可以： 输入文件名的一部分以将其打开 输入@以跳转到符号 #在文件中搜索 :转到行号 这些快捷键可以合并使用，会节省许多时间。举例： tp:100会带到文件名为text_parser.py的第100行。 2.2.Goto Definition(转到定义)123456Using information from syntax definitions, Sublime Text automatically generates a project-wide index of every class, method and function. This index powers Goto Definition, which is exposed in three different ways:A popup is displayed when hovering over a symbolPressing F12 when the caret is on a symbolThe Goto Symbol in Project functionalitySymbol indexing can be customized on a per-syntax basis via configuration files, allowing users to tailor the feature to their needs. 翻译： 使用语法定义中的信息，Sublime Text自动生成每个类，方法和函数的项目范围索引。该索引支持Goto Definition(转到定义)，它以三种不同的方式公开： 将鼠标悬停在符号上时会显示一个弹出窗口 当插入符号在符号上时按F12 项目功能中的转到符号可以通过配置文件在每个语法的基础上自定义符号索引，从而允许用户根据需要定制功能。 2.3.Multiple Selection(多项选项)1234Make ten changes at the same time, not one change ten times. Multiple selections allow you to interactively change many lines at once, rename variables with ease, and manipulate files faster than ever.Try pressing Ctrl+Shift+L to split the selection into lines and Ctrl+D to select the next occurrence of the selected word. To make multiple selections with the mouse, take a look at the Column Selection documentation. 翻译： 同时进行十次更改，而不是一次更改十次。多项选择允许您一次交互式更改多行，轻松重命名变量，并以前所未有的速度操作文件。 按住 Ctrl + Shift + L 将选区分为线，按Ctrl + D选择下一个选中的单词。 3.强大的功能3.1.Command Palette(命令面板)123The Command Palette holds infrequently used functionality, like sorting, changing the syntax and changing the indentation settings. With just a few keystrokes, you can search for what you want, without ever having to navigate through the menus or remember obscure key bindings.Show the Command Palette with Ctrl+Shift+P. 翻译： 命令面板包含不常用的功能，如排序，改变语法和更改缩进设置。只需几次操作，就可以搜索自己想要的内容，而无需浏览菜单或记住模糊的键绑定。 使用Ctrl + Shift + P显示命令选项板。 3.2.Powerful API and Package Ecosystem(强大的API和包生态系统)1234Sublime Text has a powerful, Python API that allows plugins to augment built-in functionality.Package Control can be installed via the command palette, providing simple access to thousands of packages built by the community. 翻译： Sublime Text有一个功能强大的Python API，允许插件增强内置功能。 可以通过命令面板安装Package Control，从而可以轻松访问社区构建的数千个包。 3.3.Customize Anything(定制任何东西)1Key bindings, menus, snippets, macros, completions and more - just about everything in Sublime Text is customizable with simple JSON files. This system gives you flexibility as settings can be specified on a per-file type and per-project basis. 翻译： 密钥绑定(Key bindings)，菜单(menus)，代码片段(snippets)，宏(macros)，完成(completions)等等 - 只需使用简单的JSON文件即可自定义Sublime Text中的所有内容。该系统为您提供了灵活性，因为可以在每个文件类型和每个项目的基础上指定设置。 3.4.Split editing(拆分编辑)123Get the most out of your wide screen monitor with split editing support. Edit files side by side, or edit two locations in the one file. You can edit with as many rows and columns as you wish. Take advantage of multiple monitors by editing with multiple windows, and using multiple splits in each window.Take a look at the View ▶ Layout menu for split editing options. To open multiple views into the one file, use the File ▶ New View into File menu item. 翻译： 通过分割编辑支持，充分利用宽屏显示器。并排编辑文件，或编辑一个文件中的两个位置。您可以根据需要使用尽可能多的行和列进行编辑。通过使用多个窗口进行编辑，并在每个窗口中使用多个拆分来利用多个监视器。 查看&quot;分割编辑&quot;选项的&quot;视图布局&quot;菜单。要在一个文件中打开多个视图，请使用&quot;文件▶新视图到文件&quot;菜单项。 3.5.Instant project switch(即时项目开关)1Projects in Sublime Text capture the full contents of the workspace, including modified and unsaved files. You can switch between projects in a manner similar to Goto Anything, and the switch is instant, with no save prompts - all your modifications will be restored next time the project is opened. 翻译： Sublime Text中的项目捕获工作区的全部内容，包括已修改和未保存的文件。您可以与Goto Anything类似的方式在项目之间切换，并且切换是即时的，没有保存提示 - 下次打开项目时将恢复所有修改。 3.6.Performance(性能)1Sublime Text is built from custom components, providing for unmatched responsiveness. From a powerful, custom cross-platform UI toolkit, to an unmatched syntax highlighting engine, Sublime Text sets the bar for performance. 翻译： Sublime Text由自定义组件构建，提供无与伦比的响应能力。从功能强大的自定义跨平台UI工具包到无与伦比的语法高亮引擎，Sublime Text设置了性能标准。 3.7.Cross platform(跨平台)1234Sublime Text is available for Mac, Windows and Linux. One license is all you need to use Sublime Text on every computer you own, no matter what operating system it uses.Sublime Text uses a custom UI toolkit, optimized for speed and beauty, while taking advantage of native functionality on each platform. 翻译： Sublime Text适用于Mac，Windows和Linux。无论使用何种操作系统，只需一个许可即可在您拥有的每台计算机上使用Sublime Text。 Sublime Text使用自定义UI工具包，针对速度和美感进行了优化，同时利用每个平台上的本机功能。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-AF Preformance Tuning(2)","slug":"C-2018-10-09","date":"2018-10-09T06:59:26.000Z","updated":"2018-10-12T14:32:32.838Z","comments":true,"path":"2018/10/09/C-2018-10-09/","link":"","permalink":"http://yoursite.com/2018/10/09/C-2018-10-09/","excerpt":"","text":"3.AF调试Parameter-Calibration3.1.了解AF CalibrationInfldxOffset：利用OTP中的远焦Calibration(校准)值，校正AF的Inf Position MacroldxOffset：利用OTP的近焦Calibration(校准)值，校正AF的Macro Position。 3.2.启动AF Calibration的条件1.SW Enable 2.OTP中存有AF Calibration Data 3.3.AF调试Parameter3.3.1.第一种Parameter(参数)控制AF时，几个Frame动一次Lens FRAME_WAIT[0]~[4]：如果移动步数大于FRAME_WAIT[i]，则FRAME_WAIT=i。 举例：FRAME_WAIT[0]=100 FRAME_WAIT[1]=200 FRAME_WAIT[2]=300 FRAME_WAIT[3]=400 FRAME_WAIT[4]=500 如果AF Step=60，&lt;FRAME_WAIT[0]，则AF时每个Frame都移动Lens，并取FV。 如果AF Step=150，&lt;FRAME_WAIT[1]，则AF时两个Frame移动一次，并取FV。 3.3.2.第二种Parameter(参数)用来控制AF的Parameter要根据哪些ISO进行区分，共有两种Scenario(情况)。 sAF_TH：Normal AF sZSD_AF_TH：ZSD AF ISONum： GMeanNum： ISO[0]~ISO[7]: 举例：ISONum=3 ISO[0]=100 ISO[1]=400 ISO[2]=800 3.3.3.第三种Parameter(参数) FV_DC[0][0]~[7][5] MIN_TH[0][0]~[7][5] HW_TH[0][0]~[7][5] FV_DC2[0][0]~[7][5] MIN_TH2[0][0]~[7][5] HW_TH2[0][0]~[7][5] GMR[0][0]~[7][2] 3.3.4.AF调试Parameter-磁滞补偿Scan方向不同，FV趋势图不同，且步数间等多久(磁滞现象) 3.3.5.第四种Parameter(参数) Hyst：此组Parameter控制Lens磁滞现象要补偿的步数 Hyst[0]：移动的步数间隔 Hyst[1]：要补偿的磁滞步数 举例：1234567891011Hyst[0][0]=100Hyst[0][1]=100Hyst[0][2]=100Hyst[0][4]=100Hyst[1][1]=100Hyst[1][2]=100 若Lens移动步数=50，磁滞补偿步数=4 若Lens移动步数=250，磁滞补偿步数=2 总结：移动步数越大，磁滞补偿越小 3.3.6.第五种Parameter(参数) BackJump：为了避免撞击声，当Lens往內缩时(移回远焦)，若Target Pos&lt;BackJupmp Pos，则分段移动。 BackJump[0]~[4]：分段移动的五个位置。 举例:BackJump[0]=0 BackJump[1]=50 BackJump[2]=150 BackJump[3]=250 BackJump[4]=350 Lens要由Pos 500移回50，为了避免撞击声，顺序为Pos 500-&gt;Pos 350-&gt;Pos 250-&gt;Pos 150-&gt;Pos 50。 3.3.7.第六种Parameter(参数) Coef[0]~[19]：借用Parameter。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-AF Preformance Tuning(1)","slug":"C-2018-10-08","date":"2018-10-08T15:05:01.000Z","updated":"2018-10-12T14:32:44.485Z","comments":true,"path":"2018/10/08/C-2018-10-08/","link":"","permalink":"http://yoursite.com/2018/10/08/C-2018-10-08/","excerpt":"","text":"1.了解AF现在大多数手机的AF都是被动式AF，也就是利用Focus Value Curve来对焦。 1.1.Focus Value的理解一般情况下，Focus Value越大代表越Sharp，也就意味着Focus Pos越接近焦点。 特殊情况： 若亮度太低，Gain太大，会导致Noise影响Focus Value。 过于Smooth没有Edge，导致Noise影响Focus Value。 1.2.被动式AF的目标找到Focus Value Curve，Focus Value最大的Focus Position。 如何在最短的时间内找到Peak Focus Value Position(AF的速度) 如何找到最准确的Peak Focus Value Position(AF的精度) 注意：速度和精度这两个特性很难同时满足，必须要依靠Trade-Off(平衡性)来取得最佳平衡。 1.3.被动式AF的动作 Single AF(SAF)：单按对焦键时，对中心的AF Window执行一次AF Touch AF(TAF)：单按荧幕时，对荧幕触点的位置执行一次AF。 Multi AF(MAF)：单按对焦键时，对中心的五块AF Window执行一次AF。 Continuous AF(CAF)：AF演算法持续对荧幕中心进行监控，当中心场景改变时，自动进行AF。 Single AF(SAF)&amp;&amp;Touch AF(TAF)使用同一组调试参数，其中包括AF搜索的范围、AF Table、AF的精度、AF的速度等，基本上表现都会相同。 Multi AF(MAF)虽然和SAF&amp;&amp;CAF使用相同的调试参数，但是由于MAF是五个Window同时对焦，且已最近焦的Window，因此Performance和行为表现会和SAF及TAF存在一些差异。 CAF为了保持对焦过程中画面的Smooth，因此没有使用AF Search Table，而是使用固定的AF Step进行搜索。 按照Focus Search Table搜索的作法 按照固定步数搜索的作法 2.AF调试Parameter(参数)-Thres2.1.了解Parameter(参数)-Thres2.1.1.原理从理论上来说，AF不需要搜寻整个AF Search Table，才能知道Peak FV Position。只要搜寻过程中FV值下降到一定程度，就可以确认已经找到Peak FV Position。 2.1.2.举例下图中的AF Table共有11个Steps，代表完整的AF Search，需要搜寻11个Step，但是可以看出FV从第7个Step后就开始下降，若是此时停止搜寻，AF可节省4个Step的时间。 2.1.3.特例当Focus Value Curve存在双峰现象，过早停止AF就会造成没有找到真正的清晰点，因此AF提前停止的条件必须小心。 注意:可能发生双峰现象的情形： AF Window内存在不同焦距的主体 Noise(噪音) 2.2.AF调试Parameter(参数)-Thres123456THRES_MAIN：AF搜索过程中，当THRES_SUB：(Max FV-Current_FV-THRES_OFFSET)/Max FV*100&gt;THRES_MAIN且 (Max FV-First_FV-THRES_OFFSET)/Max FV*100&gt;&gt;THRES_SUBTHRES_OFFSET：AF停止搜索 2.2.1.Current_FV&gt;First_FV当Current_FV&gt;First_FV，AF提前停止公式为： 123(Max FV-Current_FV-THRES_OFFSET)/Max FV*100&gt;THRES_SUB且(Max FV-First_FV-THRES_OFFSET)/Max FV*100&gt;&gt;THRES_MAI 2.2.2.Current_FV&gt;First_FV当Current_FV&lt;First_FV，AF提前停止公式为： 123(Max FV-Current_FV-THRES_OFFSET)/Max FV*100&gt;THRES_MAIN且(Max FV-First_FV-THRES_OFFSET)/Max FV*100&gt;&gt;THRES_SUB 2.3.AF Tuning的介绍 2.3.1.AF Search Range决定AF最近及最远的搜寻范围(优先权高于SearchTable) 2.3.2.AF Search Table决定sAF，ZSDAF，VCAF的搜寻位置 2.3.3.AF Tuning ParameterAF的调试参数 2.3.4.Get FV做完一次AF后，在FV的栏位中显示刚刚的FV 2.3.5.Clear FV清理上一次AF的FV 2.4.AF调试Parameter2.4.1.重要的文件AF Tuning File 2.4.2.AF调试Parameter(参数) 选择Level1时，可调整Commom的基本Parameter(参数) VAFC_FALL_CNT_DELTA：Video CAF专用，当搜寻方向改变超过此次次数时，停止Video CAF，并将Lens停在最佳Pos。 LV_THRES：Video CAF专用，当环境过暗时，不进行Video CAF，并将Lens停在最佳Pos。 SPOT_PERCENT_W：CAF Window位置 SPOT_PERCENT_H：CAF Window位置 InPos：infinity Mode的无穷尽位置 AFC_STEP_SIZE：Video CAF允许的最大一次移动步数。 BackJumpPos：当AF找到的Target Pos&lt;BackJumpPos，则分段前往Target Pos(为了避免撞击声) FDWinPercent：为了避免人脸框过大，框到不必要的资讯，因此照此百分比将人脸框內缩。 FDSizeDiff：当人脸的Size改变大于此数值时，会触发CAF重新对焦。 StatGain：HW Output的AF Value，先乘上此数值，才是最后FW使用的AF Value。 选择sAF_Coef时，AF按照下列三组Scenario(情况)区分Parameter sAF_Coef：SAF Parameter(用于非ZSD的SAF&amp;CAF) sZSD_AF_Coef：ZSD AF Parameter(用于非ZSD的SAF&amp;CAF) sVAFC_Coef：Video CAF(用于Video CAF) THERS_MAIN：判断AF停止搜寻&amp;合焦的主要条件 THERS_SUB：判断AF停止搜寻&amp;合焦的次要条件 INIT_WAIT：为了避免Lens缩回时发出撞击声，将Lens分段移动，最多分为五段(默认值为1) DONE_WAIT：CAF完成之后，等待多少Frame之后，才Get新的FV当做Reference(默认值是0) FALL_POS：AF失败时的Lens Default位置(默认值是0) 123FALL_POS=-1：停在FV最大的位置FALL_POS=Others：停在AF_Table[0]+FALL_POS的位置 FRAME_TIME：最短一个Frame的时间(Default是33，用来计算change count的数目) 当目前曝光时间长，Change count就少，当目前曝光时间短，Change count就多 FIRST_FV_WAIT：第一次进Camera，要等几个Frame才开始Get FV 2.4.3.AF算法参数-AFC灵敏度 取参数值：在前次对焦成功后，会等N个Frame，才会取FirstFV供scene change detection用。 N=(First_FV_WAIT*FRAME_TIME)/current_frame_time+CHANGE_CNT_DELTA 检测变化：连续ChangeCnt个frame的亮度或FV的变化超过TH，则判定为scene change。 ChangeCnt会依设定的Change_Cnt与current frame time调整 TH=MAX(FirstFV*THRES,CHANGE_OFFSET) 确认稳定：并在FV值Stable后，开始才可重新进行对焦 此机制与1st time camera launch相同，但有独立参数。 2.4.4.AF调试Parameter(参数)12345678910if(ABS(Reference FV-Current FV)&gt;FV_CHANGE_THRES_FINAL) FV_CNT++;if(ABS(Reference GS-Current GS)&gt;GS_CHANGE_THRES_FINAL) GS_CNT++;if(FV_CNT&gt;FV_CHANGE_CNT||GS_CNT&gt;GS_CHANGE_CNT) CAF Trigger;FV_CHANGE_THRES_FINAL=Max(Reference FV*FV_CHANGE_THRES,FV_CHANGE_OFFSET)GS_CHANGE_THRES_FINAL=Max(Reference GS*GS_CHANGE_THRES,GS_CHANGE_OFFSET) FV_CHANGE_THRES：FV判断CAF启动的条件(FV变化决定CAF启动)，越低越灵敏(默认是45) FV_CHANGE_OFFSET：FV判断CAF启动的条件(FV变化决定CAF启动)，越低越灵敏(默认是10000) FV_CHANGE_CNT：FV判断CAF启动的条件(FV变化决定CAF启动)，越低越灵敏(默认是12) GS_CHANGE_THRES：亮度判断CAF启动的条件(亮度变化决定CAF启动)，越低越灵敏(默认是0) GS_CHANGE_OFFSET：亮度判断CAF启动的条件(亮度变化决定CAF启动)，越低越灵敏(默认是20)。 GS_CHANGE_CNT：亮度判断CAF启动的条件(亮度变化决定CAF启动)，越低越灵敏(默认是12) FV_STABLE_THRES：CAF决定启动之后，Lens正式作动的条件(FV保持稳定，Lens正式作动)，越小，手机需越稳定Lens才作动。 FV_STABLE_OFFSET：CAF决定启动之后，Lens正式作动的条件(FV保持稳定，Lens正式作动)，越小，手机需越稳定Lens才作动。 FV_STABLE_NUM：CAF决定启动之后，Lens正式作动的条件(FV保持稳定，Lens正式作动)，越大，手机需越稳定Lens才作动。 FV_STABLE_CNT：CAF决定启动之后，Lens正式作动的条件(FV保持稳定，Lens正式作动)，越大，手机需越稳定Lens才作动。 在STABLE_NUM+1个frame中，检查是达到标准的次数是否超过STABLE_CNT。 FV_1ST_STABLE_THRES：第一次进入相机之后，CAF第一次启动的条件，Value越小，手机需越稳定CAF才作动。 FV_1ST_STABLE_OFFSET：第一次进入相机之后，CAF第一次启动的条件，Value越小，手机需越稳定CAF才作动。 FV_1ST_STABLE_NUM：第一次进入相机之后，CAF第一次启动的条件，Value越大，手机需越稳定CAF才作动。 FV_1ST_STABLE_CNT：第一次进入相机之后，CAF第一次启动的条件，Value越大，手机需越稳定CAF才作动。 在STABLE_NUM+1个frame中，检查是达到标准的次数是否超过STABLE_CNT。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-AE Preformance Tuning","slug":"C-2018-09-30","date":"2018-09-30T13:10:03.000Z","updated":"2018-10-12T14:32:51.793Z","comments":true,"path":"2018/09/30/C-2018-09-30/","link":"","permalink":"http://yoursite.com/2018/09/30/C-2018-09-30/","excerpt":"","text":"1.AE Tuning1.1.AE Tuning的原因 AE，是自动控制曝光的一种方法，让预览和成像的亮度符合使用者的期待。 由于自然界中不同的场景太多，若是只控制整体平均亮度，部分特殊场景的成像亮度无法满足客户的要求，因此需要AE Tuning来让这些特殊场景也满足需求。 1.2.AE Tuning模拟特殊场景 背光环境，若是仍然只用整体平均亮度当做目标，会导致主题过暗。 亮色纯色环境，若是仍然只用整体平均亮度当做目标，会导致感觉主题过暗(亮色场景通常会期望亮度高些) 1.3.调试方法1.3.1.调整Flare Offset控制ISP和Flare的数值，可以调整成像的对比度(但是可能牺牲暗部细节) 补充：ISP的主要作用是对前端图像传感器输出信号做后期处理，主要功能有线性纠正、噪声去除、坏点去除、白平衡、自动曝光控制等，ISP技术在很大程度上决定了相机的成像质量。 1.3.2.调整AE Target控制AE Target，可以调整最后整体平均亮度(控制整体平均亮度的做法，无法适用于所有场景) 1.3.3.调整AE Mode Condition根据目前场景，动态改变AE Target，可使多数场景的曝光符合期待(可能仍有少数场景的曝光亮度不符预期) 2.AE Tuning Page的基本操作 2.1.Pline initial ldxPline initial ldx：AE收敛的起点。 越低代表从越高环境亮度开始收敛，也就是说，若调的值过低，则刚进Camera时，亮度会较暗，然后收敛。 越高，代表从越低环境亮度开始收敛，也就是说，若调的值过高，则刚进Camera时，亮度会较亮，然后收敛。 2.2.Target mean：AE收敛的目标越低代表最后收敛的亮度越暗，越高代表最后收敛的亮度越亮。 2.3.AE Mode Tuning微调这四种AE Mode的条件Back ligth/Histogram stretch/Night Mode/Auto-over exposure用来和AE Target一起决定最后的收敛亮度。 2.4.Ev value calibrationcalibration AE估算的LV和实际LV的差异，主要是AWB演算法使用。 2.5.Parameter的基本操作Read NVRAM/Apply/Save to NVRAM 3.AE Tuning—Flare Tuning3.1.了解Flare Tuning Fix Flare(固定的Flare)：Raw File的Pixel扣固定的数值=&gt;Linear Domain中，整体亮度减去固定的数值。 Dynamic Flare(动态的Flare)： Raw File的Pixel根据Histogram的分布，动态的扣不固定的Flare数值。 由于Preview和Capture必须一致，所以Capture选择Dynamic Flare时，Preview也会自动切换成Dynamic Flare。 Flare Value：89 Fix Flare是12(bit)。 3.2.Flare Tuning Page 3.2.1.第一部分设定Preview，Capture，Video，Strobe是否要开放Dynamic Flare。 3.2.2.第二部分设定Preview，Capture，Video，Strobe扣得Flare，offset为Fix Flare，Threshold为Dynamic Flare。 3.2.3.第三部分设定Preview，Video Flare的最大值和最小值。 3.2.4.第四部分(操作方法)在&quot;AE Tuning&quot;Page设定Flare Read NVRAM：读取NVRAM中设定 Apply：将设定，写入Register Save to NVRAM：将设定，写入NVRAM 3.3.Flare Tuning—Fix Flare设定Fix Flare(不勾选Threshold) 设定Fix Flare的数值 按下&quot;Apply&amp;Save to NVRAM&quot;存储结果。 结果分析： Preview Fix Flare扣0~扣19 3.4.Flare Tuning—Dynamic Flare设定Dynamic Flare(勾选Threshold) 设定Fix Flare的数值 按下&quot;Apply&amp;Save to NVRAM&quot;存储结果。 结果分析： Fix Flare会将亮度&lt;Offset的值扣除，Dynamic Flare是将亮度&lt;threshold/10000的值扣除，因此Dynamic Flare在平均较亮的场景Flare扣较高，在平均较暗的场景Flare扣较少。 4.AE Tuning—AE Target Tuning4.1.了解AE Target TuningAE Target越高，预览成像亮度越高 AE Target越低，预览成像亮度越低 4.2.步骤设定&quot;Target mean&quot;的值 按下”Apply”，存入Register 按下”Save to NVRAM” 5.AE Tuning—AE Mode Tuning5.1.了解AE Mode Tuning1.&quot;Target mean&quot;的值为AE的Basic收敛值。 2.AE算法提供三种AE Mode Anti-Over Exposure：避免过曝 Back Light：避免因BackLight情形导致暗部偏暗(以暗部为主拉高亮度) Histogram：当主体对比不高时，拉高整体亮度(以亮部为主拉高亮度) 结论：基本上，AE是先设定一个较低的TargetMean，再by AE Mode拉高亮度。 3.Final Target Mean为三种AE Mode算出Target Mean的加权 5.2.AE Mode Tuning—Back Light当暗階的部分过暗时，会落入Backlight Condition。 当落入Backlight Condition，可调整对应的Thresold来改变亮度。 调高CentralHighBound：可提高BL Condition能拉高亮度的最大值 调低LowThres，可拉高落入BackLight Condition的概率 调高BacklightThres：可拉高落入BackLight Condition时预览及成像的亮度 图片内容可能不太准确，仅参考 5.3.AE Mode Tuning—Histogram Stretch当亮階的部分不够亮时，会落入Histogram Stretch Condition 当落入Histogram Stretch Condition，可调整对应的Thresold来改变亮度。 调高CentralHighBound：可提高Histogram Stretch Condition能拉高高度的最大值 调高HisStrechThresThres：可拉高落入Histogram Stretch Condition时预览及成像的亮度 图片内容可能不太准确，仅参考 5.4.AE Mode Tuning—Anti Over Exposure当亮階的部分过亮时，会落入Anti Over Exposure Condition 当落入Anti Over Exposure Condition时，可调整对应的Thresold来改变亮度。 由于Anti OverExposure条件一开放，容易将大部分场景亮度都拉的过低，因此建议不开放此条件 调低CentralLowBound：可降低Anti Over Exposure Condition能拉低亮度的最小值 调低HighThres，可拉高落入Anti Over Exposure Condition的概率 调低OverExposureThres：可拉低落入Anti Over Exposure Condition时预览及成像的亮度 图片内容可能不太准确，仅参考","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-AE Gen Table","slug":"C-2018-09-29","date":"2018-09-29T08:30:12.000Z","updated":"2018-10-12T14:33:00.382Z","comments":true,"path":"2018/09/29/C-2018-09-29/","link":"","permalink":"http://yoursite.com/2018/09/29/C-2018-09-29/","excerpt":"","text":"1.AE Gen Pline Table(生成AE Pline表格)1.1.了解AE Pline Table图片的亮度，由Shutter(曝光时间)、ISO(Gain值)、Aperture(光圈)和环境亮度决定。 AE Pline Table的用途：决定特定环境亮度，使用多少的Shutter(曝光时间)和ISO。 AE Pline Table差异的目的：适用于不同的场景 1.2.Sport Mode(运动模型) &amp;&amp; Candle Mode(静态模型) Sport Mode：物体移动迅速，因此当环境亮度降低时，不延长曝光时间，而是先加大ISO(物体移动时，曝光时间长会导致残影) Candle Mode：静态物体，当环境亮度降低时，先延长曝光时间，之后再考虑增大ISO(长时间曝光对静态物体无残影问题，为了避免Noise加大所以先延长曝光，ISO增大的同时会导致Noise增加) 2.Sensor Device Info建立AE Pline Table之前，首先需要得到Sensor Device Info，该文件由MTK提供。 2.1.2.Sensor Device Info的内容u4OBLevel：OB的数值 u4MinGain：能使Sensor饱和的最小Gain值(Gain值和亮度有关系) u4MaxGain：Sensor Support的最大Gain值 u4MinilSOGain：Sensor Gain为1024时的ISO u4GainStepUnitInTotalRange：Sensor Gain的最小单位 u4PreviewExposureLineUnit：Preview曝光时间最小单位 u4PreviewMaxFrameRate：Preview的最高FrameRate u4VideoExposureLineUnit：Video曝光时间最小单位 u4VideoMaxFrameRate：Video的最高Frame Rate u4VideoToPreviewSensitivityRatio：Video感光度和Preview感光度的比例 u4CaptureExposureLineUnit：Capture曝光时间最小单位 u4CaptureMaxFrameRate：Capture的最高FrameRate u4CaptureToPreviewSensitivityRatio：Capture感光度和Preview感光度的比例 Fno：光圈值 Gain Step：Sensor Gain的最小单位 Period Pixel Number：影响着横轴X的Size(Preview/Capture/Video) Period Line Number：影响着纵轴Y的Size(Preview/Capture/Video) Sensor PCLK：Sensor的Pixel Clock，控制每秒Readout多少Pixel(Preview/Capture/Video) FixSensorGain：当Sensor为Fix Gain时才使用(Sensor只能使用特定Gain值) 3.APEC：用来衡量曝光条件的公式3.1. AV + TV=EV3.1.1.AV：光圈值的级数一般来说，光圈用Fno.表示，Fno.表示光圈直径开孔的大小的倒数。 面积=∏*半径^2，光圈每提升一级，代表孔径缩小1倍，Fno*1.41(光圈增大)，入光量*1/2(入光量减少)。 3.1.2.TV：快门值的级数一般来说，用秒(s)为单位来衡量快门的长短，当快门提升一级，曝光时间*1/2，入光量*1/2。 3.1.3.AV+TV：光圈量的总和有多少光通过镜头连到Sensor，也就是曝光的供给面。 3.1.4.EV：用来衡量光通量的总和EV=㏒2(Fno.^2/快门时间) 3.1.5.结论 AV+1(光圈变小)，TV-1(快门加长)，EV不变(光通量不变) AV-1(光圈变大)，TV+1(快门缩短)，EV不变(光通量不变) 3.2. BV + SV BV：环境亮度的级数，环境亮度越高，BV越高 SV：Sensor感光度的级数，感光度越高，SV越高 3.2.1.BV+SV：光需求的总和光需求的总和：固定的环境亮度及感光度之下，需要多少光通量来让曝光平衡(曝光的需求面) 3.3. APEC（曝光公式）当曝光正确的前提下(影响亮度到达Targe)，AV+TV=EV=BV+SV。 AV+TV指曝光的供给面 BV+SV指曝光的需求面，也就是说当满足曝光的供给=曝光的需求时，此时曝光是正确的(成像亮度正确)。 4.CCT-AE Pline Table 4.1.主界面的介绍 Sensor Mode：Sensor Output选择Preview，Capture或者Video。 Select AE Table：选择目前的AE mode(AETABLE_RPEVIEW_AUTO)。 Scene Mode：AE_SCENC_AUTO。 AE Scene：列出全部的AE Scene。 AE Table：列出每个AE Mode，Mapping到的AE Table。 Table_Preview：点选可看到AE Table的Behaviour。 Update to Mapping Table：点选可将目前AE Mode与AE Table Mapping的关系记录下来。 Import form P-line：点选可从外部import每一组AE Table的Behavior。 Export to P-line Info：点选可将母亲AE Table Behavior Export为CSV文件。 4.2.常用的功能4.2.1.更新AE Scene与AE Table的Mapping关系 Sensor Mode下拉式选单中，选择希望设定的AE Mode。 Select AE Table下拉式选单中，选择希望设定的AE Table。 按下Update to Mapping Table按钮更新Mapping。 4.2.2.导入AE Table Behavior 按下Import form P-line按钮 选择预存的Pline Table.CSV AE Pline Table更新完成 4.2.3.导出AE Table Behavior 按下Export to P-line Info按钮 选择存储路径 完成储存AE Pline Table(*.csv &amp; *.cpp) 4.2.4.更新AE Table Behavior Select AE Table下拉式选单中，选择要更新的AE Table。 按下Table Preview键(进入Modify AE Tbale) AE Table Behavior满足公式AV+TV=EV=BV+SV。 过高的EV，AE无法收敛而过曝。 过低的EV，AE无法收敛而过暗。 4.2.5.定义各环境亮度 (BV)下，使用ISO与Shutter (曝光时间)的组合a.环境亮度由BV10降到BV3 Shutter(曝光时间)由1/3000(s)提升到1/30(s) Gain(ISO)保持1195不变(Minimum Saturation Gain) b.环境亮度由BV3降到BV-1 Shutter(曝光时间)保持1/30(s) Gain(ISO)由1195提升到20480 结论：每一段AE Pline，同时只能改变ISO或是改变Shutter其中一项。 4.3.实例(尝试在现有的AE Table新增段数)1.原本的AE Table只有两段 2.原本的Table随着环境亮度降低，先降Shutter再拉ISO 3.将AE Table Behavior改成Shutter(曝光时间)先由1/3000拉倒1/60，接着ISO由1195拉倒20480，最后Shutter(曝光时间)再由1/60拉倒1/30。 4.按下Refresh Curve后得到新的AE Table，可以看出转折点和Support的BV Range均改变了，新的AE Table在较高的BV就开始提升ISO，新的AE Table Support较低的BV。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-AWB Tuning","slug":"C-2018-09-28","date":"2018-09-28T10:30:45.000Z","updated":"2018-10-12T14:33:07.050Z","comments":true,"path":"2018/09/28/C-2018-09-28/","link":"","permalink":"http://yoursite.com/2018/09/28/C-2018-09-28/","excerpt":"","text":"1.AWB Tuning1.1.MTK CCT AWB Tuning提供的功能1.Module AWB Light Source Area Tuning(模块AWB光源区域调优) 新模组必须重新校正模组白点在各个色温下的落点，AWB结果才会正确。 2.AWB Preference Tuning(AWB偏好调优) CCT可用Slider调整各个色温的喜好度色偏，比如黄光下可以偏黄而不是全白，蓝天更蓝，白云更白等。 各种色温下也可以给予一组Preference Gain。 2.CCT AWB Tuning Flow1.在Common Control Dialog中，按下&quot;AWB Default&quot; 将AWB Disable，并设为1x Gain 关闭CCM/PA/Saturation 2.指定Capture Setting 将Format设为Raw Ext Mode设为Capture 3.指定正确的Shading Table 当拍摄D65/D75/DNP时，选用高色温 当拍摄CWF/TL84时，选用中色温 当拍摄A光时，选用低色温 4.拍照后在图片中框选一块ROI(感兴趣的区域)，然后填入对应的Light Source中。 5.反复进行步骤2、3、4填入八个色温的Data，这时就可以点击&quot;Auto Tuning&quot;。 DF指的是Daylight(日光) Fluorescent(荧光)，此色温为Optional(可选的)。 6.按下&quot;Auto Tuning&quot;让Tool自动产生AWB Light Source Area(AWB光源区)。 如果之前已经Tuning完成，且将Data存在手机中，想再次确认资料的正确性，可以使用”NVRAM Tuning”，利用手机NVRAM中的资料，将直接产生AWB Light Source Area。 7.点选AWB Light Area，可看到Tool Auto Tuning的AWB结果。 AWB Light Source Area 8.点选PWB Light Area，可看到Tool Auto Tuning的PWB结果。 PWB Light Source Area(MWB) 3.CCT AWB Tuning Flow-Preference Tuning(偏好调试) 3.1.提供三条Silder进行特定光源下色偏程度的控制 Slider越大越色偏，Slider越小越白平衡 Tungsten代表Horizon(H光=低色温) Warm Fluorescent代表A光 Shade代表D75 3.2.提供Preference Gain，进行各种光源下Preference Gain的设定 建议不要轻易使用Preference Gain，AWB会将运算结果强制乘上Preference Gain。 可能为了解特定场景偏色，而导致其余场景都偏色。 最恰当的使用时机，若AWB始终无法白平衡，且都偏相同色调。 4.CCT AWB Tuning Flow-Fix Issue4.1.问题一某些室内日光灯，AWB结果偏绿，且白点落在Daylight下方，该如何处理？ 答案：建议增加AWB Daylight Fluorescent Light Source Window(AWB日光 荧光 光源窗) AWB Light Source Area-Old AWB Light Source Area-New 4.2.问题二当Daylight(日光)出现AWB偏蓝，该如何处理？ 答案：可将Daylight(日光) AWB Window往右扩大 PS：当特定光源偏蓝，将对应的Window往右移 偏红，往左移 偏紫，往上移 偏绿，往下移 AWB Light Source Area-Old AWB Light Source Area-New 5.重要的文件5.1.Camera_tuning_para_sensor.h5.2.Camera_tuning_para_sensor.h","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-CDVT Sensor Calibration","slug":"C-2018-09-27","date":"2018-09-27T00:17:20.000Z","updated":"2018-10-12T14:33:19.197Z","comments":true,"path":"2018/09/27/C-2018-09-27/","link":"","permalink":"http://yoursite.com/2018/09/27/C-2018-09-27/","excerpt":"","text":"1.CDVT Sensor Calibration(Sensor 校准)的了解 1.1.第一部分(Sensor Calibration)(Sensor 校准)选择测试OB 选择测试Minimum ISO(最小的ISO值) 选择测试Minimum Saturation Gain(最小的饱和Gain值) 1.2.第二部分(Sensor Mode)选择测试时选择是Preview，Capture或者Video 1.3.第三部分1.4.第三部分1.5.第三部分2.测试项目2.1.OB2.1.1.测试目的测试相同Sensor Sensitivity(Sensor 敏感度)设定下，Sensor跑复数次OB测试的平均值。 2.1.2.测试环境尽量选择全黑环境，或者直接遮黑镜头。 2.1.3.测试方式 设定Exp Time(曝光时间) 设定Gain值(Sensor Gain) 设定Repeat Times(重复测试的次数) &quot;Run&quot;(开始测试) Result(得到测试结果) 2.2.Minimum ISO2.2.1.测试目的测试当Gain值为一倍时(1024)，对应的ISO值应为多少？ 也就是说，用来测试Sensor的基本Sensitivity(敏感度)。 2.2.2.测试环境尽量选择适当亮度的均匀光源(DNP灯箱) 2.2.3.测试方式 设定频率(50Hz or 60Hz) 设定LV(根据光源亮度填入数值) 设定F Number(根据光圈大小填入数值) 设定OB(根据以前的测试结果，填入OB数值) Run(开始测试) Result(得到测试结果) 注意：测试的结果可以得到&quot;Minimum ISO&quot;，这个值需要填入&quot;Device Info&quot;，Device Info预设会由MTK Camera Tuning Owner提供。 2.3.Minimum Saturation Gain2.3.1.测试目的测试能让Sensor饱和(R\\G\\B Channel均达到255)的最小Gain值 也就是说，当Sensor Gain小于某定值时，Sensor Exposure无论多长，Sensor Output都无法饱和，因此必须找到此Sensor Gain的最小值。 2.3.2.测试环境尽量选择适当亮度的均匀光源(DNP灯箱) 2.3.3.测试方式 设定频率(50Hz or 60Hz) 设定Target Decline Rate(使用默认) 设定Gain Buffer(Buffer越大，允许的Minimum Saturation Gain越小(使用默认)) 设定OB(根据以前的测试结果，填入OB数值) Run(开始测试) Result(得到测试结果) 注意：测试的结果可以得到&quot;Minimum Saturation Gain&quot;，这个值需要填入&quot;Device Info&quot;，Device Info预设会由MTK Camera Tuning Owner提供。 3. Shading Tuning的了解3.1.MTK Shading Compensation Solution MT6575 MT6577 MT6589 3.2.测试环境 准备均匀光源环境(DNP灯箱) 将手机镜头贴近光源 使用CCT开始Tuning 4.CCT Shading Tuning4.1.使用步骤1.选择&quot;Lens Info&quot; 2.Common Control Dialog中，进行Default操作。 选择Preview/Capture/Video 按下&quot;AWB Default&quot;(将设定初始化) 选择要Calibration(校准)的色温：(高/中/低三组选一组) MTK的shading Table最多可以区分三组色温： 高色温：D75/D65/DNP 中色温：TL84/CWF 低色温：A/Horizon 各种色温的Shading Table，直接在要测试的色温环境下Tuning(大光源)，Color shading补偿效果是最好的！但是如果模组不同色温下，Color Shading效果差异很大，很有可能会在切换Shading Table时，产生不连续的现象，所以应该使用MTK推荐的环境Tuning。 3.取消&quot;Fix Shading&quot; 选择Fix Shading，表示Tuning完一组shading Table，会同时填入NVRAM高中低三组Table。 4.选择Tuning Para 设定Shading要补偿的比例，一般设置为85%~90%。 5.按下Calculate，开始Tuning 6.Tuning完成后将设定存入手机 按下Apply para and Table 按下Apply para 按下Save to NVRAM 重复2、3、4、5步骤，产生三个色温Preview和Capture的Shading Table。 4.2.CCT验证Shading补偿效果1.由Common Control Dialog Enable Shading 2.指定Shading Table后牌照 3.点选图片周围的圆圈，显示剖面圆RGB Channel的响应，可以看出Shading的程度。 4.3.Import/Export Shading TableImport：导入文件(CSV格式) Export：导出文件(CSV格式) 5.重要的文件5.1.Camera_isp_regs_sensor.h存放Shading Compensate Register(阴影补偿登记) 5.2.Camera_isp_lsc_sensor.h存放Shading Compensate Table(阴影补偿表格)","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-Sensor Verify","slug":"C-2018-09-26","date":"2018-09-26T13:10:32.000Z","updated":"2018-10-12T14:33:30.218Z","comments":true,"path":"2018/09/26/C-2018-09-26/","link":"","permalink":"http://yoursite.com/2018/09/26/C-2018-09-26/","excerpt":"","text":"1.Sensor Verify(Sensor验证)1.1.目的：确认Sensor基本特性1.1.1.Sensor Linearity(Sensor线性度) 确认Sensor Exposure Linearity(Sensor的线性曝光) 确认Sensor Gain Linearity(Sensor的线性Gain值) 注意：如果是Sensor Linearity不佳，可能出现AE不稳或是震荡的问题。 1.1.2.OB 确认OB稳定，不随着Gain值和Shutter(曝光时间)而变动。 确认OB稳定，且Preview和Capture保持一致。 注意：如果是OB不稳，则画面容易出现暗处和亮处的色调不同，或是Preview/Capture的亮度不一致。 补充知识：Gain值越大，亮度越低，通过调整Gain值，增加亮度来观察图片的变化。 1.2.测试环境1.2.1.Sensor Linearity 尽量选择适当亮度的均匀光源(DNP灯箱)，并且亮度尽量控制在LV10左右。 如果亮度过亮，Sensor Output就会过饱和；亮度过暗，Sensor Output就会无法饱和，这两种情形均无法看出Sensor线性度。 1.2.2.OB 尽量选择全黑环境，或者直接遮黑镜头。 如果镜头没有完全遮黑，测出的OB值会偏大(测出的OB包含实际的OB+外界的亮度)；如果扣了过多的OB，会导致暗处的细节消失且偏绿。 2.CDVI Sensor Verify2.1.CDVI Sensor Test 2.1.1.第一部分(Sensor Test)选择验证Sensor Exposure Linearity(Sensor的线性曝光) 选择验证Sensor Gain Linearity(Sensor的线性Gain值) 选择验证OB Stability(OB 稳定性) 2.1.2.第二部分(Sensor Mode)Sensor Output选择Preview，Capture或者Video 2.1.3.第三部分(Exposure Linearity)选择Exposure的时间单位(Exp Time/Exp Line) Gain的设定值 起始的Shutter(曝光时间) Time 结束的Shutter(曝光时间) Time Shutter(曝光时间) Time的间隔 2.1.4.第四部分(Gain Linearity/OB Stability)Shutter(曝光时间)的设定值 起始的Gain 结束的Gain Gain的间隔 2.1.5.第五部分测试结果的显示 2.2.CDVI Sensor Verify-Exposure Linearity2.2.1.测试流程1.将手机面对均匀光源(DNP灯箱) 2.选择&quot;Exposure Linearity&quot; 3.设定&quot;Gain/Exp Start/Exp End/Exp Interval&quot; 4.按下&quot;Run&quot;，执行测试 5.按下&quot;Raw Analysis Result&quot; 2.2.2.期望结果理想的Sensor，Exposure Time对应Sensor Output应该是笔直的线性。 2.3.CDVI Sensor Verify-Gain Linearity2.3.1.测试流程1.将手机面对均匀光源(DNP灯箱) 2.选择&quot;Gain Linearity&quot; 3.设定&quot;Exp Time/Gain Start/Gain End/Gain Interval&quot; 4.按下&quot;Run&quot;，执行测试 5.按下&quot;Raw Analysis Result&quot; 2.3.2.预期结果理想的Sensor，Gain对应Sensor Output应该是笔直的线性。 2.4.CDVI Sensor Verify-错误结果分析2.4.1.过快饱和 线性区过短，R、G、B、Value过快到达最高点 Exp和Gain的搭配过大，导致Sensitivity(敏感度)过高。 2.4.2.无法饱和 线性区过长，R、G、B、Vaule无法达到最高点 Exp和Gain的搭配过小，导致Sensitivity(敏感度)过低 2.4.3.总结 当Exp和Gain的搭配设定过小或过大，都无法正确的验证Sensor的Linearity(线性度) 开始进行测试前，建议先根据目前的光源亮度与Sensitivity(敏感度)的设定，确认Sensor Output的Range。微调Sensitivity(敏感度)设定后，再开始完整测试。 2.5.CDVI Sensor Verify-OB Stability2.5.1.测试流程1.将手机遮黑 2.选择&quot;OB Stability&quot; 3.设定&quot;Exp Time/Gain Start/Gain End/Gain Interval&quot; 4.按下&quot;Run&quot;，执行测试 5.按下&quot;Raw Analysis Result&quot; 2.5.2.期望结果OB的四个Channel(R、Gr、Gb、B)的值彼此间可以不同，但是不同的Sensor Sensitivity(Sensor 敏感度)设定，相同的Channel的OB值必须相同(相同Channel的OB值十分接近即可)。 从图中可以得到OB的值是10bit，后续要填入NVRAM，需要转换为12bit(*4)。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"CCT6735M的了解与使用-Camera tuning Flow","slug":"C-2018-09-25","date":"2018-09-25T11:25:47.000Z","updated":"2018-10-12T14:34:51.825Z","comments":true,"path":"2018/09/25/C-2018-09-25/","link":"","permalink":"http://yoursite.com/2018/09/25/C-2018-09-25/","excerpt":"","text":"1.减光片的校准方法1.第一步：首先拍摄一张不使用减光片遮住摄像头的照片作为参照物，前摄像头或者后摄像头都可以。 2.第二步，将打乱顺序的减光片都放在摄像头上遮住，拍摄照片。这时必须保证视场角、光照等是相同的。 3.分析拍摄到的所有的照片，在DP软件中可以得到图片的log信息，保存起来。 4.需要查看每张图片的log信息，可以获得AWB_TAG_PV_SCENE_LV(亮度)的值，减光片的遮光能力是逐级递减的，所以根据不同照片的亮度值，很容易就校准了减光片。 2.Camera tuning Flow2.1.一个完整的Tuning流程 基本上，Image Pipeline上每个Stage一变动，就会影响后级的结果。因此只要变动某级的调整参数，后级的调整参数很可能也得重新调整。 Ex 1.若改动Shading，后段的AWB/ISP餐数都得重新调整一遍。 Ex 2.若改动Gamma，前段的AWB Output没有影响，但后段的Noise和Color就会受到影响。 2.2.注意：1.调试时，一定要按照上图的顺序Calibration(标准)，否则会交互影响，导致问题无法收敛。 2.在同Sensor，不同Lens，F No.(光圈)不变的情况下，因为Module(模组)的Lens改变，因此Shading、AF、AWB的影响会比较大，所以必须重调。 3.在同Sensor，不同Lens的情况下，F No.(光圈)改变的情况下，因为Module(模组)的lens和F No.改变，因此shading、AE、AF、AWB的影响会比较大，所以必须重调。 2.3.客户的不同要求1.AE：Support(支持)更高或更低的环境亮度，相同的环境亮度采用不同的Shutter(曝光时间)/Gain值组合 2.AF：CAF(Constract Auto Focus)稳定度(自动对焦的稳定性)和敏感度的Trade off(平衡性) 3.AWB：特定色温的偏色程度.Ex黄光 4.Gamma：对比的调整 5.EE/NR：Noise/Sharpness Trade Off(噪音和锐化度的平衡性，噪音和锐化总是不可分开的两个属性) 6.Color：不同的色调表现，.Ex黄绿或是翠绿，正红或是桃红 补充知识： Gain值越大，亮度越低，通过调整Gain值，增加亮度来观察图片的变化。 3.CCT-MT6589的简单了解3.1.用途1.可以强制改变Camera的3A/ISP(图像信号处理器[image signal processing])设定 2.可手动设定ISP各Module是否开放 3.通常用来分析特殊场景问题 补充知识：ISP的主要作用是对前端图像传感器输出信号做后期处理，主要功能有线性纠正、噪声去除、坏点去除、白平衡、自动曝光控制等，ISP技术在很大程度上决定了相机的成像质量。 3.2.CTT提供的功能1.Sensor验证 2.Gen AF Search Table/AF Parameter(生成AF搜索表 /AF参数) 3.Gen AE Pline Table/AE Parameter( 生成AE曝光表/AE参数) 4.Calibration Flash Strength Ratio(校准闪光灯强度比) 5.Calibration Noise/sharpness Trade Off(校准噪音，锐化度) 6.Calibration Color Preference(校准色彩偏移) 3.3.使用环境1.Windows XP/Windows 7系统 2.安装MTK Official Load的手机 4.CCT的基本操作4.1.CCT6735M软件主界面 Capture(工程模式)：拍照(Raw图) Export Original(出口源)：将拍好的图片output到电脑 Import File(导入图片)：由电脑input图片到tool Export BMP：将拍好的图片以BMP格式output到电脑 Export Setting：将Camera Parameter(相机参数)output到电脑 Formal：决定拍照的格式 Subsample：决定Capture的照片尺寸 Width：显示Capture照片的宽 Height：显示Capture照片的高 Mode：选择Sensor Output Mode AWB：手动AWB设定 CCM：手动CCM设定 En：手动ISP设定 AE：手动AE设定 AF：手动AF设定 shading：手动Shading设定 4.2.Gen Code(生成代码)4.2.1.作用产生调试参数的相关档案。 4.2.2.路径alps\\mediatek\\custom\\hal\\imgsensor\\sensorname_raw 4.2.3.步骤1.在主界面上选择Device Profile-&gt;Import 2.Action-&gt;Save NVRAM and Generate Camera Parameter File 3.选择APDB File 4.选择存档路径 5.Gen Code保存完成 4.2.4.Gen Code中的内容 Camera_isp_lsc_ov8825mipirawraw.h ====&gt; PCA Tuning Parameter(PCA调试参数) Camera_isp_pca_ov8825mipirawraw.h ====&gt; ISP Tuning Parameter(ISP调试参数) Camera_isp_regs_ov8825mipirawraw.h ====&gt; Shading/AE/AWB Camera_tuning_para_ov8825mipirawraw.cpp ====&gt; Tuning Parameter(调试参数) lens_para_OV8825AF.cpp ====&gt; AF Tuning Parameter(AF调试参数)","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"CCT","slug":"CCT","permalink":"http://yoursite.com/tags/CCT/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Sublime编辑器的介绍","slug":"C-2018-09-21","date":"2018-09-21T12:52:52.000Z","updated":"2018-10-12T14:34:40.059Z","comments":true,"path":"2018/09/21/C-2018-09-21/","link":"","permalink":"http://yoursite.com/2018/09/21/C-2018-09-21/","excerpt":"","text":"1.Sublime强大的功能1.1.跨平台Sublime适用于Mac，Windows和Linux。无论使用何种操作系统，只需一个许可即可在您拥有的每台计算机上使用Sublime。 1.2.多项选择多项选择允许一次交互式更改多行,主要用于修改相同的文字、代码或者数据。 使用方式：首先确定基选区，然后按住Ctrl + Shift + L将选区分为线，接着按住ctrl，接着选中任意多个选区，这时会出现多条分区线，这样就可以同时在这些分区线后面一次写入多个相同的内容，大大提高编码效率。 1.3.强大的API和包生态系统Sublime有一个功能强大的Python API，允许通过插件增强内置功能。 可以通过命令面板安装Package Control，从而可以轻松访问社区构建的数千个包。 1.4.拆分编辑可以将编辑器拆分显示 1.5.命令调色板可以方便的搜索不常用，但有时候可能需要使用的命令。 使用方式：使用Ctrl + Shift + P显示命令选项板。 2.有关Color shading知识的学习2.1.检测Colro shading最适合的场景2.1.1.主观场景： 1.最适合拍摄的颜色最好是中性颜色，比如说灰色、灰白色、白色等， 不能拍摄鲜艳的颜色，比如说红色、绿色、紫色、黄色等，原因是Colro shading是指色彩分布不均匀，从中性颜色的图片上更容易观察除color shading的问题，那些彩色的图片，可能会遮盖住Colro shading的问题。 2.检测Colro shading时最佳拍摄的主观场景最好是水泥路面、晴天的天空、阴天的天空(云朵)、白墙、天花板等。 2.1.2.实验室场景 1.18灰色卡是检测Color shading最好的设备了。 2.在实验室拍照片检测color shading时，一般用毛玻璃盖住相机，拍摄出来的图片大概是灰白色的图片。 2.2.主观观看Color shading 1.主要看图片色彩是否分布均匀 2.观察拍摄出来的图片是否有一块黄、一块青、一块紫、一块红灯，也就是说是否出现一块一块的别的颜色等。 2.3.Color shading和彩噪的区别 1.Color shading是一大块区域、一大块区域都是其他颜色，这里的其他颜色包括红色、黄色、青色、绿色等等(因为拍的照片都是中性颜色的照片)，这些区域是独立的，互不相连的。 2.彩噪是整片区域都是其他的颜色，这里的其他颜色包括也是红色、黄色、青色、绿色等(因为拍的照片都是中性颜色的照片)，而这些区域是交叠在一起的，就像长长的链条一样，一个套着一个的。 3.用Package Control安装插件的方法：3.1.第一步：按住ctrl+shift+p：调出安装插件的命令面板，如下图所示. 3.2.第二步：在命令面板中输入Install Package，选择Package Control:Install Package选项并回车。 等待结果如下图所示，一般会在编辑器的左下角显示。 3.3.第三步：如果出现类似下图的命令面板，就说明资源，网络已经OK没有问题，这时可以在命令面板中搜索你自己想要的插件，然后点击安装。 3.4.查看已安装的插件 3.5.删除已安装的插件1.按住ctrl+shift+p：调出安装插件的命令面板。 2.在命令面板中输入remove package，然后选择Package Control:Remove Package选项。 3.这时的命令面板中就会出现你安装过的所有插件，想删除那个插件就点击哪个插件就OK了。 4.常用的插件的介绍4.1.格式化(formatting)1.Line Endings Unify：批量更改文件结尾 2.MoveText：选择文本并将其拖动，或设置文本隧道以将代码从一个位置移动到另一个位置。 3.Char Value：获取所选字符的字符值(Unicode代码点) 4.EditorConfig：帮助开发人员在不同的编辑器之间保持一致的编码风格 4.2.文本处理(text manipulation)1.ChangeQuotes：将单引号转换为双引号或单引号转换为双引号 2.AddToFile：允许将选择立即添加到打开的文件中 3.Autoimport：管理经常遇到的关键字 4.3.语言语法(language syntax)1.C++ NamespaceTool：简单C++名称空间重构包 2.C++ Starting Kit：C，C++的语法高亮支持 3.Abstract Markup Language：Sublime的抽象标记语言语法高亮，代码片段和构建系统。 4.4.Color Scheme(配色方案)1.Chrome Color Scheme：语法主题模仿Chrome google开发者工具 2.Chuby Ninja Color Scheme：柔和的深色配色方案，方便眼睛使用","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://yoursite.com/tags/Sublime/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Android Debug Bridge","slug":"C-2018-09-20","date":"2018-09-20T14:01:30.000Z","updated":"2018-10-12T14:34:23.074Z","comments":true,"path":"2018/09/20/C-2018-09-20/","link":"","permalink":"http://yoursite.com/2018/09/20/C-2018-09-20/","excerpt":"","text":"Android Debug Bridge version 1.0.31(Android调试桥版本1.0.31)1.-a：指示adb监听连接的所有接口2.-d ：将命令引导到唯一连接的USB设备，如果有多个USB设备出现，则返回一个错误。3.-e：将命令引导到唯一运行的模拟器，如果超过一个模拟器正在运行，则返回一个错误。4.-s： 用给定的命令将命令引导到设备或模拟器，序列号或限定符，覆盖ANDROLD_SERIAL(串号)。5.-H：adb服务器主机名(默认:localhost)。6.-P：adb服务器(默认：5037)。7.devices [-l]：列出所有的连接设备8.connect &lt;host&gt;[:&lt;port&gt;]：通过IP连接到设备，如果没有指定端口号，则默认使用了5555。9.disconnect [&lt;host&gt;[:&lt;port&gt;]]：断开与一个ip设备的连接，如果没有指定端口号，则默认使用5555端口，在没有附加参数的情况下运行这个命令，将断开与所有连接的ip设备的连接。10.device commands:磁盘操作命令10.1. adb push [-p] &lt;local&gt; &lt;remote&gt;123复制文件/目录到设备&quot;-p&quot;来显示转移的进度 10.2. adb pull [-p] [-a] &lt;remote&gt; [&lt;local&gt;]12345复制文件/目录到设备&quot;-p&quot;来显示转移的进度&quot;-a&quot;的意思是复制时间戳和模式 10.3. adb shell ：交互式地运行远程shell10.4. adb shell &lt;command&gt;：运行远程shell命令10.5. adb emu &lt;command&gt;：运行模拟器控制台命令10.6. adb logcat [ &lt;filter-spec&gt; ] - View device log(查看设备日志)10.7. adb bugreport：从设备返回所有信息，这应该包含在Bug报告中10.8. adb restore &lt;file&gt;：从备份存档中恢复设备内容10.9. adb help：显示这个帮助信息10.10. adb version：显示版本数11. scripting:(脚本语言)11.1. adb wait-for-device ：一直等待，知道设备上线11.2. adb start-server ：确保有一个服务器在运行11.3. adb kill-server ：如果服务器正在运行，就杀死服务器11.4. adb get-state ：打印：脱机引导加载程序11.5. adb get-serialno：打印序列号11.6. adb get-devpath：打印设备路径11.7. adb status-window ：为指定的设备连续打印设备状态11.8. adb remount ：在设备读写上重新安装/系统分区11.9. adb reboot [bootloader|recovery]：重新启动设备，可选地进入11.10 adb reboot-bootloader ：将设备重新引导到引导加载程序中11.11. adb root：重新启动带有根权限的adbd守护进程11.12. adb usb：重新启动adbd守护进程监听USB11.13. adb tcpip &lt;port&gt;：重新启动adbd守护进程，监听指定端口上的TCP","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"http://yoursite.com/tags/adb命令/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"手机摄像模组图像质量规范(3)","slug":"C-2018-09-19","date":"2018-09-19T11:29:30.000Z","updated":"2018-10-12T13:33:43.208Z","comments":true,"path":"2018/09/19/C-2018-09-19/","link":"","permalink":"http://yoursite.com/2018/09/19/C-2018-09-19/","excerpt":"","text":"11.信噪比测试11.1.相关的概念11.1.1.信噪比的定义 信噪比中的“信”指信号本身，是有用部分;“噪”指由外界干扰或设备自身因素而产生的噪声。 信号传输过程中的各种干扰，或者设备发热都可产生噪声，这些噪声与信号本身无关，也就是说噪声的功率不以有效信号的强弱而变化。 11.1.2.信噪比和噪声的功率之间的关系信噪比=10㏒(Ps/Pn)，其中Ps代表信号，Pn代表噪声的有效功率，信噪比的单位是(dB)。 一般来说，对于固定的系统，噪声的功率一般是恒定的。信噪比越高，信号中的有用成分越多，噪声越少，说明信号的质量越好；若信噪比越低，信号中的噪声越多，说明信号质量越差。 11.1.3.提高信噪比的方法 提高信号本身的幅度，也就是合适的增加曝光量，画面亮部的噪波要明显小于暗部的噪波。 降低摄影系统自身产生的噪音。 11.1.4.噪点图像噪声（image noise是图像中一种亮度或颜色信息的随机变化(被拍摄物体本身并没有)，通常是电子噪声的表现。它一般是由扫描仪或数码相机的传感器和电路产生的，也可能是受胶片颗粒或者理想光电探测器中不可避免的的散粒噪声影响产生的。图像噪声是图像拍摄过程中不希望存在的副产品，给图像带来了错误和额外的信息。 噪点，形象的来说就像是图片被弄脏了，布满一些细小的糙点，也就是会出现图像中原本没有的颜色(假色)，这种假色就说噪点。 11.1.5.曝光时间和曝光量曝光时间是为了将光投射到照相感光材料的感光面上，快门所要打开的时间。若曝光时间较长，适合光线条件较差的情况，若曝光时间较短，则适合光线较高的情况。 曝光量=照度*时间，照度由光圈决定，时间由快门控制，也就是说曝光量由光圈和快门共同决定。 11.2.目的测试拍照系统的Noise程度 11.3.所需要的工具24色卡、大光源、色温照度计 11.4.信噪比的计算方法11.4.1.第一种方法将拍摄到的24色卡的图片导入Imatest软件，选择按钮[Colorcheck]之后，根据客户的要求设置一些参数值，Imatest软件自动分析，我们从结果中可以得到需求的值。 注意：如果想要得到信噪比的值，必须在导入图片之后出现的弹出框中做一下设置。 11.4.2.第二种方法SNR=20㏒10((S19-S24)/N22) S19、S24分别表示为第19，第24灰阶块的信号亮度值，而N22表示第22灰阶块的噪声值。 11.5.信噪比判断标准 12. TV Distortion(畸变)测试12.1.定义畸变是一种可以把直线变成曲线的像差，广角镜头、变焦镜头，远距镜头容易造成严重的畸变，在图像的边缘切线尤其的明显。 12.2.目的测试拍照系统成像是否发生畸变。 12.3.所需要的工具大光源、色温照度计、棋盘格 12.4.畸变的测试方法12.4.1.第一种方法将拍摄到的棋盘格 charts的图片导入Imatest软件，选择按钮[Distortion]之后，选择自己感兴趣的区域，根据客户的要求设置一些参数值，Imatest软件自动分析，我们从结果中可以得到需求的值。 青色和红色的线表示校正后的水平和垂直线，青色和红色的箭头示意畸变方向 上图显示了畸变在半径方向造成的改变△r，△r指的是归一化到中心到边角的距离。 注意：这里的感兴趣的区域指的是棋盘格中行和列是相同的，相同的行和相同的列组成的白色棋盘格与黑色棋盘格的个数是相同的，如果不满足这些条件的话，Imatest软件将不会计算出结果。 红色区域代表要选择的区域 12.4.2.第二种方法畸变图像如下所示： 计算方法： A=(A1+A2)/2 Distortion=100(A-B)/B 12.5.畸变的判断标准 13.最大亮度测试13.1.目的测试摄像头的最大亮度值 13.2.所需要的工具大光管、灰阶卡、色温照度计 13.3.最大亮度的测试方法 第一步：将拍摄的图片导入PS中。 第二步：选择测试区域 第三步：在PS中读取数据 13.4.最大亮度值判定标准最大亮度值在205~250之间 14.杂光(Flare)14.1.目的确认模组拍摄时影像画面内是否存在其它光线影像成像效果 14.2.所需要的工具日光灯、被测设备 14.3.杂光的测试方法 1.将模组解像力较好的模组对准日光灯管，距离3m左右 2.当灯管放于画面中心时(此时为零度)，再向影像八个角落依0度~90度方向测试，每10度记录一张相片。 角度 视角内：鬼影 视角外：杂光 14.4.杂光的判定标准要求大/小角度时影像画面内必须无明显杂光/鬼影产生。 15.总结 1.分辨率低的太多就需要换镜头了，分辨率第一点就可以调试AWB。 2.色彩普遍过饱和就需要调试AWB，某一个光饱和只需要调试单一的色彩就可以了。 3.动态范围大于8的，前面是隔行大于的，中间是挨个大于的，是因为γ线压的严重了。 4.动态范围大于8的小于10阶，需要调试Constrast和Gamma。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像质量规范","slug":"图像质量规范","permalink":"http://yoursite.com/tags/图像质量规范/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"手机摄像模组图像质量规范(2)","slug":"C-2018-09-18","date":"2018-09-18T05:21:58.000Z","updated":"2018-10-12T13:33:32.182Z","comments":true,"path":"2018/09/18/C-2018-09-18/","link":"","permalink":"http://yoursite.com/2018/09/18/C-2018-09-18/","excerpt":"","text":"6.色彩均一性测试6.1.目的确认模组周边与中心色彩一致性是否符合要求 6.2.所需要的工具DNP灯箱、18灰 charts 6.3.色彩均匀性的测试方法 1.需要一组解像力较好的模组。 2.将拍摄到的18灰 charts分别导入Imatest软件，选择按钮[Light Falloff]之后，分别分析R/B、R/G、G/B的max与min值，并用min值除以max值，从而得到需求值。 6.3.1.Color shading(R/B)Color shading的选项为Red/Blue，Imatest软件的分析结果为： 6.3.2.Color shading(R/G)Color shading的选项为Red/Green，Imatest软件的分析结果为： 6.3.3.Color shading(G/B)Color shading的选项为Green/Blue，Imatest软件的分析结果为： 6.4.颜色均一性的测试标准VGA(Video Graphics Array)是IBM推出的一种视频传输标准。 7.色彩还原性测试7.1.定义色彩（Color)在数字化的世界中是以一个3D三维空间的座标表现（La*b*），L 代表明度，a*b*代表颜色座标。 7.2.目的确认模组在模拟蓝天日光下的偏色现象及还原性效果以和在暗态下的偏色现象及还原效果。 7.3.所需要的工具大光源、24色卡 7.4.色彩还原性的计算方法 ΔC=((a-a)2+ (b-b)2)1/2 ΔE=((L-L)2+(a-a)2+(b-b*)2)1/2 Saturation=100% ×((a 2 + b 2)1/2)/((a2+ b2)1/2) L、a、b 为经过拍照系统处理后的值，L*、a*、b*为ColorChecker的实际值 将拍摄到的24色卡的图片导入Imatest软件，选择按钮[Colorcheck]之后，根据客户的要求设置一些参数值，Imatest软件自动分析出结果。 7.5.24色卡的说明整版ColorChecker一共包含了24个图块，第四排的六个由白到灰再到黑的ColorChecker主要是用来测试相机的自动白平衡，24图块的名称如下图所示。 7.6.色彩还原的判断标准VGA(Video Graphics Array)是IBM推出的一种视频传输标准。 8.AWB(白平衡测试)8.1.目的测试拍照系统在不同色温环境下对白色的再现能力 8.2.所需要的工具大光源、24色卡，色温照度计 8.3.白平衡的计算方法将拍摄到的24色卡的图片导入Imatest软件，选择按钮[Colorcheck]之后，根据客户的要求设置一些参数值，Imatest软件自动分析，我们从图中刻印看到每个色块的值。 24色卡中第四排的六个由白到灰再到黑的ColorChecker主要是用来测试相机的自动白平衡，我们最主要的参考的是20~22色块的值。 8.4.白平衡判断标准VGA(Video Graphics Array)是IBM推出的一种视频传输标准。 9.ExposureError(曝光)测试9.1.目的测试拍照系统在不同色温环境下对曝光测试。 9.2.所需要的工具大光源、24色卡、色温照度计 9.3.曝光值的计算方法将拍摄到的24色卡的图片导入Imatest软件，选择按钮[Colorcheck]之后，根据客户的要求设置一些参数值，Imatest软件自动分析，我们从图中可以看到曝光值(ExposureError)。 9.4.曝光值的判断标准绝对值&lt;0.3 10 Gray Scale(灰阶测试)10.1.目的测试摄像头的动态范围 10.2.所需要的工具大光源、灰阶卡、色温照度计 10.3.灰阶的计算方法10.3.1.第一种方法将拍摄到的灰阶卡的图片导入Imatest软件，选择按钮[Stepchart]之后，根据客户的要求设置一些参数值，Imatest软件自动分析，我们从图中可以知道可以区分多少级灰阶。 10.3.2.第二种方法 1.从Imatest的测试数据中，具体的来说是从&quot;Result&quot;文件中找到对应的&quot;CVS&quot;文档，从而得出每个灰阶块的Y值(灰度值)； 2.计算相邻灰阶块Y值得差值△Y，如果该值△Y&gt;8，那么认为这两个相邻灰阶是可以被肉眼区分的，如果您△Y&lt;8，那么不可以被肉眼区别。 3.统计一共可以区分多少级灰阶 10.4.灰阶值的标准VGA(Video Graphics Array)是IBM推出的一种视频传输标准。 contrast","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像质量规范","slug":"图像质量规范","permalink":"http://yoursite.com/tags/图像质量规范/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"手机摄像模组图像质量规范(1)","slug":"C-2018-09-17","date":"2018-09-17T13:17:08.000Z","updated":"2018-10-12T13:33:23.430Z","comments":true,"path":"2018/09/17/C-2018-09-17/","link":"","permalink":"http://yoursite.com/2018/09/17/C-2018-09-17/","excerpt":"","text":"1.目的对成品模组影像进行评测及相关测试(客观测试和主观测试)标准的制定，检测是否满足客户的要求。 2.适用范围适用于大部分的模组镜头。 3.更多名词的了解 解像力：表现摄像设备对被摄景物细节的再现分辨能力。 亮度均匀性：用拍摄设备拍摄亮度均匀的画面，画面中心和画面边缘的亮度差异程度。 色彩均一性：用拍摄设备拍摄亮色彩均匀的画面，画面中心和画面边缘的色彩差异程度。 色彩还原性：彩色拍摄画面的色彩大体上和原景物的色彩相一致。 白平衡：通过自动白平衡调节，在不同的光源条件下能获得与人眼观察相符的彩色再现。 灰阶：摄像设备对不同光谱特性或等效光谱特性的灰度的分辨能力。 畸变：拍摄设备拍摄的画面相对于被拍摄图案的几何变形。 视场角:在画面充满视场条件下，被摄画面对角线两端与摄像设备镜头中心连线的夹角为对角线视场角。 杂散光 信噪比： 4.解像力测试4.1.目的确认模组分辨率是否达到标准要求，锐化程度是否过高 4.2所需要的工具ISO12232 Charts、大光源 4.3.解像力读取方法4.3.1.第一种方法从低频楔形线对开始向高频率开始读，当不能再辨别为线对的时候，该处的值就为此处的解像力值。 4.3.2.第二种方法使用Imatest软件也可以测试解像力的值，拍照区域为4:3~4:3，绿色线框中表示的是水平解析度值，粉红色线框表述的是垂直解析度值；中间区域线框中表示的是中心的解析度值，其他为各个对应角落的解析度值。 打开Imatest软件，选择按钮[SFR：new File]这个按钮，导入拍摄的ISO12232图片，选择自己感兴趣的区域，Imatest软件会自动计算出结果值。 注意：这里的感兴趣的区域指的是黑色和白色的区域，如下图标注出来的区域。也就是说一共需要测量十次，包括中间横向、中间纵向、四角的横向和纵向。 测试结果如下图所示： 4.4.锐化度(sharpening)读取方法利用Imatest软件，我们可以很明显的得到图片的锐化度(Oversharpening/Undersharping)的值。 打开Imatest软件，选择按钮[SFR：new File]这个按钮，导入拍摄的ISO12232图片，选择自己感兴趣的区域，Imatest软件会自动计算出Oversharpening/Undersharping的值。 注意：如果想要出现sharpening的值，需要设置一个参数(Standardized sharpening ON) 4.5.测试标准4.5.1.解析度的一般标准 4.5.2.锐化度的一般标准 VGA(Video Graphics Array)是IBM推出的一种视频传输标准。 5.亮度均匀性测试5.1.目的测试图片的亮度均匀性 5.2.所需要的工具均匀光源(DNP灯箱)，照度计、18灰 charts 5.3.亮度均匀性的计算方法5.3.1.第一种方法Shading值=(四角最暗处的亮度值Y/中心最亮处的亮度值)*100% 5.3.2.第二种方法利用Imatest软件进行分析，选择按钮[Light Falloff]，导入拍摄的18灰 charts，Imatest软件会自动计算出结果值。 5.3.3.注意事项 Light Falloff需要选择整幅图片作为测试区域，而解析度选择指定的区域作为测试区域。 选择好测试区域之后，会弹出一个对话框，需要特别注意的是选择color shading测试。 一般情况下，会选择Red/Blue、Red/Green、Green/Blue分别都测试一遍。 5.4.shading5.4.1.lens shadinglens shading测试原理是在整幅图像中的四角和中央分别取相同大小区域，然后算出这些区域的亮度值，以中间区域为基准，用四周区域的亮度值和中间区域的亮度值相比，这样便会得到一个比值，这个比值越接近1越好。 5.4.2.color shadingcolor shading测试的原理就是把整幅图像等分成若干区域，然后算出这些区域的R/B、R/G或G/B的值，以中间区域为基准，用其他区域的比值和中间区域的比值再相比，得到一个接近于1的数值，这些最终得到的比值越接近1说明Color shading越好。 5.4.3.总结从Imatest的测试结果来看，lens shading和color shading的测试结果都有好几个值，Worst、Mean等，至于看哪个要根据每个客户的标准来。 5.5.亮度均一性的测试标准VGA(Video Graphics Array)是IBM推出的一种视频传输标准。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"图像质量规范","slug":"图像质量规范","permalink":"http://yoursite.com/tags/图像质量规范/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"Imatest软件的学习","slug":"C-2018-09-14","date":"2018-09-14T10:18:08.000Z","updated":"2018-10-12T14:52:41.946Z","comments":true,"path":"2018/09/14/C-2018-09-14/","link":"","permalink":"http://yoursite.com/2018/09/14/C-2018-09-14/","excerpt":"","text":"今天主要了解了一些常用的图像测试软件以及基本的用法。 1. Imatest：图像质量分析软件Imatest软件主要分析分辨率，畸变，噪点，色彩还原，均匀性，横向色差等。 SFR:New File：导入拍摄的SFR的图片，主要分析图片的解析度(锐度)。 SFRplus setup：根据客户的要求提前设置好一系列的参数 SFRplus auto：根据设置好的参数，可以同时导入多张图片进行分析，提高工作的效率，不必每张图片都设置相同的参数，减少重复劳动。 Rescharts：需要的图片是拍摄ISO12232，主要测量图片的分辨率。 MTF Compare：对比分析MTF50的值(SFR的结果值)。 Colorcheck：需要的图片是拍摄24色卡，主要分析色彩的饱和度，白平衡，色彩还原，噪声等。 Multicharts Stepchart：需要的图片是拍摄15739，主要分析信噪比，Gamma值，如果观察动态范围，需要拍摄的图片是灰阶卡。 Dynamic Ragge：需要的拍摄的图片是灰阶卡，主要用来观看动态范围。 Distortion：需要的图片是拍摄棋盘格，主要观察镜头是否发生畸变。 Light Falloff：需要的图片是拍摄18灰，主要用来测试Lens shading(亮度的均匀性)。 Blemish Detect： Uniformity Interactive View/Rename Files：查看/重命名图片 Find Sharp Files： Test Charts：测试拍摄的色卡图片 Screen Pattrns： dcraw Raw view Print Test：打印测试的结果 EXIF：查看拍摄图片的拍摄时间、文件大小、ISO值等详细信息。 Open Fig File：打开fig文件，fig文件是用户界面窗口定义文件。 Options I Options II 2.DebugParser：MTK分析图片工具 AE： AF： AWB： AWBv： Strobe： Flicker： ISP： AF Table Gen： EIS： CMN： MF： N3D： SENSOR： SHAD： SHADv： ColorSHAD： 4.CCT：MTK调试工具5.YuVTools：看图工具YuV文件 6.BuildSoSetup：高通效果参数编译小工具7.7yuv：YUV文件查看工具8.BCompare：对比代码软件可比对的对象包括纯文字档、资料夹、zip 压缩案、FTP 站等。 Bompare的主要目标是详尽的分析差异之处，并且对它们进行详尽的处理。 9.FastStone Image Viewer：一款轻便的看图软件提供了简易的图像编辑功能，可以方便的对图片进行裁剪，添加文本、线条以及调整各种参数等，并且还具有图像的批量转换和重命名等功能。 10.chromatix tools：","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Imatest","slug":"Imatest","permalink":"http://yoursite.com/tags/Imatest/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"常用的图像测试软件","slug":"C-2018-09-13","date":"2018-09-12T18:01:20.000Z","updated":"2018-10-12T14:52:33.908Z","comments":true,"path":"2018/09/13/C-2018-09-13/","link":"","permalink":"http://yoursite.com/2018/09/13/C-2018-09-13/","excerpt":"","text":"1. Imatest的简单了解想要了解一部数位相机的特性、它的影像质量好不好，可以通过色彩的表现、在各个感度的噪声多寡、解像力等多个方面来衡量。 1.1.色彩在色彩、噪声上，我们可以用GretagMacbeth(美国麦克贝斯24色卡)的ColorChecker色卡。 ColorChecker色表如下所示，由上而下、由左而右，它总共有四排、24 个格子。 ColorChecker色表的24格的编号分别从#1-#24。 #1可以代表dark skin，#2可以代表light skin，跟肤色相关。 #13-#18从左而右：B、G、R 这是色彩三原色，然后是 Y、M、C，这是重要的三补色。 第四排的六个格子，左边是白色、右边是黑色，这一排可以代表从影像的亮部、中间调，一直到暗部，都涵盖其中。 1.2.色彩倾向色彩倾向就是色相，物体的固有色，通俗了说就是指平常我们所看到的东西是什么颜色的;没有绝对的冷暖，只有相对的冷暖，比如说黄比蓝暖，但是黄如果和红比就是冷了。 我们可以观看Imatest的测试图表，可以看到类似的效果。 总共测试#1-#18个色彩区块，圆圈处是Olympus E-300的实际表现, 方型处则是色表上的理想值，我们便很容易看出这部相机在每个测试的色彩区块偏移的情况，这是很直觉的、很简单的、容易懂的。 2.Imatest的具体使用2.1.图片清晰度测试 第一步：打开Imatest 第二步：打开SFR:New file选中拍4:3的图片 第三步：对应的报告中的中心分辨率，请看图中红色矩形对应的区域。 第四步：对应的报告中的右上角分辨率，请看图中红色矩形对应的区域。 第五步：对应的报告中的右上角分辨率，请看图中红色矩形对应的区域。 2.2.色彩还原性测试 (AWB)打开colorcheck 选中D65光下的24色卡的图片 用Imatest的&quot;colorcheck&quot;来导入对应的图片，选择合适的测试范围，如下红色矩形区域： 在&quot;Results&quot;中找到对应的&quot;colorerror&quot;分析图，如下图红色矩形区域数据所示：","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Imatest","slug":"Imatest","permalink":"http://yoursite.com/tags/Imatest/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"Camera基础知识的加深了解","slug":"C-2018-09-12","date":"2018-09-12T15:07:08.000Z","updated":"2018-10-12T14:52:21.262Z","comments":true,"path":"2018/09/12/C-2018-09-12/","link":"","permalink":"http://yoursite.com/2018/09/12/C-2018-09-12/","excerpt":"","text":"1.实验室拍摄图片的注意事项 当拍摄多张图片时，最好让相机重新聚焦，在拍摄不同光照的图片之前，重新聚焦的方法是用一张纸在拍摄的镜头前面晃一下即可。 拍摄过程中尽量等摄像头的亮度和颜色稳定后再进行拍摄，尤其是切换光源后。 在拍摄前摄像头时，需要用一张纸挡住屏幕部分，只留出前摄像头，如果不遮挡的话，屏幕会反光。 2.外景拍摄图片的注意事项 用不同型号的设备拍摄图片的时候，视场角最好保持不变。 拍摄图片时选择合适的参照物。 3.白平衡 相机的白平衡控制，是为了让实际环境中白色的物体在你拍摄的画面中也呈&quot;真正&quot;的白色。 每种光源都有色温，从红色到蓝色各不相同，有&quot;暖色调&quot;和&quot;冷色调&quot;之分。 我们的视觉系统会自动对不同的光线做出补偿，所以无论在暖调还是在冷调的光线环境下，我们看到的白纸永远都是白色的。但相机则不然，它只会直接记录呈现在它面前的色彩，这就会导致画面色彩偏暖或偏冷。 通过调节相机预制的白平衡设置，来与当前实际的光线条件相匹配。只要保证白色的物体在画面中呈现出准确的、没有偏色的白，那么画面中所有的其他颜色就也会得到准确的还原。 自动白平衡有他自己的局限性，只有在一个相对有限的色温范围之内，它才够正常工作，所以除了自动白平衡，相机中还会提供一系列白平衡预设，来应对更多特定的光线环境。 3.1.白平衡预设 白织灯白平衡设置会消除预定数量的暖调光线，来让画面的色彩平衡趋向于中性。 日光： 阴影：阴影白平衡设置会消除晴天阴影中特有的冷调。 多云： 每一种预设，都会对其相应的光线做出白平衡校正。 3.2.混合光源很多场景，光线的色温并不是单一的，而是由不同色温的光线混合而成的，比如日光和阴影。 如果设置为日光白平衡的效果：阳光照射的一侧色彩还原是准确的，而阴影覆盖的一侧画面会偏蓝。 如果设置为阴影白平衡效果：图片右侧的色彩还原是准确的，而另一侧则偏暖。 4.感光度ISO代表着camera感光元件的感光速度，一般来说相机的感光器件对光的敏感程度，ISO数值越高说明感光能力越强。 4.1.感光度对摄影的影响的表现 速度，更高的感光度能获得更快的快门速度。 画质，越低的感光度带来更细腻的成像质量，而高感光度的画质噪点比较大。 4.2.对ISO的进一步理解 当光线很暗时，在相同的光圈、快门设置下，低ISO拍摄出来的照片可能会显得很暗，影响也会有些&quot;朦胧&quot;，提高了ISO，照片会变得明亮一些。 在不能加大光圈、降低快门速度的情况下，常用提高ISO来获得足够的曝光量，但随着ISO的提高，照片上产生的&quot;噪点&quot;会随之增加。因此在光线比较好的情况下，应该用低ISO进行拍摄，以保证照片的质量。 ISO值越小，说明所处在的环境较为明亮，感光能力较弱；ISO值越大，说明说明所处的环境较暗，感光能力较强，也就是说，在明亮的环境下，ISO值通常为100~200即可，在暗处的环境下，ISO值通常为1000~2000。 5.锐度锐度(清晰度)，它是反应图像平面清晰度和图像边缘锐利程度的一个指标。 5.1.锐度高的优点 如果将锐度调高，图像平面上的细节对比对也更高，看起来更清楚。 在较高锐度的情况下，垂直方向的深色或黑色线条，或黑白图像突变的地方，线条或黑白图像突变的交接处，其边缘更加锐利，整体画面显得更加清楚。提交锐度，实际上也就提高了清晰度。 5.2.锐度高的缺点如果锐度调的过高，会在黑线两边出现白色线条的镶边，图像看起来失真而且刺眼，同时界面噪点也会更加明显。 6.饱和度/亮度/色度颜色空间的表示有许多种，常有的有RGB，HSV等。 RGB颜色空间将色调，亮度，饱和度三个量放在一起，组合成了一个三维空间。 HSV颜色空间是将RGB颜色空间中的点在倒圆锥体中的表示方法。其中H表示Hue(色相)、S表示Saturation(饱和度)、V表示Luminance(亮度)。 6.1.饱和度饱和度表示色彩的纯度，以%表示，0%(灰色)，100%(完全饱和) 饱和度取决于该色中含色成分和消色成分(灰色)的比例 含色成分越大，饱和度越大；消色成分越大，饱和度越小 纯的颜色都是高度饱和的；混杂上白色，灰色或其他色调的颜色，是不饱和的颜色；完全不饱和的颜色根本没有色调(黑白之间的各种灰色)。 6.2.亮度亮度表示色彩的亮度，以%表示，0%(黑色)，100%(白色) 亮度是指反光体(反光体)表面发光(反光)强弱的物理量。 亮度是人对光的强度的感受，它是一个主观的量。 6.3.色度色度也称色调，色彩在标准色环上的位置 颜色是由亮度和色度共同表示的，色度不包括亮度在内的颜色的性质，它反映的是颜色的色调和饱和度。 7.对比度对比度指的是一副图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比度越小。 一般来说对比度越大，图像越清晰醒目；对比对越小，会让整个画面都灰蒙蒙的。 低对比： 整体过暗 整体过亮 正常对比 8.Flicker(闪光灯)Flicker产生的原因：50Hz/60Hz光源闪烁使曝光不均匀造成的。 9.光圈定义：控制进入物镜光亮的光栏装置 光圈F值=镜头的焦距/镜头光圈的直径 完整的光圈值系列如下：1.0，1.4，2.0，2.8，4.0，5.6，8.0，11，16，22，32，45，64。 手机Camera常用光圈：2.0，2.2，2.4，2.8。 9.1.光圈的作用光圈的作用在于决定镜头的进光量，F值越小，通光孔径越大，在同一单位时间内的进光量便越多。也就是说，在快门速度(曝光速度)不变的情况下，光圈F数值越小光圈就越大，进光量越多，画面比较亮；光圈F数值越大光圈就越小，画面比较暗。 注意：对于已经制造好的镜头，不可能随意改变镜头的直径，但是可以通过在镜头内部加入多边形或者圆形，并且面积可变的孔状光栅来达到控制镜头通光量。 10.焦距焦距，是光学系统中衡量光的聚集或发散的度量方式。 具有短焦距的光学系统比长焦距的光学系统有更好的聚光能力。 11.FF/AF/AE11.1.FFFF(Fixed Focus)定焦：无对焦功能 11.2.AF(Auto Focus)自动对焦自动对焦的方式： 取景界面发生变化时，手机自动对焦(默认开启自动连续对焦) 需手动触动对焦 注意：出现红色提示说明由于画面光线不足，背景反差等原因，相机无法实现自动对焦。 11.3.AE(Auto Expose)自动曝光自动曝光，指相机根据光线条件自动确定曝光量。 注意：出现红色提示说明相机在当时的环境下无法实现自动曝光。 12.HDR(高动态范围图像)HDR(高动态范围图像)，相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR(LOW Dynamic Range[低动态范围])，利用每个曝光时间相对应最佳细节的LDR(低动态范围)图像来合成最终HDR(高动态范围图像)图像，能够更好的反映出真实环境中的视觉效果。 HDR拍照模式适用于拍照场景中有亮暗两部分，比如说灯管场景。 13.ZSD：零延时拍照14.ASD：自动场景检测根据不同的场景，自动给予最佳拍照的设定值，可支持检测到以下7种场景。 15.Flare(杂光、鬼影)Flare是指在拍摄光源或者强光物体时，边缘出现光影或出现一个完整物体的影子，而且这些现象只能减轻不能完全消失，原因是由于镜片的材质导致光线不但存在折射还存在反射，整机由于镜头面到保护镜片距离很大会更明显。 正常情况下 杂光、鬼影 注意：遇到杂光问题，需要先确认Camera镜头是否擦干净。 16.坏点坏点(Defect Pixel)：一般是指在sensor制造过程中因为单个像素的电路异常而不能正常表现感光亮度，其表现形式为全黑情况下成像中单个的白色和彩色的点或者全白情况下成像中的黑点。 17.防手震在video录像时，EIS(电子防抖)会侦测手震的位移量，并加以补偿，使video不会因为手震而晃动(垂直与水平的手震皆可补偿) 主体因手震，在画面上随机晃动 主体因防手震，在画面上较为平稳 EIS(电子防抖)：主要指在数码照相机上采用强制提高CCD感光参数同时加快快门并针对CCD上取得的图像进行分析，然后利用边缘图像进行补偿的防抖。 18.降噪功能当ISO&gt;=800时，开启消噪功能，可降低预览及录像时的噪点。 19.Camera常见问题点1、锐度、噪点 2、饱和度、色彩均一性 3、亮度、亮度均一性 4、闪光灯 5、功能缺失 6、强光下的问题点 调节饱和度问题时要同时兼顾室内外：若室外偏红，室内饱和度太低，这时需要平衡。 20、注意事项1、取景模式(烟火)：适用于黑暗环境下测试 2、合理的使用连拍模式 3、避免闪烁为50Hz时，对着灯光拍照，不能有水波纹。 4、切换语言，进入相机，遍历避免闪烁设置，不能出现空字符。 5、避免闪烁为60Hz。 6、办公室环境下，录制的视频会有水波纹或彩色条纹，这属于正常现象。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Camera tuning","slug":"Camera-tuning","permalink":"http://yoursite.com/tags/Camera-tuning/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"常用的adb命令","slug":"C-2018-09-11","date":"2018-09-11T13:37:28.000Z","updated":"2018-10-12T14:52:02.563Z","comments":true,"path":"2018/09/11/C-2018-09-11/","link":"","permalink":"http://yoursite.com/2018/09/11/C-2018-09-11/","excerpt":"","text":"1.Camera常用的adb命令1.1. adb shell模拟点击事件input，在adb shell中直接输入命令：12345usage: input ...input text &lt;string&gt;input keyevent &lt;key code number or name&gt;input tap &lt;x&gt; &lt;y&gt;input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; input text：模拟输入内容 input keyevent：模拟手机的按键 (27 –&gt; “KEYCODE_CAMERA” ) input tap：模拟点击屏幕生成down-up事件 input swipe：模拟滑动屏幕 1.2. adb root命令：以root权限运行adb。adb的运行原理是pc端的adb Server与手机端的守护进程adbd建立连接，然后pc端的adb Client通过adb Server转发命令，adbd接收命令后解析运行。所以如果adbc以普通权限执行有些需要root权限才能执行的命令无法直接用adb xxx执行。 1.3. adb remount命令：获取文件的读写权限，以root身份进入。1.4. adb reboot命令：重新启动设备。1.5. adb shell rm [options] &lt;files or directory&gt;删除文件或目录。 带有-f的参数：强制删除文件 带有-r的参数：删除该目录以及目录中的所有文件和子目录 带有-d的参数：删除该文件夹 带有-i的参数：删除该文件夹下的所有文件并给出提示 2.Camera常用命令实例2.1.拍摄图片(普通图片)123adb shell input keyevent 27//27 --&gt; &quot;KEYCODE_CAMERA&quot; 2.2.pull图片之后删除检测设备中的图片(普通图片)12adb pull /sdcard/dcim/camera/ .adb shell rm -fr /sdcard/dcim/camera/ 注意：拍摄到的图片的存储路径为当前的文件夹，这里的”.”就是代表当前文件夹的意思，在这里可以随便改为任意的路径。 2.3.拍摄图片(Raw图) 第一步进入到工程模式 12345adb rootadb shell setenforce 0adb shell am start -n com.mediatek.engineermode/com.mediatek.engineermode.EngineerMode 第二步拍摄Raw图片 1adb shell input tap 300 940 2.4.pull图片之后删除检测设备中的图片(Raw图)注意：需要在工程模式的环境下 123adb pull /sdcard/dcim/cameraem .adb shell rm -fr /sdcard/dcim/cameraem 注意：拍摄到的图片的存储路径为当前的文件夹，这里的”.”就是代表当前文件夹的意思，在这里可以随便改为任意的路径。 2.5.把&quot;.so&quot;文件push到测试设备作用：so文件一般都是打包好的共享库文件，放入到被检测的设备中，检测现阶段所做的修改是否使得Camera的性能提升了一些。 12345678910111213141516171819adb rootadb remountadb disable-verity（若执行命令 adb remount未成功，就执行该命令）adb rebootadb rootadb shell &quot;rm -f data/nvram/media/CAMERA*&quot;adb remountadb push libcameracustom.so system/vendor/libadb push libcameracustom.so system/libadb reboot 2.6.抓log(普通模式)123456789adb rootadb remountadb logcat按下Ctrl C键，停止抓log的操作adb logcat &gt; log_0911.txt(将抓取到的log的信息重定向到一个文本文件即可) 注意：在执行抓log命令时，最好用管理员的身份打开CMD，这样在重定向log文件时才会有权限。 2.7.刷机命令进入Fastboot的方式是有两种: 第一种： 1.手机开机状态，确定adb可以打开。 2.adb reboot bootloader 第二种： 1.将手机关机 2.同时按住上音量键和电源键开机 3.这时就进入了fastboot模式。 刷机命令： 第一种方式的刷机命令：adb reboot bootloader python flashimage.py 第二种方式的刷机命令：python flashimage.py 3.学到的新知识3.1.&#39;.bat文件&#39;bat文件是doc下的批处理文件，批处理文件是无格式的文本文件，它包含一条或多条命令，在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用cmd.exe按照该文件中各个命令出现的顺序来逐个运行它们。 3.2.&#39;.sh文件&#39;sh文件是Unix/Linux操作系统的脚本文件。 3.3.&#39;.so文件&#39; so文件是Linux系统中的共享库文件，类似于Windows系统中的dll文件。 dll文件为动态链接库文件在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即dll文件，放置于系统中。当我们执行某一个程序时，相应的dll文件就会被调用。一个应用程序可使用多个dll文件，一个dll文件也可能被不同的应用程序使用，这样的dll文件被称为共享dll文件。 so文件的的格式是ELF格式的文件，在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储的标准文件格式。 3.4. Andriod手机的各种模式 启动模式(normal mode)：正常启动手机，进入正常的系统，也就是用户使用手机的系统。 安全模式(safe mode)：和正常模式类似，但是没有登记Google，所以不能访问Market或者使用Google账号。 恢复模式(recovery mode)：该模式具有相对较高的修改权限，可进行打开命令解释程序(shell)、刷新映像文件(flash image)、执行备份等。 引导模式(BootLoader mode)：从SD卡上安装新的系统映像，其中包括刷系统以及recovery，具有很高的修改权限。 fastboot模式：为了使用fastboot命令来刷新新映像文件，并可以进行清理数据、版本升级等一系列的操作。 诊断模式：为了测试手机各项功能的模式。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"http://yoursite.com/tags/adb命令/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"Camera tuning的大致了解","slug":"C-2018-09-10","date":"2018-09-10T12:28:07.000Z","updated":"2018-10-12T14:51:49.345Z","comments":true,"path":"2018/09/10/C-2018-09-10/","link":"","permalink":"http://yoursite.com/2018/09/10/C-2018-09-10/","excerpt":"","text":"1.Camera性能测试的主要内容 OB：在全黑的环境下，理论上sensor感应到的电流值应该为零，但是由于暗电流的存在，则形成了OB。 Lens shading：要求整张图片亮度，色彩均匀 Color shading：要求整张图片颜色均匀 AE：自动曝光，表现为图片偏暗或者偏亮 AF：自动对焦(CAF) AWB：调试白平衡(R/G/B) Gamma：调试对比度 Color：调试颜色，根据色彩校正矩阵来比对，原本该是什么颜色就是什么颜色 NR：噪点去除 EE：边缘增强 color:PCA：根据实际的场景添加颜色，比如说让蓝天更蓝，白云更白，让整张图片更好看。 2.实验设备的了解 灰卡：18灰，占18%的全灰，主要用来调试白平衡。 DNP：主要用来调试Color shading，查看图片色彩的均匀性。 毛玻璃：同样用来调试Color shading，但是和DNP的使用方法不相同，它们的原理也不相同。 24色卡：测试图片的原色是否全都被还原。 灰阶卡：两个相邻的阶的差值大于8的时候，才被认为是接受的，是可以分清的。 减光片：减弱光的强度 照度计：测量色温，必须尽量满足让中间区域的色温达到客户所要求的值。 实景灯箱： SFRplus： 157319：用来测量噪音，动态范围等。 ISO12232：侧聊图片的解析力(图片的清晰度) 大光源：提供不同的色温(光照强度) 棋盘格：用来测量基变，最好的测量区域是中间的5*3共15格。 LSB灯箱：用来调试亮度，从Level 0~Level 15共有16个不同的阶度，只有两个色温。 3.学到的新东西3.1.&quot;.raw文件&quot;(图像文件)原始图像文件包含从数码相机、扫描器或电影胶片扫描的图像传感器所处理数据。它们尚未被处理，未被打印或用于编辑，通常情况下，原始图像有宽色域的内部色彩，可以进行精确的调整。 3.2.色温色温指绝对黑体从绝对零度(-273度)开始加温后所呈现的颜色。黑色在受热后逐渐由黑变红，转黄，发白，最后发出蓝色光。 当加热到一定的温度黑体发出的光所含的光谱成分，就称为这一温度下的色温。 若光线的色温较高，照片偏冷色调，若光线的色温较低，照片偏暖色调。换句话说，色温越高，光色越偏蓝，色温越低，光色则偏红。 3.3.白平衡使用数码相机拍照时，在日光灯的房间里拍摄的影像会显得发绿，在室内钨丝灯光拍摄出来的景物就会偏黄，而在日光阴影处拍摄到的照片则莫名其妙的偏蓝，原因就是因为白平衡的设置。 为了贴近人的视觉标准，数码相机必须模仿人类大脑并根据光线来调整色彩，数码摄像机的白平衡感测器可以自动的感知周围环境，从而调整色彩的平衡。 4.基础知识的加深了解4.1.光圈定义：控制进入物镜光亮的光栏装置 光圈F值=镜头的焦距/镜头光圈的直径 完整的光圈值系列如下：1.0，1.4，2.0，2.8，4.0，5.6，8.0，11，16，22，32，45，64。 光圈F值越小，通光孔径越大，在同一单位时间内的进光量便越多，而且上一级的进光量刚好是下一级的两倍。 手机Camera常用光圈：2.0，2.2，2.4，2.8。 注意：对于已经制造好的镜头，不可能随意改变镜头的直径，但是可以通过在镜头内部加入多边形或者圆形，并且面积可变的孔状光栅来达到控制镜头通光量。 4.2.快门定义：快门是相机里控制曝光时间的装置。 &quot;安全快门速度&quot;为了保证照片清晰而使用的最慢快门速度。 为了保证照片的清晰，必须使快门速度小于所用镜头焦距的倒数。 &quot;安全快门速度&quot;就是所用的镜头其焦距的倒数，当使用50mm焦距标准镜头拍摄时，安全快门速度为1/60秒，当使用300mm焦距长焦距望远镜头拍摄时，安全快门速度为1/300秒。 4.3.景深景深就是照片焦点前后延伸出来的&quot;可接受的清晰区域&quot;。 光圈数值越小其口径越大，光圈数值越大其口径越小。 清晰度范围的大小被称为”景深”，光圈数值越大时，景深越小，光圈数值越小时，景深越大。","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Camera tuning","slug":"Camera-tuning","permalink":"http://yoursite.com/tags/Camera-tuning/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"Camera基础知识的了解","slug":"C-2018-09-07","date":"2018-09-07T10:09:43.000Z","updated":"2018-10-12T14:51:34.916Z","comments":true,"path":"2018/09/07/C-2018-09-07/","link":"","permalink":"http://yoursite.com/2018/09/07/C-2018-09-07/","excerpt":"","text":"1.色卡色卡是自然界存在的颜色在某种材质上的体现，用于色彩选择、对比、通过，是色彩实现在一定范围内统一标准的工具。 1.1.色卡在国内的标准 纺织服装行业:CNCS色卡 建筑行业:GB/T15608-2006 汽车行业:国内外汽车贴膜专用色卡 漆膜颜色样卡:全国涂料和颜料标准化技术委员会 2.手机Camera模组结构 Lens:表示镜头，镜头中的镜片分为球面和非球面，手机镜片一般都采用非球面设计，可消除一定的球差，提高图像的边角解像力。 VCM:表示音圈马达。 工作原理:线圈通电后会产生磁场，流经磁场的电流大小可以推动镜头进行向前或者向后的移动，这就形成了一个简易的马达，这个过程将电能转换成了机械能。 滤光片:过滤到人眼不可见的光，使得Sensor只接收人眼可见的光。 Sensor:图片传感器，一般分为两类，CCD(电荷耦合器件)和CMOS(互补性氧化物半导体) 3.一个Camera的工作原理景物通过镜头(Lens)生成光学图像投射到图像传感器(Sensor)表面上，然后转换成电信号，经过A/D(模数转换)变成数字图像信号，再送到数字信号处理(DSP)中加工处理，通过DISPLAY的设备显示出来。 4.手机Camera性能相关测试 色彩还原性及AWB(自动白平衡) 解析力/清晰度 亮度均一性和色彩均一性测试 SNR(信噪比) AE(自动曝光) 视场角及畸变 坏点 其他问题的测试(紫边,炫光,黑太阳)","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Camera tuning","slug":"Camera-tuning","permalink":"http://yoursite.com/tags/Camera-tuning/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"2018-09-06日报之Linux系统的目录结构","slug":"C-2018-09-06","date":"2018-09-06T14:15:58.000Z","updated":"2018-10-12T13:12:40.604Z","comments":true,"path":"2018/09/06/C-2018-09-06/","link":"","permalink":"http://yoursite.com/2018/09/06/C-2018-09-06/","excerpt":"","text":"一、早上1.了解关于数码相机的基本知识，基本使用技巧。 2.在IT知识导引中学习了Linux系统的目录结构以及Linux系统的硬盘挂载。 二、下午看了一部分实习生的文档，学习了一些新的名词。 1.SFRplus:图像测试卡 2.OECF:光电转换函数 3.Uniformity:像面响应均匀性 4.主观测试和客观测试 三、晚上旁听Peter的实习答辩，关于PPT的制作方面收获很大，主要包括以下方面。 1.注意细节问题。包括标点符号的正确使用，中英文符号环境的正确切换以及英语单词首字母开头大写等。 2.整体文档字体大小统一，重点部分最好突出显示，云朵图片中显示的内容一般用于注释或者文档，不能突出重点。 3.事件的逻辑顺序必须要正确的罗列。 四、明日计划","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[{"name":"Camera","slug":"Camera","permalink":"http://yoursite.com/categories/Camera/"}]},{"title":"5-2-分布式Git","slug":"5-2-分布式Git","date":"2018-08-28T15:54:21.000Z","updated":"2018-10-12T14:47:38.898Z","comments":true,"path":"2018/08/28/5-2-分布式Git/","link":"","permalink":"http://yoursite.com/2018/08/28/5-2-分布式Git/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"5-1-分布式Git","slug":"5-1.分布式Git","date":"2018-08-26T11:50:59.000Z","updated":"2018-10-12T14:47:46.344Z","comments":true,"path":"2018/08/26/5-1.分布式Git/","link":"","permalink":"http://yoursite.com/2018/08/26/5-1.分布式Git/","excerpt":"","text":"1.分布式工作流程2.向一个项目贡献3.维护项目","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-3-服务器上的Git","slug":"4-3-服务器上的Git","date":"2018-08-24T13:35:08.000Z","updated":"2018-10-12T14:47:55.958Z","comments":true,"path":"2018/08/24/4-3-服务器上的Git/","link":"","permalink":"http://yoursite.com/2018/08/24/4-3-服务器上的Git/","excerpt":"","text":"7.GitWeb8.GitLab9.第三方托管的选择","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-2-服务器上的Git","slug":"4-2.服务器上的Git","date":"2018-08-22T10:08:02.000Z","updated":"2018-10-12T14:47:57.791Z","comments":true,"path":"2018/08/22/4-2.服务器上的Git/","link":"","permalink":"http://yoursite.com/2018/08/22/4-2.服务器上的Git/","excerpt":"","text":"3.生成SSH公钥4.配置服务器5.Git守护进程6.Smart HTTP","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-1-服务器上的Git","slug":"4-1.服务器上的Git","date":"2018-08-20T04:20:19.000Z","updated":"2018-10-12T14:45:42.594Z","comments":true,"path":"2018/08/20/4-1.服务器上的Git/","link":"","permalink":"http://yoursite.com/2018/08/20/4-1.服务器上的Git/","excerpt":"","text":"1.协议1.1.本地协议1.1.1.优点1.1.2.缺点1.2.HTTP协议1.2.1.智能(Smart)HTTP协议1.2.2.哑(Dumb)HTTP协议1.2.3.优点1.2.4.缺点1.3.SSH协议1.3.1.优点1.3.2.缺点1.4.Git协议1.4.1.优点1.4.2.缺点2.在服务器上搭建Git2.1.把裸仓库放在服务器上2.2.小型安装2.2.1.SSH连接","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-5-Git分支","slug":"3-5-Git分支","date":"2018-08-16T16:42:58.000Z","updated":"2018-10-12T14:48:09.715Z","comments":true,"path":"2018/08/17/3-5-Git分支/","link":"","permalink":"http://yoursite.com/2018/08/17/3-5-Git分支/","excerpt":"","text":"6.2.一个变基的例子在对两个分支进行变基时，也可以指定另外的一个分支进行应用，就像从一个特性分支里再分出一个特性分支的提交历史。 举例：创建了一个特性分支server，为服务器添加了一些功能，提交了C3和C4，然后在C3上创建了特性分支client，为客户端添加了一些功能，提交了C8和C9，最后，回到了server分支，又提交了C10。 从一个特性分支里再分出一个特性分支的提交历史 6.2.1.git rebase命名 + --onto选项的使用如果希望将client中的修改合并到主分支并发布，但是并不想合并server中的修改，也就是说，选中在client分支里但不在server分支里的修改(C8和C9)，将它们变基到master分支上。 1$ git rebase --onto master server client 取出cilent分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们变基到master分支上。 截取特性分支上的另一个特性分支，然后变基到其他分支 这时，就可以切回到master分支，进行一次快进合并。 12$ git checkout master$ git merge client 快速合并master分支，使之包含来自cilent分支的修改 6.2.2.git rebase [basebranch] [topbranch]命令git rebase [basebranch] [topbranch]命令可以直接将特性分支(server)变基到目标分支(master)上。 1$ git rebase master server 将server中的修改变基到master上 这时，就可以切回到master分支，进行一次快进合并。 12$ git checkout master$ git merge server 这时，client和server分支中的修改都已经整合到主分支中了，可以删除掉client和server分支了。 12$ git branch -d client$ git branch -d server 最终的提交历史 6.3.变更的风险6.3.1.变基的准则—不要对在你的仓库外有副本的分支执行变基变基操作实质是丢弃一些现有的提交，然后相应地新建一些内容但实际上不同的提交。如果已经将提交推送至某个仓库，其他人已经从该仓库拉取提交并进行了后续工作，如果再使用git rebase命令重新整理提交并再次推送，这时候就会变得一团糟。 举例：(在公开的仓库上执行变基操作)假设从一个中央服务器克隆并且在它的基础上进行一些开发，提交历史如下。 克隆一个仓库，然后在它的基础上进行了一些开发 然后，其他人向中央服务器提交了一些修改，其中包括一次合并，这时，又一次抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样： 抓取别人的提交，合并到自己的开发分支 突然，这个人又决定把合并操作回滚，改用变基，使用git push --force命令更新了服务器上的提交历史。更新之后，如果再从服务器上抓取更新，就会发现会多出一些新的提交历史。 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 此时，如果执行git pull命令，将会合并来自两条提交历史的内容，生成一个新的和并提交。 将相同的内容又合并了一次，生成了一个新的提交 如果执行git log命令，会发现有两个提交的作者、日期、日志。并且是一样的，这会是非常混乱的。 6.3.2.用变基解决变基如果团队中的某人强制推送并覆盖了一些你所基于的提交，我们需要知道你做了哪些修改，以及他们覆盖了哪些提交。 举例(有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交) 检查哪些提交是自己分支上独有的(C2，C3，C4，C6，C7) 检查其中哪些提交不是合并操作的结果(C2，C3，C4) 检查哪些提交在对方覆盖更新时并没有被纳入目标分支(只有C2和C3，C4就是C4´) 把查到的这些提交应用到my_ying/master上面 此时，将相同的内容又合并了一次，生成了一个新的提交中不同的结果，也就是说，在一个被变基然后强制推送的分支上再次执行变基。 在一个被变基然后强制推送的分支上再次执行变基 6.3.3.变基VS合并仓库的提交历史就是记录实际发生过什么，它是针对历史的文档，不能乱改，也就是说，只对尚未推送或分享给别人的本地修改指向变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才是最好的选择。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-4-Git分支","slug":"3-4.Git分支","date":"2018-08-15T08:28:10.000Z","updated":"2018-10-12T14:48:13.849Z","comments":true,"path":"2018/08/15/3-4.Git分支/","link":"","permalink":"http://yoursite.com/2018/08/15/3-4.Git分支/","excerpt":"","text":"5.1.推送当想要公开分享一个分支时，需要将其推送到具有写入权限的远程仓库上，本地的分支并不会自动地与远程仓库同步，必须显示地推送想要分享到分支。 命令：git push (remote)(branch) 12345678910$ git push origin my_yingCounting objects: 9, done.Delta compression using up to 4 threads.Compressing objects: 100% (9/9), done.Writing objects: 100% (9/9), 3.90 KiB | 0 bytes/s, done.Total 9 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), completed with 5 local objects.To git@github.com:Alicesii/Git.git dbd8323..58b5dbd master -&gt; masterBranch master set up to track remote branch master from origin. 其他人从服务器上抓取数据时，它们会在本地生成一个远程分支origin/my_ying，指向服务器的my_ying分支的引用。 1234567$ git pull originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/my_ying * [new branch] my_ying -&gt; oriin/server 5.2.跟踪分支从一个远程分支检索出一个本地分支会自动创建&quot;跟踪分支&quot;，跟踪分支是与远程分支有直接关系的本地分支。也就是说，Git能自动识别去哪个服务器上抓取，合并到哪个分支。 当克隆一个仓库时，Git会自动创建一个跟踪origin/master的master分支。 当在本地初始化一个仓库时(git init命令)，Git也会自动创建一个空的跟踪分支。 git branch命名+-vv选项，可以查看设置的所有跟踪分支。这会将所有的本地分支列出来并且包含更多的信息。也就是说如果每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 123456$ git branch -vv iss16 7e424c3 [origin/iss16: ahead 2] forgot the bracke master c9dff3c [origin/master] fif-Camera* my_ying f8674d9 [origin/my_ying: ahead 3, behind 1] thisshould do it testing 5ea463a trying something n 说明： iss16分支正在跟踪origin/my_ying并且&quot;ahead&quot;是2，意味着本地有两个提交还没有推送到服务器上。 master分支正在跟踪origin/master分支并且是最新的. my_ying分支正在跟踪master服务器上的my_ying分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 testing分支并没有跟踪任何远程分支。 5.3.拉取git pull命令：从远程仓库拉取到本地仓库。 1234567$ git pull originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/my_ying * [new branch] my_ying -&gt; oriin/server 5.4.删除远程分支git push命令+--delete选项+分支名称：删除远程分支。 如果已经通过远程分支做完了所有工作，并且这个特性分支已经合并到了远程仓库的master分支，就可以从服务器上删除这个没有用的分支了。 123$ git push origin --delete my_yingTo https://github.com/my_ying - [deleted] my_ying 这个命令只是从服务器上移除这个指针，Git服务器通常会保留数据一段时间直到垃圾回收运行。 6.变基整合不同分支的修改主要有两种方法：&quot;merge&quot;(融合)和&quot;rebase&quot;(变基)。 6.1.变基的基本操作6.1.1.merge命令的回顾 分支的提交历史 &quot;merge&quot;命令是指它会把两个分支的最新快照(c3和c4)以及二者最近的共同祖先(c2)进行三方合并，合并的结果是生成一个新的快照(并提交)。 通过合并操作来整合分支的历史 6.1.2.rebase(变基)rebase命令是指：将提交到某一个分支上的所有修改都移至另一个分支上，也就是说可以提取在C4中引入的补丁和修改，然后在C3的基础上应用一次。 1234$ git checkout my_ying$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 原理：首先找到这两个分支(当前分支my_ying、变基操作的目标基底分支master)的最近共同祖先C2，然后对比当前分支相对于该分支的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底C3，最后以此将之前另存为临时文件的修改依序应用。 将C4中的修改变基到C3上 这时，就可以切回到master分支，进行一次快进合并。 12$ git checkout master$ git merge my_ying master分支的快进合并 这时，C4＇指向的快照就和使用merge命令例子中C5指向的快照一模一样，&quot;merge&quot;和&quot;rebase&quot;这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。其实我们可以发现，尽管实际的开发工作是并行的，但是它们看上去就像是串行的一样，提交历史是一条直线没有分叉。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-3-Git分支","slug":"3-3-Git分支","date":"2018-08-12T23:08:59.000Z","updated":"2018-10-12T14:48:16.535Z","comments":true,"path":"2018/08/13/3-3-Git分支/","link":"","permalink":"http://yoursite.com/2018/08/13/3-3-Git分支/","excerpt":"","text":"3.分支管理git branch命令在不加任何参数运行时，会得到当前所有分值的一个列表。 1234$ git branch iss16 * master feature *字符：代表现在正处于哪一个分支(master分支)，也就是当前HEAD指针所指向的分支。如果在这时提交，master分支会随着新的工作向前移动。 git branch -v命令：查看每一个分支的最后一次提交。 1234$ git branch -v iss16 93b412c new branch * master 0f704f0 master feature bb5c431 anther brabch --merged选项过滤列表中已经合并到当前分支的分支。 123$ git branch --merged iss16* master 在该列表中分支名字前没有*号的分支可以使用git branch -d命令删除。 --no-merged选项过滤列表中尚未合并到当前分支的分支。 12$ git branch --no-merged feature 使用git branch -d命令删除feature命令时会失败。 123$ git branch -d featureerror: The branch &apos;feature&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature&apos;. 可以使用&#39;git branch -D&#39;命名删除feature分支，但是会丢掉在该分支上的工作。 4.分支开发工作流4.1.长期分支(master分支)在整个项目开发周期的不同阶段，可以拥有多个开放的分支，可以定期地把某些特性分支合并入其他分支中。 一般情况下，在master分支上保留完全稳定的代码，有可能仅是已经发布或即将发布的代码，可能有一些名字为develop或next的平行分支，被用来做后续开发或者测试稳定性。 develop或next分支不需要保持绝对稳定，一旦达到稳定状态，就需要被合并到master分支。 在确保已完成的特性分支(短期分支[iss16])能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支，等待下一次的发布。 稳定分支的指针总是在提交历史中落后一大截，前沿分支的指针比较靠前。 渐进稳定分支的线形图。 就像流水线一样，经过测试的提交会被提交到更加稳定的流水线。 渐进稳定分支的流水线视图 4.2.特性分支特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 在特性分支(iss16和hotfix分支)中提交一些更新，并且把它们合并到主干分支之后，又删除了特性分支。这样做能使你快速并且完整地进行上下文切换，因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关。 举例： 你在master分支上工作到C1，这时为了解决问题#18而新建iss91分支，在iss91分支上工作到C4，对于问题#18你又有了新的想法，所有你再新建一个iss91v2分支试图用另一种方法解决问题#18，接着你回到master分支工作了一会儿，你又冒出了一个不太确定的想法，于是你在C10的时候新建一个dumbidea分支，并在上面解决该问题。 拥有多个特性分支的提交历史 假如你决定使用iss91v2分支和dumbidea分支中的方案的其中一个，就可以丢掉和iss91分支(丢弃C5和C6提交)，然后把另外两个分支合并入主干分支。 合并dumbidea分支和iss91v2分支 5.远程分支远程跟踪分支是远程分支状态的引用，它们是不能移动的本地分支，当不论做任何操作时，它们会自动移动。 命名形式：(remote)/(branch) 举例：查看最后一次与远程仓库origin通信时master分支的状态，可以查看origin/master分支。 假设从Git服务器git.ying.com上克隆一个项目，Git的pull命令会为你自动将其命名为origin，拉取它的所有数据，创建一个指向它的master分支的指针，并且在本地将其命名为origin/master。 克隆之后的服务器与本地仓库 如果你在本地的master分支做了一些工作，在同一时间，其他人推送提交到git.ying.com服务器并更新了它的master分支，这时会发生两种状况。 第一种情况：与origin服务器连接 提交历史将向不同的方向前进。 第二种情况：没有与origin服务器连接 origin/master指针不会移动 本地与远程的工作分叉 git pull origin命令：向远程仓库同步你的工作。 git pull origin命令：查找&quot;origin&quot;是哪一个服务器(git.ying.com)，从中抓取本地没有的数据，并且更新本地数据库，移动origin/master指针指向新的、更新后的位置。 git pull命令更新远程仓库地引用 举例： 假设存在另一个内部的Git服务器，用于开发新的项目，这个服务器位于git.my_ying.com，我们可以添加另一个新的远程仓库引用到当前新的项目。 git remote add命令：添加一个新的远程仓库引用到当前的项目，远程仓库的命名为my_ying。 添加另一个远程仓库 运行git pull origin命令来抓取远程仓库my_ying而本地没有的数据，这台服务器上现有的数据是origin服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支my_ying/master指向my_ying的master分支。 远程跟踪分支my_ying/master","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-2-Git分支","slug":"3-2-Git分支","date":"2018-08-11T11:00:39.000Z","updated":"2018-10-12T14:48:19.523Z","comments":true,"path":"2018/08/11/3-2-Git分支/","link":"","permalink":"http://yoursite.com/2018/08/11/3-2-Git分支/","excerpt":"","text":"2.分支的新建与合并分支新建与分支合并的场景(工作流)： 1、开发某个网站 2、为实现某个新的需求，创建一个分支 3、在这个分支上开展工作。 此时，你突然接到一个电话说有个很严重的问题需要紧急修补，你将按照如下方式来处理： 1、切换到你的线上分支 2、为这个紧急任务新建一个分支，并在其中修复它。 3、在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 4、切换回你最初工作的分支上，继续工作。 2.1.新建分支假设存在一个正在开发过程中的项目，并且已经有了一些提交。 一个简单提交历史 如果你需要解决编号为#16的需求问题，你需要创建一个新的分支，然后切换到该分支上。 简写方式： 12$ git checkout -b iss16Switched to a new branch &apos;iss16&apos; 非简写方式： 123$ git branch iss16$ git checkout iss16Switched to branch &apos;iss16&apos; 创建一个新分支指针 现在可以开始在iss16分支上解决编号#16的需求，在此过程中，你做了一些提交，所以iss16分支在不断的向前推进，此时HEAD指针指向了iss16分支上。 12$ git add *$ git commit -a -m &apos;new branch&apos; iss16分支随着工作的进展向前推进 当你接到电话时，有个紧急问题等待你来解决，在Git下，不需要把这个紧急问题和iss16的修改混在一起，也不需要还原#16问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。你所需要做的仅仅是切回到master分支。 在切回到master分支之前，必须保证所有的工作目录和暂存区中的修改的文件是被提交的状态。 12345$ git statusOn branch iss16nothing to commit, working directory clean$ git checkout masterSwitched to branch &apos;master&apos; 此时，你的工作目录和在开始处理#16需求之前一模一样，现在可以开始修复紧急问题了。 你可以建立一个针对该紧急问题的分支(hotfix branch)，在该分支上解决该紧急问题。 1234567$ git checkout -b hotfixSwitched to a new branch &apos;hotfix&apos;$ vim README.md$ git add *$ git commit -a -m &apos;fixed hotfix branch&apos;[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) 基于master分支的紧急问题分支hotfix branch 注意：当切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。Git会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 当修改完成这个紧急问题后，使用git merge命令，将hotfix分支合并回master分支。 1234567$ git checkout masterSwitched to branch &apos;master&apos;$ git merge hotfixUpdating f42c576..3a0874cFast-forward README.md | 2 ++ 1 file changed, 2 insertions(+) master被快进到hotfix Fast-forward的解释： Fast-forward表示&quot;快进&quot;，由于当前master分支所指向的提交是你当前提交的的直接上游，所以Git只是简单的将指针向前移动。也就是说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有发生冲突。 当解决完该紧急问题之后，你准备继续处理#16的需求，但是你应该先删除hotfix分支，因为已经不再需要它了，master分支已经指向了同一个位置。 简写方式： 12$ git checkout -d hotfixDeleted branch hotfix 非简写方式： 123$ git checkout hotfix$ git delete hotfixDeleted branch hotfix 这时，可以继续处理#16的需求了。 1234567$ git checkout iss16Switched to branch &quot;iss16&quot;$ vim README.md$ git add *$ git commit -a -m &apos;fixed iss16 branch&apos;[iss16 ad82d7a] fixed the broken email address 1 file changed, 2 insertions(+) 继续在iss16分支上工作 在hotfix分支上所做的工作并没有包含到iss16分支中。 2.2.分支的合并现在已经完成了#16的需求，需要将iss16分支合并到master分支。 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge iss16Merge made by the &apos;recursive&apos; strategy.README.md | 1 +1 file changed, 1 insertion(+) 此时分支的合并并不是Fast-forward的形式，master分支所在提交不是iss16所在提交的直接祖先，在这种情况下，你的开发历史从一个更早的地方开始分叉开来。Git需要做一些额外的工作。 Git会使用两个分支的末端所指的快照(C4和C5)以及这两个分支的工作祖先(C2)，做一个简单的三方合并。 一次典型合并中所用到的三个快照 Git将三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它，这个被称作一次合并提交 一个合并提交 Git会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础。 当完成合并之后，需要删除iss16分支。 12$ git checkout -d iss16Deleted branch iss16 2.3.遇到冲突时的分支合并如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git在合并时就会产生冲突： 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge iss16Auto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed;fix conflicts and then commit the result. Git做了合并，但是没有自动地创建一个新的合并提交。Git会暂停下来，等待你去解决合并产生的冲突。 解决冲突的步骤： 第一步：使用git status命令查看包含合并冲突而处于未合并状态的文件。 123456789$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 第二步：Git会在有冲突的文件中加入标准的冲突解决标记，你可以打开这些包含冲突的文件手动解决冲突。出现冲突的文件会包含一些特殊区段。 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:README.md&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss16:README.md 这表示HEAD所指示的版本(master分支所在的位置)在=======的上半部分，而iss16分支所指示的版本在=======的下半部分。 第三步：为了解决冲突，你必须选择使用由=======分割的两部分中的一个，或者也可以自行合并这些内容。 1234//选择上半部分或者下半部分&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt; 该解决方案仅保留了其中一个分支的修改，并且&lt;&lt;&lt;&lt;&lt;&lt;&lt;,=======,和&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行被完全删除。 当解决了所有文件里的冲突之后，对所有文件使用git add命令将其标记为冲突已解决。 自行合并冲突：$ git mergetool命令 该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突. 1234567891011121314$ git mergetoolThis message is displayed because &apos;merge.tool&apos; is not configured.See &apos;git meergetool --tool-help&apos; or &apos;git help config&apos; for more details.&apos;git mergetool&apos; will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffusediffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:README.mdNormal merge conflict for &apos;README.md&apos;: &#123;local&#125;: modified file &#123;remote&#125;: modified fileHit return to start merge resolution tool (opendiff): 当退出合并工具之后，Git会询问刚才的合并是否成功。如果回答是，Git会暂存那些文件以表明冲突已解决： 1234567$ git statusOn branch masterAll conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge)Changes to be committed: modified: README.md 第四步：当所有的有冲突的文件都已经暂存，就可以提交到Git仓库中。 123456789101112131415161718$ git commit -m &quot;solve merge branch&quot;Merge branch &apos;iss16&apos;Conflicts: README.md## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git# and try again.# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: README.md","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-1-Git分支","slug":"3-1-Git分支","date":"2018-08-09T03:20:19.000Z","updated":"2018-10-12T14:48:23.087Z","comments":true,"path":"2018/08/09/3-1-Git分支/","link":"","permalink":"http://yoursite.com/2018/08/09/3-1-Git分支/","excerpt":"","text":"使用分支意味着你可以把你的工作从开发主线上分离出来，以免影响开发主线。合理的利用分支，将会提高你的开发效率。 1.分支简介Git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。 在进行提交操作时，Git会保存一个提交对象，该提交对象会包含一个指向暂存内容快照的指针，还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。 举例：假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和(SHA-1哈希算法)，然后会把当前版本的文件快照保存到Git仓库中，最终将校验和加入到暂存区域等待提交。 12345678910111213$ git add A.md B.md C.md$ git commit -m &apos;my project&apos;[master (root-commit) 6beec10] my project 3 files changed, 194 insertions(+) create mode 100644 A.md create mode 100644 READ.md create mode 100644 README.md$ git logcommit 6beec10a754d1614768a055bff34aa007910b30eAuthor: ying &lt;1511317497@qq.com&gt;Date: Thu Aug 2 22:23:11 2018 +0800 my project 当使用git commit进行提交操作时，Git会先计算每一个子目录(项目根目录)的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象(项目根目录)的指针。 也就是说，Git仓库中有五个对象，三个blob对象(保存着文件快照)、一个树对象(记录着目录结构和blob对象索引)以及一个提交对象(包含着指向树对象的指针和所有提交信息)。 首次提交对象及其树结构 做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象(父对象)的指针。 123456789101112131415161718$ git logcommit b4fa11682c5a00cacdbc103bfbd6795a6dd900b2Author: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:37:49 2018 +0800 second-Gitcommit 9c36a3dba4a14c96b650555658a01f211c9274bfAuthor: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:36:55 2018 +0800 first-Gitcommit 6beec10a754d1614768a055bff34aa007910b30eAuthor: ying &lt;1511317497@qq.com&gt;Date: Thu Aug 2 22:23:11 2018 +0800 my project 提交对象及其父对象 Git的分支，其实本质上仅仅是指向提交对象的可变指针。Git的默认分支名字是master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支，它会在每次的提交操作中自动向前移动。 分支及其提交历史 1.1.分支创建git branch命令：创建新的分支，创建了一个可以移动的新的指针。 1git branch feature 也就是在当前所在的提交对象上创建一个指针 两个指向相同提交历史的分支 是不是有疑问，Git怎么知道当前在哪一个分支上呢？ 在Git中，它有一个名为HEAD的特殊指针，指向当前所在的本地分支。git branch命令仅仅创建一个新分支，并不会自动切换到新分支，现在仍然在master分支。 HEAD指向当前所在的分支 使用git log命令查看各个分支当前所指的对象，需要使用–decorate参数。 1234$ git log --pretty=oneline --decorateb4fa11682c5a00cacdbc103bfbd6795a6dd900b2 (HEAD -&gt; master, feature) second-Git9c36a3dba4a14c96b650555658a01f211c9274bf first-Git6beec10a754d1614768a055bff34aa007910b30e my project 我们可以看到，当前&quot;master&quot;和&quot;feature&quot;分支均指向校验和以b4fa116开头的提交对象。 1.2.分支切换git checkout命令：切换到一个已存在的分支。 12$ git checkout featureSwitched to branch &apos;feature&apos; 现在Head就指向feature分支了。 HEAD指向当前所在的分支 利用分支的形式有什么优点呢，我们可以来看一下： 123456789101112131415161718192021222324252627282930313233$ git add *$ git commit -m &apos;anther brabch&apos;[feature bb5c431] anther brabch 1 file changed, 1 insertion(+), 1 deletion(-)$ git logcommit bb5c431f59dd83b3ffcefa587f2959eba5c3e60dAuthor: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 19:11:07 2018 +0800 anther branchcommit b4fa11682c5a00cacdbc103bfbd6795a6dd900b2Author: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:37:49 2018 +0800 second-Gitcommit 9c36a3dba4a14c96b650555658a01f211c9274bfAuthor: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:36:55 2018 +0800 first-Gitcommit 6beec10a754d1614768a055bff34aa007910b30eAuthor: ying &lt;1511317497@qq.com&gt;Date: Thu Aug 2 22:23:11 2018 +0800 my project$ git log --pretty=oneline --decoratebb5c431f59dd83b3ffcefa587f2959eba5c3e60d (HEAD -&gt; feature) anther branchb4fa11682c5a00cacdbc103bfbd6795a6dd900b2 (master) second-Git9c36a3dba4a14c96b650555658a01f211c9274bf first-Git6beec10a754d1614768a055bff34aa007910b30e my project HEAD分支随着提交操作自动向前移动 从图中可以，feature分支向前移动了，但master分支却没有，我们可以切换到master分支。 12$ git checkout masterSwitched to branch &apos;master&apos; HEAD指针随着分支的变化移动 git checkout命令有两个功能： 一是使HEAD指针指回master分支 二是将工作目录恢复成master分支所指向的快照内容，也就是说，如果现在修改的话，项目将使于一个较旧的版本，本质上来说，是忽略eature分支所做的修改，以便于向另一个方向进行开发。 注意：分支切换会改变你工作目录中的文件 在切换分支时，如果切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的状态。 1234567891011121314151617181920212223242526272829303132$ git add *dell@yang MINGW64 /e/维护/A/算法的日常/链表 (master)$ git commit -m &apos;master&apos;[master 0f704f0] master 3 files changed, 3 insertions(+), 3 deletions(-)dell@yang MINGW64 /e/维护/A/算法的日常/链表 (master)$ git logcommit 0f704f0df86d9e044906c557be9d5976e91f1076Author: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 20:42:13 2018 +0800 mastercommit b4fa11682c5a00cacdbc103bfbd6795a6dd900b2Author: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:37:49 2018 +0800 second-Gitcommit 9c36a3dba4a14c96b650555658a01f211c9274bfAuthor: ying &lt;1511317497@qq.com&gt;Date: Fri Aug 3 15:36:55 2018 +0800 first-Gitcommit 6beec10a754d1614768a055bff34aa007910b30eAuthor: ying &lt;1511317497@qq.com&gt;Date: Thu Aug 2 22:23:11 2018 +0800 my project 这时，项目的提交历史已经产生了分支，因为刚才创建了一个新分支，并切换过去进行了一些工作，随后又切换回master分支进行了另外一些工作。 项目分叉历史 使用git log命令查看各个分支当前所指的对象以及分支的历史，利用–oneline、–decorate、–graph、–all参数，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 1234567$ git log --pretty=oneline --decorate --graph --all* 0f704f0df86d9e044906c557be9d5976e91f1076 (HEAD -&gt; master) master| * bb5c431f59dd83b3ffcefa587f2959eba5c3e60d (feature) anther brabch|/* b4fa11682c5a00cacdbc103bfbd6795a6dd900b2 second-Git* 9c36a3dba4a14c96b650555658a01f211c9274bf first-Git* 6beec10a754d1614768a055bff34aa007910b30e my project","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-6-Git基础","slug":"2-5-Git基础","date":"2018-08-06T16:10:35.000Z","updated":"2018-10-12T14:48:41.607Z","comments":true,"path":"2018/08/07/2-5-Git基础/","link":"","permalink":"http://yoursite.com/2018/08/07/2-5-Git基础/","excerpt":"","text":"6.打标签Git可以给历史中的某一个提交打上标签，作为重要的标志。常用这个功能来标记发布节点。 6.1.列出标签git tag命令：列出Git中已有的标签。 123$ git tagv1.0v1.1 以字母顺序列出标签，但是它们出现的顺序并不重要。 可以使用特定的模式查找标签： 1234567891011$ git tag -l &apos;v1.8.5*&apos;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5 6.2.创建标签Git使用两种类型的标签：轻量标签和附注标签。 一个轻量标签像一个不会改变的分支，它只是一个特定提交的引用。 附注标签是存储在Git数据库中的一个完整对象，它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间;一个标签信息;并且可以使用GPG签名与验证。 一般情况下都会创建附注标签，这样你可以拥有以上所有的详细信息;但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，这时可以选择轻量标签。 注：GPG它是目前最流行、最好用的加密工具之一。 6.3.附注标签git tag -a命令：创建一个附注标签。 1234$ git tag -a v1.1 -m &apos;my version 1.1&apos;$ git tagv1.0v1.1 -m选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。 git show命令：看到标签信息与对应的提交信息。 123456789101112131415161718$ git show v1.0tag v1.0Tagger: ying &lt;1511317497@qq.com&gt;Date: Wed Aug 1 23:12:00 2018 +0800my version 1.0commit 474f2b97636314959f312fce6ed9202260363877Author: ying &lt;1511317497@qq.com&gt;Date: Tue Jul 31 16:38:49 2018 +0800 Git-firstdiff --git &quot;a/README.md&quot; &quot;b/README.md&quot;index a548fa5..3fafe74 100644--- &quot;a/README.md&quot;+++ &quot;b/README.md&quot;@@ -377,7 +377,7 @@ Changes to be committed: 输出显示了打标签者的信息、打标签的日期信息、附注信息，然后显示具体的提交信息。 6.4.轻量标签轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 创建轻量标签，不需要使用-a、-s或-m选项，只需要提供标签名字： 12345678$ git tag v1.4$ git tagv1.0v1.1v1.2v1.3v1.4v1.5 运行git show命令，只会显示出提交信息，不会看到额外的标签信息。 123456789101112$ git show v1.4commit 474f2b97636314959f312fce6ed9202260363877Author: ying &lt;1511317497@qq.com&gt;Date: Tue Jul 31 16:38:49 2018 +0800 Git-firstdiff --git &quot;a/README.md&quot; &quot;b/README.md&quot;index a548fa5..3fafe74 100644--- &quot;a/README.md&quot;+++ &quot;b/README.md&quot;@@ -377,7 +377,7 @@ Changes to be committed: 6.5.后期打标签假如提交历史如下： 1234$ git log --pretty=oneline474f2b97636314959f312fce6ed9202260363877 Git-first7022a109f04ab32f38a7e1bf987e77abb52818fb second-Git9358d279319fa10a7018e9aa2320259e417c6eb5 first-Git 如果在v1.3.1时忘记给项目打标签，也就是在second-Git提交，其实你可以在之后补上标签。 需要在命令的末尾指定提交的校验和(或者部分校验和)： 12345678910111213141516171819202122232425262728$ git tag -a v1.3.1 7022a109f0$ git tag$ git tagv1.0v1.1v1.2v1.3v1.3.1v1.4v1.5$ git show v1.3.1tag v1.3.1Tagger: ying &lt;1511317497@qq.com&gt;Date: Wed Aug 2 10:58:01 2018 +0800my version 1.3.1commit 474f2b97636314959f312fce6ed9202260363877Author: ying &lt;1511317497@qq.com&gt;Date: Tue Jul 31 16:38:49 2018 +0800 second-Gitdiff --git &quot;a/README.md&quot; &quot;b/README.md&quot;index a548fa5..3fafe74 100644--- &quot;a/README.md&quot;+++ &quot;b/README.md&quot;@@ -377,7 +377,7 @@ Changes to be committed: 6.6.共享标签默认情况下，git push命令并不会传送标签到远程仓库服务器上，在创建完标签后你必须显示地推送标签到共享服务器上。 git push origin [tagname]命令 123456$ git push origin v1.0Counting objects: 1, done.Writing objects: 100% (1/1), 155 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:Alicesii/Git.git * [new tag] v1.0 -&gt; v1.0 带--tags选项的git push命令，一次性可以推送很多标签，这将会把所有不在远程仓库服务器上的标签全部传送到那里。 12345678910$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 155 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:Alicesii/Git.git * [new tag] v1.1 -&gt; v1.1 * [new tag] v1.3 -&gt; v1.3 * [new tag] v1.3.1 -&gt; v1.3.1 * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4 -&gt; v1.5 这时，当其他人从仓库中克隆或拉取，它们也能得到你所设置的标签。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-4-Git基础","slug":"2-4-Git基础","date":"2018-08-04T16:10:35.000Z","updated":"2018-10-12T14:48:43.273Z","comments":true,"path":"2018/08/05/2-4-Git基础/","link":"","permalink":"http://yoursite.com/2018/08/05/2-4-Git基础/","excerpt":"","text":"4.撤销操作在任何一个阶段，你都有可能想要撤消某些操作，但是有些撤销操作是不可逆的。 有时我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。这时，可以运行带有--amend选项的提交命令尝试重新提交。 1$ git commit --amend 该命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改，那么快照会保持不变，而你所修改的只是提交信息。 举例：你提交后发现忘记了暂存某些需要的修改，这时，就可以运用该命令了。 123$ git commit -m &apos;initial commit&apos;$ git add forgotten_file.md$ git commit --amend 最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。 4.1.取消暂存的文件如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却输入了git add *同时暂存了它们两个。如何只取消暂存两个中的一个呢？ 12345678$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: one.html new file: two.html 上述代码已经提示的很清楚，使用&quot;git reset HEAD &lt;file&gt;...&quot;来取消暂存文件。 123456789101112$ git reset HEAD one.html$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: two.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) new file: one.html 我们可以看到one.html文件已经被修改为未暂存的状态。 4.2.撤销对文件的修改12345Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) new file: one.html 如何撤销对文件的修改，也就是将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子），我们还需要依照提示来做：使用&quot;git checkout -- &lt;file&gt;...&quot;来撤销对文件的修改。 12345678$ git checkout -- one.html$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: one.html new file: two.html 5.远程仓库的使用远程仓库是指托管在网络中的你的项目的版本库，你可以同时拥有多个远程仓库，通常有些仓库只读，有些既可以读也可以写。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 5.1.查看远程仓库git remote命令：列出你指定的每一个远程服务器的简写。 123456789101112131415$ git pull origin masterremote: Counting objects: 3, done.remote: Compressing objects: 100% (3/3), done.Unpacking objects: 100% (3/3), done.remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0From github.com:Alicesii/javascript-Object * branch master -&gt; FETCH_HEAD 6d95c79..d08bd5e master -&gt; origin/masterUpdating 6d95c79..d08bd5eFast-forward README.md | 59 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 1 file changed, 59 insertions(+) create mode 100644 README.md$ git remoteorigin origin是Git克隆的仓库服务器的默认名称。 指定选项-v，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。 123$ git remote -vorigin git@github.com:Alicesii/javascript-Object.git (fetch)origin git@github.com:Alicesii/javascript-Object.git (push) 多人合作完成的项目，肯定拥有多个远程仓库，该命令会将它们全部列出。 1234567891011$ git remote -vbakkdoor https://github.com/bakkdoor/grit (fetch)bakkdoor https://github.com/bakkdoor/grit (push)cho45 https://github.com/cho45/grit (fetch)cho45 https://github.com/cho45/grit (push)defunkt https://github.com/defunkt/grit (fetch)defunkt https://github.com/defunkt/grit (push)koke git://github.com/koke/grit.git (fetch)koke git://github.com/koke/grit.git (push)origin git@github.com:mojombo/grit.git (fetch)origin git@github.com:mojombo/grit.git (push) 5.2.添加远程仓库git remote add &lt;shortname&gt; &lt;url&gt;：添加一个新的远程Git仓库。 12345678$ git remoteorigin$ git remote add Ades https://github.com/Alicesii/blog$ git remote -vAdes https://github.com/Alicesii/blog (fetch)Ades https://github.com/Alicesii/blog (push)origin git@github.com:Alicesii/javascript-Object.git (fetch)origin git@github.com:Alicesii/javascript-Object.git (push) 可以在命令行中使用字符串Ades来代替整个URL。例如，如果你想拉取blog的仓库但是没有它的URL信息，就可以运行git pull Ades。 12345678$ git pull Adesremote: Counting objects: 119, done.remote: Compressing objects: 100% (113/113), done.Receiving objects: 7remote: Total 119 (delta 34), reused 72 (delta 6), pack-reused 0Receiving objects: 100% (119/119), 284.63 KiB | 164.00 KiB/s, done.Resolving deltas: 100% (34/34), done.From https://github.com/Alicesii/blog * [new branch] master -&gt; Ades/master 5.3.从远程仓库中抓取与拉取1$ git pull [remote-name] 该命令会访问远程仓库，从中拉取所有本地仓库中没有的数据。执行完成后，你将会拥有该远程仓库中所有分支的引用，可以随时合并或查看。 git pull命令会将数据拉取到你的本地仓库，它并不会自动合并或修改你当前的工作。 5.4.推送到远程仓库git push [remote-name] [branch-name]命令：将项目推送到远程服务器。 我们最常使用的是将master分支推送到origin服务器上。 1$ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到服务器然后你再推送，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 5.5.查看远程仓库git remote show [remote-name]命令：查看某一个远程仓库的更多信息。 1234567891011$ git remote show origin* remote origin Fetch URL: git@github.com:Alicesii/Git.git Push URL: git@github.com:Alicesii/Git.git HEAD branch: master Remote branch: master tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 该命令会列出远程仓库的URL与跟踪分支的信息。 5.6.远程仓库的移除与重命名git remote rename命令：重命名远程仓库的简写名称。 12345$ git remote add Ades https://github.com/Alicesii/blog$ git remote rename Ades Bdes$ git remoteBdesorigin git remote rm命令：移除一个远程仓库 123$ git remote rm Bdes$ git remoteorigin","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-3-Git基础","slug":"2-3-Git基础","date":"2018-08-04T07:35:02.000Z","updated":"2018-10-12T14:48:46.771Z","comments":true,"path":"2018/08/04/2-3-Git基础/","link":"","permalink":"http://yoursite.com/2018/08/04/2-3-Git基础/","excerpt":"","text":"3.查看提交历史git log命令用来查看某个项目的提交历史，我们可以查看提交了若干更新或者是克隆的某个项目提交历史记录。 12345678910111213141516171819202122232425$ git pull origin master$ git logcommit 011909b7b4e8942a5f18a7bb52a25dd63623c3aaAuthor: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Sun Jul 29 18:03:16 2018 +0800 blog-thirdcommit 2d428927038fc78846f7c4b21906bcede964226cAuthor: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Sun Jul 29 17:51:44 2018 +0800 README.mdcommit c96f1e2772d2c0a45734fa5f4ef68d1070812186Author: ying &lt;1511317497@qq.com&gt;Date: Tue Jul 17 11:20:25 2018 +0800 blog-secondcommit d585eaa4e1eac4a181c55acf5ce045d76c901cebAuthor: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Thu Jul 12 16:17:32 2018 +0800 Create README.md git log会按提交时间列出所有的更新，最近的更新排在最上面，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log命令有许多选项可以帮助你搜寻你所要找的提交。 -p按补丁格式显示每次提交的内容差异，可以加上数字(-2)它将限制输出长度，也就意味着仅显示最近两次的提交。 12345678910111213141516171819$ git log -p -2commit 011909b7b4e8942a5f18a7bb52a25dd63623c3aaAuthor: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Sun Jul 29 18:03:16 2018 +0800 blog-thirddiff --git &quot;a/README.md&quot; &quot;b/README.md&quot;index aae07c6..4bfc990 100644--- &quot;a/README.md&quot;+++ &quot;b/README.md&quot;@@ -165,7 +165,6 @@ A.prototype.name=&quot;张三&quot;; function B()&#123; &#125; B.prototype=new A();- var b=new B(); console.log(b.name); //张三 console.log(b.age); //undefined -p选项除了显示基本信息之外，还附带了每次commit的变化。 --stat显示每次更新的文件修改统计信息 123456789101112131415161718$ git log --statcommit 011909b7b4e8942a5f18a7bb52a25dd63623c3aaAuthor: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Sun Jul 29 18:03:16 2018 +0800 blog-third README.md | 1 - 1 file changed, 1 deletion(-)commit 575b0cc7ab8a6ce8b107ac0e4b5bc7636b7897c1Author: 255255255255 &lt;33173766+255255255255@users.noreply.github.com&gt;Date: Sun Jul 29 18:01:49 2018 +0800 blog-third &quot;README.md&quot; | 2 -- 1 file changed, 2 deletions(-) –stat选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 --shortstat：只显示--stat中最后的行数修改添加移除统计。 --name-only：仅在提交信息后显示已修改的文件清单。 --name-status：显示新增、修改、删除的文件清单。 --abbrev-commit：仅显示SHA-1的前几个字符，而非所有的40个字符。 --relative-date：使用较短的相对时间显示 --graph：显示ASCCII图形表示的分支合并历史。 --pretty：指定使用不同于默认格式的方式展示提交历史。可用的选项包括oneline，short，full，fuller 和format。 oneline表示将每个提交放在一行显示。 12345678$ git log --pretty=oneline011909b7b4e8942a5f18a7bb52a25dd63623c3aa blog-third2d428927038fc78846f7c4b21906bcede964226c README.md5f007ee5cf5fa337420265c713b5717c72763500 first-javascriptc96f1e2772d2c0a45734fa5f4ef68d1070812186 blog-secondd585eaa4e1eac4a181c55acf5ce045d76c901ceb Create README.mddceb7854ab9a316e3800046852f399dde075aaed Delete README.mdabd37e003368157d02f6f9e2e948ff72322c9890 blog-first format可以定制要显示的记录格式。 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用–date=选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 12345678$ git log --pretty=format:&quot;%h - %an,%ar : %s&quot;011909b - 255255255255,3 hours ago : blog-third2d42892 - 255255255255,3 hours ago : README.md5f007ee - ying,7 days ago : first-javascriptc96f1e2 - ying,12 days ago : blog-secondd585eaa - 255255255255,2 weeks ago : Create README.mddceb785 - 255255255255,2 weeks ago : Delete README.mdabd37e0 - ying,2 weeks ago : blog-first 注意：作者和提交者的差别 作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。假设当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们可以灵活的组合使用git log命令的这些选项。 123456789101112$ git log --pretty=format:&quot;%h %s&quot; --graph* 011909b blog-third* 575b0cc blog-third* 9dcb0d7 blog-third* 050b346 blog-third* 2d42892 README.md* 9e2b474 README.md* 5f007ee first-javascript* c96f1e2 blog-second* d585eaa Create README.md* dceb785 Delete README.md* abd37e0 blog-first 3.1.限制输出长度我们不仅可以定制输出格式的选项，还可以限制输出长度，也就是只输出部分提交信息。 -(n)仅显示最近的n条提交 1$ git log -p -2 n可以是任何整数，表示仅显示最近的若干条提交 –since, –after仅显示指定时间之后的提交。 123$ git log --since=2.weeks$ git log --since=&quot;2018-07-29&quot;$ git log --since= &quot;2 years 1 day 3 minutes ago&quot; –until, –before仅显示指定时间之前的提交。 –author 仅显示指定作者相关的提交。 –committer 仅显示指定提交者相关的提交。 –grep仅显示含指定关键字的提交 -S仅显示添加或移除了某个关键字的提交。例如，想找出添加或移除了某一个特定函数的引用的提交。 1$ git log -Sfunction_name 举例：要查看Git仓库中，2018年7月期间，作者ying提交的文件。 1234$ git log --pretty=format:&quot;%h - %s&quot; --author=ying --since=&quot;2018-07-01&quot; --before=&quot;2018-08-01&quot;7022a10 - second-Git9358d27 - first-Git","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-2-Git基础","slug":"2-2-Git基础","date":"2018-08-03T14:58:09.000Z","updated":"2018-10-12T14:48:48.517Z","comments":true,"path":"2018/08/03/2-2-Git基础/","link":"","permalink":"http://yoursite.com/2018/08/03/2-2-Git基础/","excerpt":"","text":"2.5.忽略文件一般我们总会有些文件无需放入Git管理，也不希望它们总出现在未跟踪文件列表，这时我们可以创建一个.gitignore的文件，列出要忽略的文件模式。 123touch .gitignore*.[oa]*~ 第一行告诉Git忽略所有以.o或.a结尾的文件 第二行告诉Git忽略所有以波浪符（~）结尾的文件 文件.gitignore的格式规范如下： 所有空行或者以＃开头的行都会被Git忽略。 可以使用标准的glob模式匹配(正则表达式)。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）。 参考链接：https://github.com/github/gitignore 2.6.查看已暂存和未暂存的修改假如我们再次修改README.md文件后暂存，然后编辑five.html文件后先不暂存，我们可以看下当前的状态： 123456789101112$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: five.html 如果你想知道具体修改了什么地方，git status命令的输出的结果太过模糊，我们可以使用git diff命令。通过该命令我们可以知道： 当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 1234567891011$ git diffdiff --git a/five.html b/five.htmlindex 59a5ccd..a4e2f77 100644--- a/five.html+++ b/five.html@@ -55,7 +55,6 @@&lt;h3&gt;效益&lt;/h3&gt;&lt;p&gt;为什么要参加？为了识别、灵感和资源，我们都可以向人们展示&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;requirements&quot; id=&quot;zen-requirements&quot; role=&quot;article&quot;&gt;&lt;h3&gt;要求&lt;/h3&gt;&lt;p&gt;在可能的情况下,实用的而不是2%的浏览公众最新的流血技巧。我们唯一的真正要求是您的验证&lt;/p&gt; git diff命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。 我们可以使用git diff --cached查看已暂存的将要添加到下次提交里的内容。 12345678910111213141516171819202122232425262728$ git diff --cacheddiff --git a/five.html b/five.htmlindex e231252..59a5ccd 100644--- a/five.html+++ b/five.html@@ -4,17 +4,14 @@&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;CSS禅意花园:CSS设计之美&lt;/title&gt;&lt;/head&gt;&lt;body id=&quot;css-zen-garden&quot;&gt;&lt;div class=&quot;page-wrapper&quot;&gt;&lt;section class=&quot;intro&quot; id=&quot;zen-intro&quot;&gt; &lt;header role=&quot;banner&quot;&gt; &lt;h1&gt;CSS Zen Garden&lt;/h1&gt;@@ -35,7 +32,6 @@&lt;p&gt;CSS禅园邀请你放松和沉思大师们的重要课程&lt;/p&gt;&lt;/div&gt;&lt;/section&gt;@@ -43,12 +39,10 @@&lt;div class=&quot;participation&quot; id=&quot;zen-participation&quot; role=&quot;article&quot;&gt;&lt;h3&gt;参与&lt;/h3&gt;&lt;p&gt;您可以按照您希望的任何方式修改样式表&lt;/p&gt;&lt;p&gt;下载示例和@@ -129,7 +123,6 @@ &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; 2.7.提交更新在提交之前，一定要确认还有没有什么修改过的或新建的文件还没有git add过，否则提交的时候不会记录这些还没暂存起来的变化。 1git commit git commit命令会启动文本编辑器以便输入本次提交的说明。 12345678910# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:# new file: README.md# modified: five.html#~~~ 我们可以看出，默认的提交消息包含最后一次运行git status的输出，全都放在注释行中。 我们大多数的用法是在commit命令后面添加-m选项，将提交信息与命令放在同一行。 12345$ git commit -m &apos;first-commit&apos;[master 4f38a76] first-commit 3 files changed, 3 insertions(+), 10 deletions(-) create mode 100644 README.md create mode 100644 five.html 至此，我们已经完成了第一个提交，提交之后会显示当前在哪个分支提交的，本次提交的完整SHA-1校验和是4f38a76，以及在本次提交中，有多少文件修订过，多少行添加和修改过。 2.8.跳过使用暂存区域我们可以将git add和git commit命令的功能合并成为一个命令，那就是git commit -a。 该命令就是跳过使用暂存区域，也就是说Git会自动把所有已跟踪过的文件暂存起来一并提交。这个基本不太使用，大家了解一下就好。 2.9.移除文件git rm命令:从已跟踪文件清单中移除某个文件，更明确地说是从暂存区域移除，也就是说从暂存区域并连带从工作目录中删除指定文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是从工作目录删除文件，运行git status时所删除的文件就会在&quot;Changes not staged for commit&quot;部分(未暂存清单)中看到： 12345678$ rm README.md$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: README.md 我们可以使用git rm命令删除文件看下与普通的删除文件的区别： 123456$ git rm README.mdrm README.mdOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: README.md 从暂存区域并连带从工作目录中删除了README.md文件，也就意味着该文件就不在纳入版本管理了。 如果我们想把文件从Git仓库中删除(从暂存区域移除)，但仍然希望保留在当前工作目录中。也就是说，想让文件保留在磁盘，但是并不想让Git继续跟踪(.gitignore文件的作用)。可以在上添加git rm命令上添加--cached选项： 1$ git rm --cached README.md","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-1-Git基础","slug":"2-1-Git基础","date":"2018-08-02T02:16:20.000Z","updated":"2018-10-12T14:48:49.896Z","comments":true,"path":"2018/08/02/2-1-Git基础/","link":"","permalink":"http://yoursite.com/2018/08/02/2-1-Git基础/","excerpt":"","text":"1.获取Git仓库有两种方法可以获取到Git项目仓库。第一种是在现有项目下导入所有文件到Git；第二种是从一个服务器克隆一个现有的Git仓库。 1.1.在现有目录中初始化仓库在现有目录点击右键，就可以看到Git Bash的快捷键方式， git init命令将创建一个.git的子目录，这个子目录含有初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果是在一个已经存在文件的文件夹中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。可以通过git add命令来实现对文件的跟踪，然后执行git commit提交。 123git add *git commit -m &quot;first-commit&quot; 现在，已经得到了一个实际维护(或者说是跟踪)着若干个文件的Git仓库。 1.2.克隆现有的仓库git clone命令：获取一份已经存在了的Git仓库的拷贝。 Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行git clone命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。 12345git clone [url]git clone https://github.com/Alicesii/blog或git clone https://github.com/Alicesii/blog myblog //自定义本地仓库的名字myblog 在该目录下初始化一个.git文件夹，从远程仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。 Git支持多种数据传输协议，可以使用的是https://协议，也可以使用git://协议或者使用SSH传输协议。 2.记录每次更新到仓库假如我们有一个项目的Git仓库，并从这个仓库中取出所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。 工作目录下的每一个文件都只存在着这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 编辑过某些文件之后，由于自上次提交后对它们做了修改，Git将它们标记为已修改文件。我们可以将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。使用Git时文件的生命周期如下： 文件的状态变化周期 2.1.检查当前文件状态查看文件处于哪些状态，使用git status命令。 如果在克隆仓库后立即执行此命令，会是这样的输出： 123$ git statusOn branch masternothing added to commit, working directory clean 说明现在的工作目录十分干净。也就是说，所有已跟踪文件在上次提交后都未被更改过。并且当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。该命令还显示了当前所在分支，并且告诉你这个分支同远程服务器上对应的分支没有偏离。 我们可以在项目下创建一个README.MD的文件，如果之前不存在这个文件，使用git status命令，将看到一个新的未跟踪文件。 1234567$ echo &apos;css garden&apos; &gt;README.md$ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) README.md 在状态报告中可以看到新建的README.MD文件出现在Untracked files下。未跟踪的文件意味着Git在之前的快照(提交)没有这些文件，Git不会自动将之纳入跟踪范围。 2.2.跟踪新文件开始跟踪一个文件，使用git add命令。 1234567$ git add README.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README.md READMD文件文件已被跟踪，并处于暂存状态。 在Changes to be committed下的所有文件都是已暂存状态，如果此时提交，那么该文件此时此刻的版本江北存留在历史记录中。 2.3.暂存已修改文件修改一个已被跟踪的文件，然后运行git status命令， 123456$ git statusChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: five.html 文件five.html出现在Changes not staged for commit下，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，又需要使用git add命令。 git add命令有多种作用： 跟踪新文件 把已跟踪的文件放到暂存区 合并时把有冲突的文件标记为以解决状态 “添加内容到下一次提交中”而不是”将一个文件添加到项目中” 12345678$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README.md modified: five.html 两个文件都已暂存，下次提交时就会一并记录到仓库。 如果需要在修改five.html文件，我们可以再看一下暂存区的状态： 12345678910111213$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README.md modified: five.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: five.html 我们可以发现five.html文件同时出现在暂存区和非暂存区，这种情况是不可能发生的，实际上Git只暂存了你运行git add命令时的那个版本，如果你现在提交，five.html的版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit时，在工作目录中的当前版本。因此，运行了git add之后又作了修订的文件，需要重新运行git add把最新版本重新暂存起来。 12345678$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README.md modified: five.html 2.4.状态简览git status命令的输出十分详细，但又有些繁琐，可以使用git status -s命令，得到一种更为紧凑的格式输出。 12345$ git status -s M README.mdMM five.htmlA five.txt?? .project 新添加的未跟踪文件前面有??标记，新添加到暂存区中的文件前面有A标记，修改过的文件前面有M标记。你可能注意到了M有两个可以出现的位置，出现在右边的 M表示该文文件被修改了但是还没放入暂存区，出现在靠左边的M表示该文件被修改了并放入了暂存区。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"认识Git","slug":"1-认识Git","date":"2018-07-31T23:40:29.000Z","updated":"2018-10-12T14:48:51.169Z","comments":true,"path":"2018/08/01/1-认识Git/","link":"","permalink":"http://yoursite.com/2018/08/01/1-认识Git/","excerpt":"","text":"1.认识GitGit是什么？用来做什么? Git用来进行版本控制…… 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。就好像在PS中修改图片时，你会建立多个图层。你可以很方便的找到任何一个图层。 本地版本控制系统 采用某种简单的数据库来记录文件的历次更新差异。 集中式版本控制系统 在实际的开发中，一个项目通常是由多人协作共同完成的，如何让在不同系统上的开发者协同工作成了亟待解决的问题，集中式版本控制系统便应运而生了。它通过单一的集中管理的服务器，保存所有文件的修订版本，协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。 这种方式很好解决了多人协同开发的问题，但是也存在着很大的弊端，若中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统(Git是典型的分布式管理系统) 在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，还需要一台共享服务器，所有开发者通过这台共享服务器提交和更新数据。 2.了解Git2.1.直接记录快照，而非差异Git和其他版本控制系统的主要差别在于Git对待数据的方法，其他大部分系统以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异。 存储每个文件与初始版本的差异 Git把数据看作是对小型文件系统的一组快照，每次提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引，为了提高效率，如果文件没有修改，Git不再重复存储该文件，而是只保留一个链接指向之前存储的文件，Git对待数据更像是一个快照流 存储项目随时间改变的快照 这是Git与其他版本控制系统的重要区别，Git重新考虑了以前每一代版本控制系统延续下来的诸多方面。Git更像是一个小型文件系统，提供了许多以此为基础构建的工具，而不是一个简单的VCS(版本控制系统)。 2.2.近乎所有操作都是本地在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。 举例：要浏览项目的历史，Git不需要外连服务器去获取历史，然后再显示出来，它只需要从本地数据库中读取，就可以看到项目历史。如果你想查看当前版本与一个月前的版本之间的修改，Git会查找到一个月前的文件做一次本地的差异比较，而不是由远程服务器处理或从远程服务器拉回旧版本文件在做来本地处理，这也意味着你离线或者没有VPN时，几乎可以做任何操作。 2.3.Git保证完整性Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。如果在传送过程中丢失信息或损坏文件，Git就能发现。 Git用以计算校验和的机制叫做SHA-1散列(哈希)。这是一个由40个十六进制字符(0-9和a-f)组成字符串，基于Git中文件的内容或目录结构计算出来的。SHA-1哈希看起来是这样的： e65b40b8c5f3d8d69fcf7fe546c43a0d48df2c1d Git数据库中保存的信息都是以文件内容哈希值来索引，而不是文件名。 2.4.Git一般只添加数据所执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS(版本控制系统)一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 2.5.三种状态Git有三种状态，你的文件可能处于其中之一：已提交、已修改、已暂存。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 Git 项目的三个工作区域的概念：Git仓库、工作目录以及暂存区域 Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作&quot;索引&quot;，不过一般说法还是叫暂存区域。 基本的Git工作流程如下： 1、在工作目录中修改文件。 2、暂存文件，将文件的快照放入暂存区域。 3、提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 2.6.命令行Git有多种使用方式。你可以使用原生的命令行模式也可以使用GUI模式，这些GUI软件也能提供多种功能，但是只有在命令行模式下你才能执行Git的所有命令。 3.初次运行Git前的配置3.1.用户信息安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。这样做是非常有必要的，因为每一个Git的提交都会使用这些信息并且它会写入到你的每一次提交中不可更改： 123$ git config --global user.name &quot;Yang Ying&quot;$ git config --global user.email 17868812265@163.com 如果使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有--global选项的命令来配置。 123$ git config user.name &quot;Yang Ying&quot;$ git config user.email 17868812265@163.com 3.2.文本编辑器Git操作系统默认的文本编辑器是Vim。 3.3.检查配置信息使用git config --list命令可以列出所有Git当时能找到的配置。 123456789101112131415161718192021222324252627282930$ git config --listcore.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlhttp.sslcainfo=F:/Git/mingw64/ssl/certs/ca-bundle.crtdiff.astextplain.textconv=astextplainrebase.autosquash=truefilter.lfs.required=truefilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processuser.name=yinguser.email=1511317497@qq.comuser.password=123456credential.helper=storecore.autocrlf=falsecore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=truecore.hidedotfiles=dotGitOnlyremote.origin.url=git@github.com:255255255255/CSSGarden.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/* 通过输入git config &lt;key&gt;:来检查Git的某一项配置 123$ git config user.nameying 3.4.获取帮助1git help config Git中几乎所有命令都是在本地执行，不需要请求服务器端的信息。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"HTML5新增APT","slug":"HTML5新增API","date":"2018-07-27T02:47:01.000Z","updated":"2018-10-12T14:47:23.807Z","comments":true,"path":"2018/07/27/HTML5新增API/","link":"","permalink":"http://yoursite.com/2018/07/27/HTML5新增API/","excerpt":"","text":"优点： 极简的DOM操作 本地数据缓存：不管是取数据，还是存数据、还是删除数据也好都十分的简单，只需要调用相对应的方法即可。 提升了浏览器的存储性能 通常来讲，再更老版本的浏览器，如果用户想要给本地写数据是非常困难的，可以通过cookie来操作，相对比localStorage来说，cookie的用法看起来就太繁琐了。 跟硬件相关的特性 可以通过Google的服务获取我们当前设备所在的地理位置 可以获得从打开页面开始那一刻页面性能的监控：window.performance.timing,后面我们在具体讲解。 HTML5 API更好的完成性能上的提升 Web worker异步请求、离线缓存、应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 1.DOM操作使用原生JavaScript获得DOM节点对象的时候有以下几种方式： 12345document.getElementById(\"#elementId\");document.getElementsByName(\"elementName\");document.getElementsByTagName(\"tagName\"); 我们虽然可以使用上面的几种方式方便获得元素，但也存在着很大的缺点，比如根据Class来获取元素，如果有需要，我们要么自己写getElementsByClassName()方法，要么使用其他的JS类库，使用类库也存在着问题：一是加载类库会影响网站性能，二是还必须学习类库的相关知识。现在HTML5给我们提供了一些API，可以很方便的解决这个问题。 1.1.document.querySelector(&quot;selector&quot;) 根据css选择器返回第一个匹配的元素，如果没有匹配返回null； 浏览器支持: Chrome 4.0+, FireFox 3.5+, Safari 3.2+, Opera 10.1+, IE 8+ 举例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var selector = document.querySelector('li'); console.log(selector.innerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; querySelector也支持多个选择器 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"header\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var selector = document.querySelector('.header li'); console.log(selector.innerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以看到querySelector非常的方便，类似jquery的选择器，也不存在兼容性问题。 1.2.document.querySelectorAll(&quot;selector&quot;); querySelectorAll和querySelector作用一样的，只是querySelectorAll返回的是元素数组，querySelector返回的是一个元素。如果querySelectorAll没有匹配的内容返回的是一个空数组。 浏览器支持： Chrome 4.0+, FireFox 3.5+, Safari 3.2+, Opera 10.1+, IE 8+ 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"header\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var selector = document.querySelectorAll('.header li'); console.log(console.log(selector);); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.3.document.getElementsByClassName(&quot;selector&quot;) getElementsByClassName是一个类选择器，返回值是一个元素数组。 浏览器支持： Chrome 4.0+, FireFox 3.5+, Safari 3.2+, Opera 10.1+, IE 8+ 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"header\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var selector = document.getElementsByClassName('header'); console.log(selector[0].innerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.classList属性classList属性没有出现之前JavaScript操作class类选择器使用的是className()，可以看下DOM对象的添加样式、删除样式、切换样式。 1234567891011121314151617181920212223242526272829303132333435//javascript只能用className()这样一个方法来判断存不存在样式、添加样式、删除样式、切换样式。```javascriptwindow.onload=function()&#123;//判断有没有样式function hasClass(obj,cls)&#123; return obj.className.match(new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'));&#125;//添加样式function addClass(obj,cls)&#123; if(!hasClass(obj,cls))&#123; obj.className+=\" \"+cls &#125;&#125;//删除样式function removeClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; var reg=new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'); obj.className=obj.className.replace(reg,' '); &#125;&#125;//切换样式function toggleClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; removeClass(obj,cls); &#125;else&#123; addClass(obj,cls); &#125; &#125;&#125; 2.1.classList属性classList是HTML5新的属性，只不过现在浏览器支持的不是很好,我们使用caniuse网站检测一下： 中文： 英文： 判断是否是IE11+以及其他现代浏览器: document.body.classList是否为undefined 我们把上面的实例修改为classlist来操作： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"class1 class2 class3 \"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.getElementsByTagName(\"ul\")[0]; console.log(ul.classList); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面是Chorme浏览器下面打印的结果： 可见其直接暴露的API有： length属性，表示元素类名的个数，只读 item()支持一个参数，为类名的索引，返回对应的类名，例如上例： 123ul.classList.item(0);//结果是：\"class1\". 如果索引超出范围，例如： 123ul.classList.item(3);结果是：null. add()：支持一个类名字符串参数。表示往类名列表中新增一个类名；如果之前类名存在，则添加忽略。例如： 123ul.classList.add(\"class1\");ul.classList.length ; // 3 add()方法执行的返回值是undefined 因此，classList的add()方法是无法级联的，remove()方法也是无法级联的。 remove()：支持一个类名字符串参数。表示往类名列表中移除该类名。例如： 123ul.classList.remove(\"class1\");ul.classList.length // 2 类似于jQuery对象中的removeClass()方法，然后者返回包装器对象本身，removeClass()方法可级联； remove()方法返回undefined，索引remove()方法是无法级联的。 toggle()：支持一个类名字符串参数。无则加勉，有则移除之意。若类名列表中有此类名，移除之，并返回false; 如果没有，则添加该类名，并返回true. contains()：支持一个类名字符串参数。表示往类名列表中是否包含该类名。有点对应jQuery中的hasClass方法。如果包含，则返回true, 不包含，则false。 举例： ul.classList.contains(&quot;class1&quot;); // false 因为&quot;class1&quot;上面remove掉了 3.全屏为了方便用户的阅读或者观看视频，很多的网站实现了全屏功能。FullScreen API 是一个新的JavaScript API,简单而又强大.FullScreen 让我们可以通过编程的方式来向用户请求全屏显示,如果交互完成,随时可以退出全屏状态. FullScreen是HTML5的一个新特征，现在主流的浏览器已经支持,我们可以使用caniuse网站再检测一下： 中文： 英文： 3.1.FullScreen API接口属性： fullscreenElement：该属性返回当前处于全屏模式的DOM元素。 fullscreenEnabled：该属性返回当前document是否进入了可以请求全屏模式的状态。 方法： requestFullscreen()：请求进入全屏模式。 exitFullscreen()：退出全屏模式。 事件： fullscreenchange：进入/退出全屏模式切换时会触发。 fullscreenerror：进入/退出全屏模式失败时会触发。 由于各个浏览器对FullScreen接口实现的方式不一样，主要是因为浏览器内核的差别，所以在使用的时候要考虑浏览器的兼容性。 3.1.进入全屏12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\" onclick=\"launchFullScreen()\"&gt;我是全屏&lt;/button&gt; &lt;script&gt; // 找到支持的方法, 使用需要全屏的 element 调用 function launchFullScreen(element) &#123; var element = element || document.documentElement; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 有的浏览器在进入全屏的时候会提示用户是否进行全屏，如果用户取消则全屏失效。同意浏览器的工具栏以及浏览器其它的组件都会隐藏起来，使document的高和宽横跨整个屏幕。 一般浏览器在进入全屏的时候提供用户按esc键可以退出全屏，即使这样有的时候我们还是需要给用户提供退出全屏的操作。 3.2.退出全屏123456789101112 &lt;script&gt; // 退出 fullscreen function exitFullscreen() &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozExitFullScreen) &#123; document.mozExitFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125;&lt;/script&gt; 退出全屏的代码很简单，我们只需要考虑浏览器的前缀就可以了。 注意: exitFullscreen只能通过document对象调用,而不是使用普通的DOM element. 3.3.检查全屏状态变化有的时候为了用户友好体验，在进入全屏或者退出全屏的时候，需要给用户提示，这个时候我们可以使用FullScreen的screenchang事件进行监控。 1234567891011&lt;script&gt; document.addEventListener(\"fullscreenchange\", function() &#123; fullscreenState.innerHTML = (document.fullscreen) ? \"\" : \"not \"; &#125;, false); document.addEventListener(\"mozfullscreenchange\", function() &#123; fullscreenState.innerHTML = (document.mozFullScreen) ? \"\" : \"not \"; &#125;, false); document.addEventListener(\"webkitfullscreenchange\", function() &#123; fullscreenState.innerHTML = (document.webkitIsFullScreen) ? \"\" : \"not \"; &#125;, false);&lt;/script&gt; 3.4.css的全屏样式Styling fullscreen在css中，我们有几个伪类来给全屏设置样式,一般是full-screen这个伪类，然后会自动再全屏的时候生效 12345678910111213&lt;style&gt; html:-moz-full-screen &#123; background: red; &#125; html:-webkit-full-screen &#123; background: red; &#125; html:fullscreen &#123; background: red; &#125;&lt;/style&gt; 全屏状态下的键盘输入 Full screen with key input 为了安全原因，很多情况下全屏输入都是被阻塞禁止的，但是chrome允许通过下面的API来允许键盘输入： docElm.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT); 这个只在chrome支持，其他浏览器不支持。firefox计划使用requestFullscreenWithKeys方法来支持鼠标输入，但是会触发用户通知已保证安全，firefox10以上，chrome 15和safari5.1以上都支持了。 4.页面可见性(Page Visibility)页面可见性就是当前页面是处于显示状态还是隐藏状态，页面可见性对于网站的统计非常有用。有的时候我们会统计用户停留在每个页面的时间，这个时间就是：用户打开网页到网页关闭或者最小化之间的时间。 有的时候在视频播放的时候，当用户离开视频播放页面自动暂停视频播放，我们有时候也对那些定期刷新内容的页面进行控制，当该页面不可见则不刷新，可见则刷新。这些都是页面可见性的具体应用。 HTML5之前，我们可以监听 onfocus()事件。如果当前窗口得到焦点，那么我们可以简单认为用户在与该页面交互，如果失去焦点onblur()那么可以认为用户停止与该页面交互。 12345678910// 当前窗口得到焦点window.onfocus = function() &#123; // 动画 // ajax 轮询等等&#125;; // 当前窗口失去焦点 window.onblur = function() &#123; // 停止动画 // 停止 ajax 轮询等等&#125;; 通过焦点来判断页面的可见性是非常不精确的，因为如果用户打开了网页，同时进行word内容的编辑，这个时候焦点在word编辑器里面，但是页面仍然可见。 4.1.可见性API和事件首先，我们来看一下可见性的兼容性 哈哈哈，只有Opera mini的浏览器都支持这个API，其他的浏览器都支持，这个可是非常不容易的。 可见性的属性： document.hidden：Boolean值，表示当前页面可见还是不可见 document.visibilityState：返回当前页面的可见状态： visible：页面内容至少部分可见.意味着该页面是一个非最小化窗口的前台标签页. hidden：页面内容用户不可见.意味着当前浏览器窗口处于最小化模式,或者该页面是一个后台标签页. prerender：页面内容正在被预渲染,用户不可见(这种情况下document.hidden会返回true). 一个页面只有在初始化时可能为这个值, 一旦变为其他两种值,不可能再变回来. unloaded：当前文档已经被卸载,用户不可见(这种情况下document.hidden会返回true). 可见性的事件： visibilitychange: 当可见状态改变时候触发的事件。 4.2.可见性的使用简单实例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.addEventListener('visibilitychange', function() &#123; var isHidden = document.hidden; if(isHidden) &#123; console.log('页面隐藏') &#125; else &#123; console.log('页面显示'); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上述实例没有考虑浏览器的兼容性问题，我们就简单的测试一下，通过不停地切换其他页面与该页面，便可以触发该事件。 通过结果可以看到监听到了页面可见性的变化。 4.3.兼容浏览器的写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"class1 class2 class3 \"&gt; &lt;li onclick=\"launchFullScreen()\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; function supportPageVisibility() &#123; var hidden = \"hidden\", visibilityChange = \"visibilitychange\"; if(typeof document.hidden !== \"undefined\") &#123; hidden = \"hidden\"; visibilityChange = \"visibilitychange\"; state = \"visibilityState\"; &#125; else if(typeof document.mozHidden !== \"undefined\") &#123; hidden = \"mozHidden\"; visibilityChange = \"mozvisibilitychange\"; state = \"mozVisibilityState\"; &#125; else if(typeof document.msHidden !== \"undefined\") &#123; hidden = \"msHidden\"; visibilityChange = \"msvisibilitychange\"; state = \"msVisibilityState\"; &#125; else if(typeof document.webkitHidden !== \"undefined\") &#123; hidden = \"webkitHidden\"; visibilityChange = \"webkitvisibilitychange\"; state = \"webkitVisibilityState\"; &#125; // 添加一个标题改变的监听器 document.addEventListener(visibilityChange, function(e) &#123; if(document[hidden]) &#123; console.log('页面隐藏') &#125; else &#123; console.log('页面显示'); &#125; &#125;, false); &#125; supportPageVisibility(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.预加载网站优化一直是项目开发中的重点之中，常用的优化方式主要有：图片懒加载、图片sprite、css合并、js合并、数据本地存储、数据网络缓存等。这些都是项目中经常使用的，HTML5考虑到了这一点，提出了链接预加载的方法，其实，这个方案是FireFox提出的，所以它对链接预加载绝对的支持。 预加载是一种浏览器机制，使用浏览器空闲时间来预先下载\\加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。 浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现，说的直接一些就是让浏览器在后台提前下载一些文件。 5.1.link的prefetch属性1234 &lt;!-- 页面，可以使用绝对或者相对路径 --&gt;&lt;link rel=\"prefetch\" href=\"page2.html\" /&gt; &lt;!-- 图片，也可以是其他类型的文件 --&gt; &lt;link rel=\"prefetch\" href=\"sprite.png\" /&gt; 上面是预加载的使用方案，href就是预加载的文件，可以看到可以加载不通类型的文件。但是由于prefetch兼容性现在使用不是特别的多，我们来看一下兼容图： 可以看到兼容效果不是特别的好。考虑到prefetech的兼容，w3c提出了另外一个属性dns-prefetch属性。它的兼容性现在主流浏览器基本都支持。 通过上图可以看到dns-prefetch的兼容性比prefetch好很多。 5.2.link的dns-prefetch 可以看到使用方法和prefetch一样，只是rel的属性不一样。 5.3.注意事项 预加载可以跨域进行，当然，请求时cookie等信息也会被发送。 预加载可能破坏网站统计数据，而用户并没有实际访问。 浏览器兼容性不是很好 6. 页面监控(window.performance.timing)百度的页面监控截图，在控制台输入window.performance.timing就可以看到。 6.1.各字段的含义： navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 unloadEventEnd：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 redirectStart：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。 requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。 responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。 responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 这些时间戳是告诉你这个网页从连接服务器开始，到连接服务器结束，到内容下载，到页面渲染，还有包括DNS，以及关闭浏览器时，卸载时所花费的时间. 6.2.如何分析页面整体加载速度主要是查看指标值PAGET_页面加载时间,此指标指的是页面整体加载时间但不含(onload事件和redirect),此指标值可直接反应用户体验,从此项指标可以知道指定某时间段的页面加载速度值,以及和天,周,月的对比状况. 也可以查询指标ALLT_页面完全加载时间, 可以查询到从浏览器开始导航(用户点击链接或在地址栏输入url或点刷新,后退按钮)到页面onload 事件js完全跑完的所有时间.如果发现页面加载速度有增加或减少,则可以分项查询前面表格中的每个指标值,总的来说他们的关系如下: dom开始加载前所有花费时间=重定向时间+域名解析时间+建立连接花费时间+请求花费时间+接收数据花费时间 pageLoadTime页面加载时间=域名解析时间+建立连接花费时间+请求花费时间+接收数据花费时间+解析dom花费时间+加载dom花费时间 allLoadTime页面完全加载时间=重定向时间+域名解析时间+建立连接花费时间+请求花费时间+接收数据花费时间+解析dom花费时间+加载dom花费时间+执行onload事件花费时间 resourcesLoadedTime资源加载时间=解析dom花费时间+加载dom花费时间 6.3.不支持HTML5元素的浏览器可以利用getTime()获取当前的时间戳，完成某个功能之后再获取一个时间戳，两个时间戳相减就是完成这个功能所花费的时间。 不支持的浏览器只能通过这种办法粗略的计算该方法所花费的事件，其他的性能指标无法获得。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"雅虎35条","slug":"前端性能优化","date":"2018-07-22T08:18:08.000Z","updated":"2018-10-12T14:46:35.525Z","comments":true,"path":"2018/07/22/前端性能优化/","link":"","permalink":"http://yoursite.com/2018/07/22/前端性能优化/","excerpt":"","text":"内容方面 [内容]尽量减少HTTP请求数 [内容]避免重定向 [内容]减少DNS查找 [内容]延迟加载组件 [内容]预加载组件 [内容]减少DOM元素的数量 [内容]跨域分离组件 [内容]尽量少用iframe [内容]杜绝404 [内容]让Ajax可缓存 服务器方面 [服务器]使用CDN（Content Delivery Network） [服务器]添上Expires或者Cache-Control HTTP头 [服务器]Gzip组件 [服务器]尽早清空缓冲区 [服务器]对Ajax用GET请求 [服务器]配置ETags [服务器]避免图片src属性为空 CSS方面 [css]把样式表放在顶部 [css]避免使用CSS表达式 [css]选择 舍弃@import [css]避免使用滤镜 JavaScript方面 [js]把脚本放在底部 [js]尽量减少DOM访问 [js]用智能的事件处理器 [js]去除重复脚本 css和JavaScript方面 [js, css]把JavaScript和CSS放到外面 [js, css]压缩JavaScript和CSS 图片方面 [图片]优化图片 [图片]优化CSS Sprite [图片]不要用HTML缩放图片 [图片]用小的可缓存的favicon.ico（P.S. 收藏夹图标） 移动端方面 [移动端]保证所有组件都小于25K [移动端]把组件打包到一个复合文档里 Cookie方面 [cookie]给Cookie减肥 [cookie]把组件放在不含cookie的域下 详细解释： 内容1.尽量减少HTTP请求数80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。 减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。 合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。 CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的 background-image和 background-position属性来定位要显示的部分。 图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片地图只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。 行内图片（Base64编码）用 data: URL模式 来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。 减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。就像Tenni Theurer的博客 Browser Cache Usage – Exposed! 里写到的,40%到60%的访客在访问你的站点时，缓存都是空的。所以，加快页面首次访问速度对提高用户体验是极其重要的。 2.避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头： 1234HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 浏览器会自动跳转到 Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如 Expires和Cache-Control 也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。 有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到 http://astrology.yahoo.com/astrology会返回一个重定向到 http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用 Alias ， mod_rewrite或者 DirectorySlash指令来取消不必要的重定向。 重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用 Alias和 mod_rewrite ，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合 Alias或者 mod_rewrite指令。 3.减少DNS查找域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。 IE默认缓存DNS查找30分钟，写在 DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用 network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件) 如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 4.延迟加载组件可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。 JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。 工具可帮你减轻工作量： YUI Image Loader可以延迟加载折叠的图片，还有 YUI Get utility是一种引入JS和CSS的简单方法。 Yahoo!主页 就是一个例子，可以打开Firebug的网络面板仔细看看。 最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。 5.预加载组件预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。 实际应用中有以下几种预加载的类型： 无条件 预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。 条件性 预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在 search.yahoo.com 的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。 提前 预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。 6.减少DOM元素的数量一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。 大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的 &lt;div&gt;或许应该用更好的语义化标记。 YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用 &lt;div&gt; ，而不是因为它能够渲染一个新行。 DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：document.getElementsByTagName(&#39;*&#39;).length那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如 Yahoo!主页 是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。 7.跨域分离组件分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在 www.example.org，而把静态组件分离到 static1.example.org和 static2.example.org。 8.尽量少用iframe用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 &lt;iframe&gt;的优点： 引入缓慢的第三方内容，比如标志和广告 安全沙箱 并行下载脚本 &lt;iframe&gt;的缺点： 代价高昂，即使是空白的iframe 阻塞页面加载 非语义 9.杜绝404HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。 10.让Ajax可缓存Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。 要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则： Gzip组件 减少DNS查找 压缩JavaScript 避免重定向 配置ETags 我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612 。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。 即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。 服务器1.使用CDN（Content Delivery Network）用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是 业绩黄金法则 。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 一些互联网公司巨头拥有他们自己的CDN，但用一个CDN服务提供者是比较划算的，比如 Akamai Technologies ， EdgeCast ，或者 level3 。对刚刚起步的公司和个人网站来说，CDN服务的成本是很高的，但如果你的用户群却越来越大，越来越全球化，那么用CDN来换取更快的响应时间还是很有必要的。在Yahoo!，把静态内容从应用程序的web服务器搬到CDN(包括上面提到的3rd party和Yahoo自己的 CDN )能够提高终端用户20%甚至更多的响应时间。换到CDN是一个相当简单的代码变更，但这将急剧提升站点的响应速度。 2.添上Expires或者Cache-Control HTTP头这条规则有两个方面： 对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效 多余动态组件：用合适的 Cache-Control HTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在 所有 组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。 Expires: Thu, 15 Apr 2010 20:00:00 GMT：如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期： ExpiresDefault &quot;access plus 10 years&quot; 记住，如果你用一个遥远的未来时间做有效期，就不得不在组件发生变化后及时修改组件的文件名。在Yahoo!，我们经常把这一步作为构建过程的一部分：把版本号内嵌在组件的文件名里，例如：yahoo_2.0.6.js 用一个遥远的未来时间做有效期HTTP头，只有在用户已经访问过站点之后才会影响页面视图。如果是新访客或者浏览器的缓存被清空时，对HTTP请求的数量并没有影响。因此这种性能提升取决于已缓存各个组件的用户访问站点的频率。我们 在Yahoo!测量了这个数据 ，发现已缓存各个组件的页面访问量（PV）占75%到85%。通过把一个遥远的未来时间作为有效期HTTP头，增加了被浏览器缓存的组件数量，在后续页面访问量中不需要用Internet连接多发送哪怕一个字节。 3.Gzip组件前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 Accept-Encoding: gzip, deflate：如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 Content-Encoding: gzip：Gzip是目前最常见的高效压缩方法，由GNU项目开发并被 RFC 1952 标准化。唯一一个你可能会看到的其它压缩格式是deflate，但它效率不高而且并不常见。 Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。如果是Apache服务器，配置gzip的模块取决于版本：Apache 1.3用 mod_gzip而Apache 2.x是mod_deflate模块。 浏览器和代理的某些因素可能会引起浏览器所期望的和它收到的压缩内容不匹配。幸运的是，随着老旧浏览器的淘汰，这些极少遇到的情况正在逐渐减少，而且Apache模块可以通过自动添加合适的Vary响应头来帮你搞定。 服务器会根据文件类型来决定要不要用gzip压缩，但这非常有限。大多数网站都用gzip压缩HTML文件，其实压缩脚本，样式表也是不错的选择，但很多网站却错失了这个机会。其实，可以压缩任何文本内容，包括XML和JSON，而图片和PDF不用压缩，因为它们已经被压缩过了，再用gzip压缩不仅浪费CPU还可能会越压越大。 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 4.尽早清空缓冲区当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个 flush() 函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。 比较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。 例如： 12345&lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; &lt;!-- content --&gt; Yahoo!搜索 开创了这项技术，而且真实用户测试研究也证明了使用这种技术的诸多好处。 5.对Ajax用GET请求Yahoo!邮箱 团队发现使用 XMLHttpRequest 时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如 HTTP说明文档 中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 6.配置ETags实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的 ETag 来指定组件的ETag： 1234HTTP/1.1 200 OK Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT ETag: &quot;10c24bc-4ab-457e1c1f&quot; Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用 If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。 12345GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot; HTTP/1.1 304 Not Modified ETags存在的问题是它们是由特定服务器构造的，所以如果浏览器从一个服务器获取最初的组件，然后想验证另一个服务器上的相同组件，ETags是无法匹配成功的，而用一群服务器处理请求在web站点中又非常普遍。默认情况下，Apache和IIS会在ETag中嵌入数据，以大大降低在多服务器站点上有效性测试成功的几率。 Apache 1.3和2.x中ETag的格式是 inode-size-timestamp 。就算给定的文件可能在多个服务器的相同目录下，而且文件大小、访问权限、时间戳等等全部相同，它的i节点（P.S. inode，UNIX中的索引文件）在不同服务器中也不一样。 IIS5.0和6.0也都存在类似的问题。IIS中ETags的格式是 Filetimestamp:ChangeNumber ， ChangeNumber是一个用来追踪IIS配置变更的计数器。 一个站点在不同的IIS服务器上的 ChangeNumber 是不可能相同的。 最终结果是Apache和IIS为完全相同的组件生成的ETags无法跨浏览器匹配，如果ETags不匹配，用户就无法收到为又小又快的304响应设计的ETags。反而，他们将收到一个携带着组件所有数据的200正常响应。如果站点部署在单一服务器上，就根本不存在这个问题。但如果站点部署在多个服务器上，而且打算用Apache或者IIS的默认ETags配置，用户将看到缓慢的页面，服务器负载更高，还会消耗更大的带宽，并且代理也无法有效缓存页面内容。即使组件有“永久” Expires HTTP头，用户点击重新加载或者刷新的时候，仍然会发出条件GET请求。 如果不想用ETags提供的灵活的验证模型，最好把所有的Etag全都去掉，可以用基于组件的时间戳的 Last-Modified HTTP头验证，而且去掉ETag可以减少HTTP响应头以及后续请求的大小。 Microsoft Support article 里写了怎样移除ETags。在Apache中，可以简单地通过在Apache配置文件中添上如下代码来实现： 7.避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： straight HTML ：&lt;img src=””&gt; JavaScript 12var img = new Image();img.src = “”; 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 IE向页面所在目录发起一个请求 *Safari和Chrome 向当前页面本身发送一个请求 Firefox 3及更早版本与Safari和Chrome处理方式一样，但3.5解决了这个问题 [bug 444931] ，不会再发送请求了 Opera 遇到有空src属性的图片不做任何处理 为什么图片src属性为空不好？ 意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。 浪费服务器资源去生成一个根本不可能被看到的页面 可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。 问题的根本原因是各个浏览器在处理URI时的分歧，这在RFC 3986 – Uniform Resource Identifiers文档中有明确定义。如果URI是一个空串，会被看作一个相对URI，实际情况是，Firefox、Safari和Chrome都是根据文档中5.4节列出的规范来处理空串，而IE并没有正确处理。据说在旧版本规范文档RFC 2396 – Uniform Resource Identifiers（被RFC 3986废弃了）中，所以从严格意义上来说浏览器处理相对URI的做法都是对的。问题是，在这种情形下，空串显然是无心的（P.S. 而不是什么相对URI）。 HTML5的4.8.2节有关于&lt;img&gt;标签src属性的描述，规定浏览器不再发送额外请求： The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.（P.S. “src属性必须存在，而且必须有一个合法的URL引用非交互式的动画或者图像资源，不能分页也不能含有脚本。如果元素的基URI和文档地址相同，那么src属性的值就不能是空串。”） 希望将来浏览器不会存在这个问题，不幸的是，没有针对&lt;script src=””&gt;和&lt;link href=””&gt;条款，也许还有时间调整，以确保浏览器不会意外地实现这一行为。 css1.把样式表放在顶部在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面 看起来 加载地更快。这是因为把样式表放在head里能让页面逐步渲染。 关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被 记录 下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。 在很多浏览器（包括IE）中，把样式表放在HTML文档底部都会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。 HTML官方文档 清楚地描述了样式表应该放在页面的HEAD里面：”Unlike A, [LINK] may only appear in the HEAD section of a document, although it may appear any number of times.”（不像a标签，link标签可能只出现在HEAD部分，虽然它能可以出现任意多次）。空白屏幕或者没有样式的falsh内容都是不可取的。理想方案就是遵循HTML官方文档，把样式表放在HTML文档的HEAD部分。 2.避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了 。例如，可以用CSS表达式把背景颜色设置成按小时交替的： 1background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); 上面的代码中， expression方法可以接受一个JavaScript表达式。CSS属性会被设置成表达式的计算结果。 expression方法会被其它浏览器忽略，所以只有想办法实现跨浏览器的与IE一致的用户体验才有用。 表达式最大的问题是它们经常被重复计算，比我们想象的次数还要多。不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都会重新计算表达式。给CSS表达式添加一个计数器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。 减少CSS表达式重新计算的一种方式就是用一次性表达式，即在表达式第一次计算后就把样式属性设置成一个明确的值，换掉表达式。如果必须要在页面的整个生命周期中动态设置样式属性，可以用事件处理器来代替CSS表达式。如果必须使用CSS表达式，要记得它们可能会被重复计算上千次，从而影响整个页面的性能。 3.选择&lt;link&gt;舍弃@import 前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。 在IE中用@import与在底部用&lt;link&gt;效果一样，所以最好不要用它。 4.避免使用滤镜IE专有的 AlphaImageLoader 滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。 最好的方法是干脆不要用 AlphaImageLoader ，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用 AlphaImageLoader ，应该用下划线hack： _filter 来避免影响IE7及更高版本的用户。 JavaScript1.把脚本放在底部脚本会阻塞并行下载， HTTP/1.1官方文档 建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。 有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用 document.write 插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。 一个常见的建议是用推迟（deferred）脚本，有 DEFER 属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持 DEFER 属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。 2.尽量减少DOM访问用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该： 缓存已访问过的元素的索引 先“离线”更新节点，再把它们添到DOM树上 避免用JavaScript修复布局问题 3.用智能的事件处理器 有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用 事件委托 的原因。如果一个 div 里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 不需要为了处理DOM树而等待onload事件，通常只要目标元素在DOM树中可访问即可，而不必等待所有的图片下载完成。可以考虑用 DOMContentLoaded 来代替onload事件，但为了让它在所有浏览器中都可用，可以用 YUI Event 工具，它有一个 onAvailable方法。 4.去除重复脚本页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。 IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。 除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签： 1&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt; PHP中一个可选方案是创建一个叫 insertScript 的函数： 1&lt;?php insertScript(&quot;menu.js&quot;) ?&gt; 除了防止相同脚本被多次引入，这个函数还可以解决脚本相关的其它问题，比如依赖性检查和给脚本文件名添加版本号来支持“永久”有效期HTTP头。 css和JavaScript1.把JavaScript和CSS放到外面很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？ 实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。 关键因素是，外部文件被缓存的频率和页面被请求数量之间的关系。尽管这个因素很难量化，但我们还是可以用各种各样的指标来衡量。如果用户的每个会话中都有多次页面访问，那么相同的脚本和样式表就可以被多个页面复用，缓存的外部文件就会带来巨大的好处。 很多站点在度量中都处于中等水平，对这些站点来说，一般最好的解决方案就是把JavaScript和CSS部署为外部文件。唯一的例外是主页上行内方式优先，例如 Yahoo!的首页 和 My Yahoo! 。在每个会话中访问量比较少的主页会发现行内JavaScript和CSS能让终端用户的响应时间更快。 对典型的站点来说，首页是众多访问量的开始，有很多技术可以对减少HTTP请求起到杠杆作用，就像用外部文件缓存的好处一样。这样的一种技术就是在首页用行内JavaScript和CSS，但在页面载入完成之后动态加载外部文件，这样后续的页面所需的外部文件就已经被放到浏览器的缓存里了。 2.压缩JavaScript和CSS压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是 JSMin 和 YUI Compressor ，YUI compressor还可以压缩CSS。 混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。 除了压缩外部脚本和样式，行内的&lt;script&gt;和 &lt;style&gt;块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。 图片1. 优化图片设计师做好图片后，在把这些图片通过FTP上传到web服务器之前，我们还可以做一些事情。 检查GIF图片，看看图片中是不是用了调色板大小对应的颜色数，用 imagemagick可以简单地检查： identify -verbose image.gif如果4色图片用了调色板中256色的“槽”，那就还有改进的余地，试着把GIF图片转换成PNG，看能不能缩减大小，往往可以。 开发者通常不愿意用PNG图片，因为浏览器支持有限，但这都是过去的事情了。真正的问题是PNG图片完全支持alpha透明度，而GIF图片却不支持透明度渐变，所以GIF能做的任何事情，PNG都可以（除了动画）。下面这个简单的命令就能让PNG图片可以安全使用： 1convert image.gif image.png 我们强调的是：给PNG一个机会。 用 pngcrush （或者其它的PNG优化工具）处理所有的PNG图片，例如： 1pngcrush image.png -rem alla -reduce -brute result.png 用jpegtran处理所有JPEG图片，这个工具支持对JPEG图片的无损操作比如旋转，还可以用来去除注释和其它无用信息（比如EXIF信息 P.S. 数码照片信息，焦距光圈之类的）： 1jpegtran -copy none -optimize -perfect src.jpg dest.jpg 2. 优化CSS Sprite在Sprite图片中横向排列一般都比纵向排列的最终文件小 组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式 “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 不要用HTML缩放图片 不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要 1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 4. 用小的可缓存的favicon.ico（P.S. 收藏夹图标）favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个 404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保： 足够小，最好在1K以下 设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较 安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。Imagemagick 可以用来处理小收藏夹图标 移动端 保证所有组件都小于25K 这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是 未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 把组件打包到一个复合文档里 把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 Cookie1.给Cookie减肥使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 清除不必要的cookie： 保证cookie尽可能小，以最小化对用户响应时间的影响 注意给cookie设置合适的域级别，以免影响其它子域 设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 2.把组件放在不含cookie的域下当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 如果域名是 www.example.org ，可以把静态组件部署到 static.example.org 。然而，如果已经在顶级域 example.org或者 www.example.org设置了cookie，那么所有对 static.example.org 的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是 yimg.com ，YouTube是 ytimg.com ，Amazon是 images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到` *.example.org` ，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"雅虎35条","slug":"雅虎35条","permalink":"http://yoursite.com/tags/雅虎35条/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"常见的浏览器内核","slug":"常见的浏览器的内核","date":"2018-07-20T06:41:13.000Z","updated":"2018-10-12T14:46:18.519Z","comments":true,"path":"2018/07/20/常见的浏览器的内核/","link":"","permalink":"http://yoursite.com/2018/07/20/常见的浏览器的内核/","excerpt":"","text":"作为一个优秀的前端程序员，大家肯定都听过并且用过各种浏览器，比如说IE、Opera、Firefox、Safari、Chrome等等，为了调整这些浏览器的兼容性也是煞费苦心，我看似许多不同的浏览器，其实其中还是有很多相似之处，给大家科普一下不同浏览器的不同内核，以方便大家以后能更好的调整浏览器的兼容性。 1. 内核的概念 内核只是一个通俗的说法，其英文名称为“Layout engine”，称为“页面渲染引擎”。它负责取得网页的内容（HTML、XML、图像等等）、整理信息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。 所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要页面渲染引擎。 不同的浏览器内核对页面的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同，前端程序员就必须利用各种各样的方法来消除这些浏览器之间的差异。 2.浏览器内核的种类 我们常常喜欢把浏览器内核与某浏览器名称直接挂钩起来，如IE内核、Chrome内核，其实是不全面的说法。比如Opera在7.0版本到12.16版本中采用的是独立研发的Presto引擎，但在后续跟随了Chrome的脚步加入了WebKit大本营，放弃了Presto； 即使名称相同，但版本不同的引擎也可能存在较大差别。比如IE6使用的是Trident早期版本，存在许多bug，性能也较低。而最新的IE11所使用的Trident7.0版本已经可以支持WebGL（3D绘图标准）以及HTML5大部分标准。 2.1.TridentTrdent是微软开发的一种排版引擎。该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到目前的 IE11。 Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器涌现，比如：Maxthon、The World 、TT、GreenBrowser、AvantBrowser等。 由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE浏览器的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，这就好比清朝时候的闭关锁国，迂腐无知一样，微软很长时间都并没有更新Trident内核，这导致了两个非常严重的后果。 Trident内核曾经几乎与W3C标准脱节（2005年）； Trident内核的大量Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器。 Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。 2.2.GeckosGecko是套开放源代码的、以C++编写的网页排版引擎。这软件原本是由网景通讯公司开发的，Netcape6开始采用该内核。后来的FireFox也采用了该内核。 Geckos的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能，因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。 事实上，Gecko引擎的由来跟IE内核有着很大的关系，因为IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。 Gecko是一个跨平台内核，可以在Windows、BSD、Linux和Mac OS X中使用。 Geckos内核发展历史： 1997年，网景收购了DigitalStyle。当时，网景浏览器在各方面的表现已经比不上她的主要竞争对手Internet Explorer。网景开始研发下一代的排版引擎，并期望把新的排版引擎应用于下一版本的网景浏览器上。 1998年初，Mozilla计划开始执行。这个新的排版引擎名为Raptor，以开发源码的方式发放于互联网上。后来，因为商标问题，Raptor改名为NGLayout（即next generation layout之意）。而最后NGLayout就被网景重新命名为Gecko。 2003年7月15日时代华纳解散了网景公司，大部分开发者被解雇。Mozilla基金会亦在当天成立，继续推动着Gecko的发展。时至今天，Gecko仍继续由Mozilla的雇员和义工所维护和发展。 2.3.PrestoPresto是一个由Opera Software开发的浏览器排版引擎，该内核在2003年的Opera7中首次被使用，直到Opera12.17版本，该款引擎的特点就是渲染速度的优化达到了极致，也是被公认网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性，这就是所谓的鱼和熊掌不可兼得。 Presto内核是一个动态内核，在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。 Presto内核在执行Javascrīpt的时候有着最快的速度，根据在同等条件下的测试，Presto内核执行同等Javascrīpt所需的时间仅有Trident和Gecko内核的约1/3（Trident内核最慢，不过两者相差没有多大），有一个大牛认为上述测试信息过于老旧且不完整，因为他曾做过的小测试显示Presto部分快部分慢，各内核总体相当。那次测试的时候因为Apple机的硬件条件和普通PC机不同所以没有测试WebCore内核。 只可惜Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、WiiInternet Channle、Nokia770网络浏览器等，这很大程度上限制了Presto的发展，导致已经无人问津了。 2.4.WebkitWebkit内核它是苹果公司自己的内核，Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持BSD系统的开发。所以Webkit也是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。 限于Mac OS X的使用不广泛和Safari浏览器曾经只是Mac OS X的专属浏览器，这个内核本身应该说市场范围并不大；但似乎根据最新的浏览器调查表明，该浏览器的市场甚至已经超过了Opera的Presto了——当然这一方面得益于苹果转到x86架构之后的人气暴涨，另外也是因为Safari3终于推出了Windows版的原因。 2.5.BlinkBlink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。这一渲染引擎是开源引擎WebKit中WebCore组件的一个分支。 3.常见的浏览器使用的内核3.1.1.使用Trident内核的浏览器 Trident内核的常见浏览器有： IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0） 360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink） 猎豹极轻浏览器，360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink） 猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink） 猎豹极轻浏览器，傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核） 百度浏览器（早期版本）、世界之窗浏览器(最初为IE内核，2013年采用Chrome+IE内核） 2345浏览器(IE+Chrome双内核)、腾讯TT、淘宝浏览器、采编读浏览器、搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit） 阿云浏览器（早期版本）、瑞星安全浏览器、Slim Browser、 GreenBrowser、爱帆浏览器（12 之前版本） 115浏览器、155浏览器、闪游浏览器、N氧化碳浏览器、糖果浏览器、彩虹浏览器、瑞影浏览器、勇者无疆浏览器 114浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器（iPhone/iPad/Android） UC浏览器（Blink内核+Trident内核），浏览器实在是太多了，简直了！！！ 注意：其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。 3.1.2.使用Gecko内核的浏览器 Firefox、Netcape6及以上版本 SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon 3.1.3.使用Presto内核的浏览器 Opera7及以上版本，12.16以下的版本 小番外，Opera浏览器的发展历史: Opera浏览器，是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器。是跨平台浏览器可以在Windows、Mac和Linux三个操作系统平台上运行。 Opera浏览器创始于1995年4月，到2014年3月4日，官方发布的个人电脑用的最新版本为Opera20。 Opera的一个里程碑作品是Opera7.0,因为它使用了OperaSoftware自主开发的Presto渲染引擎，取代了旧版Opera 4至6版本使用的Elektra排版引擎。 Presto加入了动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。Presto在推出后不断有更新版本推出，使不少错误得以修正，以及阅读Javascript效能得以最佳化，并成为当时速度最快的引擎。 然而为了减少研发成本，Opera在2013年2月宣布放弃Presto，转而跟随Chrome使用WebKit分支的Chromium引擎作为自家浏览器核心引擎。 在Chrome与2013年推出Blink引擎（基于WebKit的分支）之后，Opera也紧跟其脚步表示将转而使用Blink作为浏览器核心引擎。 3.1.4使用Webkit内核的浏览器： 傲游浏览器、Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， Chrome(28版本以前)、360极速浏览器、搜狗高速浏览器高速模式 Google的手机 Gphone、 Apple 的iPhone等所使用的Browser 内核引擎，都是基于WebKit。 3.1.5使用Blink内核的浏览器 Chrome（28及往后版本）、Opera（15及往后版本）、Yandex浏览器","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"浏览器内核","slug":"浏览器内核","permalink":"http://yoursite.com/tags/浏览器内核/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"服务器基础知识","slug":"服务器基础知识","date":"2018-07-18T00:45:51.000Z","updated":"2018-10-12T14:46:38.069Z","comments":true,"path":"2018/07/18/服务器基础知识/","link":"","permalink":"http://yoursite.com/2018/07/18/服务器基础知识/","excerpt":"","text":"1.服务器的分类服务器的类型按照不同的划分标准，服务可划分为以下类型： 按服务类型可分为：文件服务器、数据库服务器、邮件服务器、Web服务器等。 按操作系统可分为：Linux服务器、Windows服务器 按应用软件可分为：Apache服务器、Nginx服务器、IIS服务器、Tomcat服务器、Node服务器 2.服务器软件：使计算机具备提供某种服务能力的应用软件，称为服务器软件，通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。常见的服务器软件有： 文件服务器：Server-U、FileZilla、VsFTP等； 数据库服务器：Oracle、MySQL、PostgreSQL、MSSQL等； 邮件服务器：Postfix、Sendmail等； HTTP 服务器：Apache、Nginx、IIS、Tomcat、NodeJS等； 3.HTTP服务器 网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件，HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见的运行在服务端的编程语言包括 PHP、Jsp、Asp、Python、Ruby、Perl等。 4.客户端： 具有向服务器索取服务能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。 常见的客户端软件：浏览器、QQ、迅雷、Foxmail等。 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 5.状态代码5.1.成功 200 正常;请求已完成。 201 正常;紧接POST命令。 202 正常;已接受用于处理，但处理尚未完成。 203 正常;部分信息 — 返回的信息只是一部分。 204 正常;无响应 — 已接收请求，但不存在要回送的信息。 5.2.重定向 301 永久重定向 — 请求的数据具有新的位置且更改是永久的。 302 暂时重定向 — 请求的数据临时具有不同URI。 303 请参阅其它 — 可在另一URI下找到对请求的响应，且应使用 GET方法检索此响应。 304 未修改 — 未按预期修改文档。 305 使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。 306 未使用 — 不再使用;保留此代码以便将来使用。 5.3.代码中的错误 400 错误请求 — 请求中有语法问题，或不能满足请求。 401 未授权 — 未授权客户机访问数据。 402 需要付款 — 表示计费系统已有效。 403 禁止— 即使有授权也不需要访问。 404 找不到—服务器找不到给予的资源;文档不存在。 406 不可接受 — 根据此请求中所发送的“接受”标题，此请求所标识的资源只能生成内容特征为“不可接受”的响应实体。 407 代理认证请求 — 客户机首先必须使用代理认证自身。 410 请求的网页不存在(永久); 415 介质类型不受支持 —服务器拒绝服务请求，因为不支持请求实体的格式。 500 内部错误 — 因为意外情况，服务器不能完成请求。 501 未执行 —服务器不支持请求的工具。 502 错误网关—服务器接收到来自上游服务器的无效响应。 503 无法获得服务 — 由于临时过载或维护，服务器无法处理请求。 6.搭建HTTP服务器：Windows + Apache + Mysql + PHP，首字母组合。 6.1.安装WampServer安装wampserver，和普通软件安装无差别，除指定安装路径外，其它默认安装。 6.2.管理HTTP服务任务图标绿色为正常启动状态，通过图形控制台可以启动、重启、停止所有服务 或者单独启动、重启、停止特定服务 注意事项： 检查网络是不是通的 ping 对方IP 检查防火墙是否开启，如果开启将不能正常被访问 检查访问权限是否都为Require all granted而不是Require all denied。 理解默认索引(index.php)：在浏览器中输入127.0.0.1时出现的页面。 确保端口没有被其它程序占用 “#”表示注释 修改配置要格外小心，禁止无意修改其它内容 6.3.配置根目录网站根目录是Web服务器上存放网站程序的空间，可通过修改配置文件自定义，如E:/www，具体步骤如下： 打开配置文件，控制台选择： 或者 wampserver安装目录下bin\\apache\\Apache2.2.21\\conf\\httpd.conf 设定根目录，查找并修改 例如： 这样就指定了&quot;E:/www/&quot;为存放网站的根目录。 配置根目录，查找 修改成 修改完后，并不能立即生效，需要重启Apache 注：可以指定任意目录为根目录 6.4.网站部署将我们制作好的网页拷贝到配置好的根目录下，浏览器访问127.0.0.1即可。 6.5. 配置虚拟主机在一台Web服务器上，我们可以通过配置虚拟主机，然后分别设定根目录，实现对多个网站的管理。具体步骤如下： 开启虚拟主机辅配置，在httpd.conf 中找到 去掉前面的#号注释，开启虚拟主机配置 *0配置虚拟主机，打开conf/extra/httpd-vhosts.conf 分别修改以下三项： 123DocumentRoot &quot;C:\\wamp\\www\\zhimeng&quot; ServerName zhimeng.com ServerAlias www.zhimeng.com 其它项无需指定。 修改DNS（hosts）文件,打开C:\\Windows\\System32\\drivers\\etc\\hosts 注：修改hosts文件权限 重启Apache 浏览器访问http://www.zhimeng.com/ 7.关于网络 ping+网址：查看该网址的IP地址 ipconfig：查看本地主机的ip地址 查看不同端口的占用情况：netstat -an4.C/S与B/S C/S结构===客户端与服务器通信 在C/S结构的情况下，不同的服务需要安装不同的客户端软件，比如QQ、迅雷、Foxmail这种情况下安装的软件会越来越多，同时也有许多弊端，比如A出差，需要在B电脑上查收邮件，但是B电脑并未安装Foxmail等类似的客户端软件，这样不得不先去下载Foxmail，非常不方便。 B/S结构===浏览器与服务器通信 B/S（即Broswer、Server）解决了C/S所带来的不便，将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安装了浏览器），但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。 注意：B/S结构是C/S结构的一个特例 8.关于HTTP协议超文本传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。HTTP协议对由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 8.1.请求/请求报文请求由客户端发起，其规范格式为：请求行、请求头、请求主体。 Get请求： 对应于浏览器： Post请求： 请求行： 由请求方式、请求URL和协议版本构成 请求头 123456789Host：localhost请求的主机Cache-Control：max-age=0控制缓存Accept：*/* 接受的文档MIME类型User-Agent：用户代理很重要Referer：从哪个URL跳转过来的Accept-Encoding：可接受的压缩格式Content-Type：资源的MIME类型，Post的请求方式有，而Get的请求方式没有。If-None-Match：记录服务器响应的ETag值，用于控制缓存If-Modified-Since：记录服务器响应的Last-Modified值 请求主体：即传递给服务端的数据 注意：当以post形式提交表单的时候，请求头里会设置Content-Type:application/x-www-form-urlencoded，以get形式时不需要请求主体。 8.2.响应/响应报文响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 Get请求的响应： Post请求的响应： 状态行： 由协议版本号、状态码和状态信息构成 响应头 123456Date：响应时间Server：服务器信息Last-Modified：资源最后修改时间ETag：资源修改后生成的唯一标识Content-Length：响应主体长度Content-Type：响应资源的MIME类型，MIME是标识文件类型的，文件后缀并不能正确无误的标识文件的类型。 响应主体：即服务端返回给客户端的内容 注：关于响应码通常由3位数字组成，分别以1、2、3、4、5开始分成5组，每组具有不同的意义，具体参考下文： 1xx：信息、2xx：成功、3xx：重定向、4xx：客户端错误、5xx：服务器错误。 常见的有200代表成功、304文档未修改、403没有权限、404未找到、500服务器错误。 8.3.调试工具利用HTTP抓包工具在开发中可以帮我们进行调试，常用抓包工具HttpWatch、Fiddler、Charles、FireBug等 8.4.浏览器插件Firebug、HttpWatch、chrome dev tools 8.5.代理软件Charles、Fiddler 8.6.协商缓存前端性能优化雅虎35条：https://www.tuicool.com/articles/J3uyaa 利用浏览器的缓存机制，可以有效的减少HTTP的请求，提高页面加载速度，增强用户体验，同时也能极大的减轻服务器的负担，结合HTTP协议，缓存协商就是根据HTTP协议实现缓存控制的一种机制。 9.查看端口占用情况命令：netstat -ano win+R打开cmd窗口 netstat -ano列出所有端口的情况，找到被占用的端口 输入命令netstat -aon|findstr &quot;8080&quot;找对应的PID 输入命令tasklist|findstr &quot;21548&quot;查找具体的占用进程 5、打开资源管理器，找到PID是21548的进程（没有PID这一列的话可以右击列添加PID列） 6、如果想结束进程，可以使用：taskkill /f /t /im进程名","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"ajax()函数的封装","slug":"封装的ajax()函数","date":"2018-07-15T10:33:45.000Z","updated":"2018-10-12T14:46:40.380Z","comments":true,"path":"2018/07/15/封装的ajax()函数/","link":"","permalink":"http://yoursite.com/2018/07/15/封装的ajax()函数/","excerpt":"","text":"1.封装一个自己的ajax()方法,减少代码的重复，不然每次都要重复的写一些相同的代码。一般情况下，我们如果要把一个功能封装成一个函数，应该怎么去构想呢？？？ 我们首先需要确定这个函数有几个参数？ url,get/post,data我们可能需要这三个参数 正常的思路： 123function ajax(url,type,data,callback)&#123;&#125; 需要一个回调函数来执行获取到数据之后的操作。 但是我们又嫌弃函数的参数名字太长了，我们可以改成这样的形式 12345678910var obj=&#123; url:&apos;&apos;, type:&apos;&apos;, data:&apos;&apos;, callback:function()&#123;&#125;&#125;function ajax(options)&#123;&#125;ajax(obj); //调用ajax()函数 这种思路往往是被采用的，和第一种写法比较,有什么好处呢？ 我们可以看出第二种方法明显的更简洁一些，并且第一种方式的参数的位置是被固定死的，第二种方式参数的位置可以很灵活。 我们还有一个问题，如果你写了一个函数为function ajax(){},但是你的同事并不知道你占用了这个名字，它也写了个函数叫function ajax(){},如果这两个函数加载到同一个页面，其中的一个肯定会被覆盖的，我们怎么解决这个问题呢？怎么解决命名冲突问题呢？ 12345//命名冲突function ajax()&#123;&#125;function ajax()&#123;&#125; 解决办法：我们把函数封装到一个对象内部中 123456789101112var obj=&#123; ajax:function()&#123;&#125;&#125;obj.ajax() //调用ajax()方法//另一个同事var obj1=&#123; ajax:function()&#123;&#125;&#125;obj1.ajax() //调用ajax()方法 这样就解决了函数命名冲突问题.(把函数封装在一个对象内部)，专业一点来说就是采用命名空间的方式来解决函数命名冲突问题。 怎么使用命名空间？：定义一个全局的对象，把方法绑到这个全局对象的下面。 我们现在就可以动手来写了： 所需要的参数：url,get/post,data 12345678910111213141516171819var $ = &#123; //处理data的格式 params: function(data) &#123; var res=&apos;&apos;; for(var key in data)&#123; res += key+ &apos;=&apos; +data[key]+ &apos;&amp;&apos;; &#125; return res.slice(0,-1); &#125;, ajax: function(options) &#123; //传参数 //传给函数的地址||默认的当前地址 var url = options.url || location.pathname; //传给函数的请求方法||默认的请求方式 var type = options.type || &apos;get&apos;; //定义一个方法params()处理数据格式 var data = this.params(options.data); &#125;&#125; 经过以前的案例学习，我们可以知道经过post方式发送的数据的格式一般是xhr.send(&quot;name=yang&amp;age=18&quot;)这样的，但是调用的时候我们是这样的data:{name:Asici,age:18},这样的形式是不匹配的，所以在ajax()函数中我们需要处理一下data数据的格式。 函数的调用 1234567891011121314$.ajax(&#123; url: &apos;01.php&apos;, type: &apos;post&apos;, data: &#123; name: &apos;Asic&apos;, age: &apos;18&apos; &#125;, success: function(data) &#123; console.log(data); &#125;, error: function(err) &#123; &#125;&#125;) 我们现在封装的params()可以达到我们的效果吗？ 1234567params: function(data) &#123; var res=''; for(var key in data)&#123; res += key+ '=' +data[key]+ '&amp;'; &#125; console.log(res); &#125; 通过上图我们可以发现最后多了一个&amp;符号,还是不太符合要求，我们需要在修改一下。 12345678params: function(data) &#123; var res=''; for(var key in data)&#123; res += key+ '=' +data[key]+ '&amp;'; &#125; return res.slice(0,-1); console.log(res.slice(0,-1));&#125; 这样就达到了我们想要的效果了。 封装好了所需要的函数，现在就需要实例化了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var $ = &#123; //格式化参数 params: function(data) &#123; var res = ''; for(var key in data) &#123; res += key + '=' + data[key] + '&amp;'; &#125; return res.slice(0,-1); &#125;, ajax: function(options) &#123; //传参数 //获取请求的地址||默认的当前地址 var url = options.url || location.pathname; //获取请求方式||默认的请求方式 var type = options.type || 'get'; //定义一个方法params()处理数据格式(格式化参数) var data = this.params(options.data); //实例化XMLHttpRequest var xhr=new XMLHttpRequest; //判断以get形式请求 if(type=='get')&#123; url = url + '?' + data; data=null; &#125; //发起一个请求 xhr.open(type,url); //以post形式的时候需要设置文档类型 if(type=='post') &#123; xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') &#125; //发送请求主体 xhr.send(data); &#125; &#125; $.ajax(&#123; url: '01.php', type: 'post', data: &#123; name: 'Asic', age: '18' &#125;, success: function(data) &#123; console.log(data); &#125;, error: function(err) &#123;&#125; &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 基本的封装已经好了，就只差事件监听了，我们先在浏览器中测试一下，看目前的封装有没有问题。 post请求方式： get请求方式 大家可能不太知道location.pathname是什么，我来说一下 location对象有很多的属性，location.pathname是获取当前页面的地址信息，还有很多其他属性，大家都可以看下。 我们接下来就要封装onreadystatechange()方法 1234xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; &#125; &#125; 在XMLHttpRequest中有这样一些方法： 1234console.log(xhr.getAllResponseHeaders())console.log(xhr.getResponseHeader('content-type')); getAllResponseHeaders:获取响应的所有http头 getResponseHeader：从响应信息中获取指定的http头 xhr.responseText xhr.responseXML 因为可能获取到不同类型的数据所以我们要分情况对待,我们需要知道当前返回的到底是什么类型的数据，一般情况下我们都希望返回的是JSON数据(字符串)，继续封装吧。 完整的封装版。 ajax.js 12345678910111213141516171819202122232425262728293031323334353637383940414243var $ = &#123; params: function(data) &#123; var res = ''; for(var key in data) &#123; res += key + '=' + data[key] + '&amp;'; &#125; return res.slice(0,-1); &#125;, ajax: function(options) &#123; //传参数 //传给函数的地址||默认的当前地址 var url = options.url || location.pathname; //传给函数的请求方法||默认的请求方式 var type = options.type || 'get'; //定义一个方法params()处理数据格式 var data = this.params(options.data); var xhr=new XMLHttpRequest; if(type=='get')&#123; url = url + '?' + data; data=null; &#125; xhr.open(type,url); if(type=='post') &#123; xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') &#125; xhr.send(data); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; var ct=xhr.getResponseHeader('content-type'); //indexOf()判断ct中是不是有json这个字符串，返回值为该字符串的起始位置。 if(ct.indexOf('json')!=-1)&#123; //将JSON格式的字符串转化成JavaScript对象parse() var data=JSON.parse(xhr.responseText); //接下来就要交给回调函数工作了 options.success(data); &#125;else&#123; options.error() &#125; &#125; &#125; &#125;&#125; 01.php 1234&lt;?php header(&apos;Content-Type:application/json; charset=utf-8&apos;); echo json_encode($_REQUEST);?&gt; 测试： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"ajax.js\"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: '01.php', type: 'post', data: &#123; name: 'Asic', age: '18' &#125;, success: function(data) &#123; console.log(data); &#125;, error: function(err) &#123;&#125; &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 测试结果： 缺点：到目前为止，这个封装的小工具其实只考虑了部分情况，比如说数据格式只能是JSON形式的，在实际情况中，其实还可能是XML数据格式的，这种情况其实我们都没有考虑，只是把一些常用的一些操作封装了，许多地方还有优化的可能，这里先不说了。 那我们来测试一下，我们封装的这个到底好用不好用。 index.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;style&gt; table &#123; width: 300px; border-collapse: collapse; &#125; td &#123; height: 40px; text-align: center; border: 1px solid #CCC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;/table&gt; &lt;div class=\"btn\"&gt;&lt;input type=\"button\" value=\"获取数据\"&gt;&lt;/div&gt; &lt;script src=\"ajax.js\"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'stars.php', type: 'post', data: &#123; test:'test ajax tools' &#125;, success: function(data) &#123; console.log(data); &#125;, error: function(err) &#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; stars.json 123456789101112131415161718192021222324252627282930[ &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;] stars.php 123456&lt;?php // 指定文档类型 header(&apos;Content-Type:application/json; charset=utf-8&apos;); $result = file_get_contents(&apos;stars.json&apos;); echo $result;?&gt; 运行结果: 说明我们的封装基本是正确的，那我们利用自己封装的函数看能不能实现和以前一样的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;style&gt; table &#123; width: 300px; border-collapse: collapse; &#125; td &#123; height: 40px; text-align: center; border: 1px solid #CCC; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;/table&gt; &lt;script src=&quot;ajax.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: &apos;stars.php&apos;, type: &apos;post&apos;, data: &#123; test: &apos;test ajax tools&apos; &#125;, success: function(data) &#123; var html = &apos;&apos;; for(var i = 0; i &lt; data.length; i++) &#123; html += &apos;&lt;tr&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].name + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].ablum + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].age + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].sex + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;/tr&gt;&apos;; &#125; document.querySelector(&apos;table&apos;).innerHTML = html; &#125;, error: function(err) &#123;&#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 是不是很开心我们自己封装的函数可以实现相同的效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"浅谈ajax","slug":"浅谈ajax","date":"2018-07-12T02:16:37.000Z","updated":"2018-10-12T14:46:30.951Z","comments":true,"path":"2018/07/12/浅谈ajax/","link":"","permalink":"http://yoursite.com/2018/07/12/浅谈ajax/","excerpt":"","text":"AJAX 即 Asynchronous Javascript And XML，不是一门的新的语言，而是对现有持术的综合利用。其本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 1.XMLHttpRequest浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。(局部更新) 内建对象：浏览器已经封装好了该方法，用的时候只需要new一下就可以拿来使用了。 举例：我们先写请求行和请求主体 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //new一下，实例化 var xhr=new XMLHttpRequest; //请求 //请求行 xhr.open(&apos;get&apos;,&apos;01.txt&apos;); //以get的方式请求，请求主体为空。 //请求主体 xhr.send(null); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 我们可以再浏览器看一下结果： 可以明显的看到请求的地址和请求的方法。 注意：请求主体即使是空的，也要写着，这个是不能忽略的。 现在可以来写请求头了 12//请求头xhr.setRequestHeader('Content-Type','text/html'); 再来刷一刷浏览器的结果： 请求发送完了，这下我们该接收响应了。这下客户端的请求发送过来了，等到服务器空闲就去处理，本来说是客户端得一直等着服务器端的处理，其实客户端不用一直等着去干别的事情，可以设置一个监听事件onreadystatechange监听服务器端什么时候处理完这个请求，等服务器处理完之后客户端在接收，这样客户端就不用一直等着，这也就是异步请求的原理。 12345678//接收响应 xhr.onreadystatechange=function()&#123; console.log(xhr.readyState); if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; var result=xhr.responseText; console.log(result); &#125; &#125; onreadystatechang属性一直监听着服务器端的变化，我们可以检测一下 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //new一下，实例化 var xhr=new XMLHttpRequest; console.log(xhr.readyState); //请求 //请求行 xhr.open('get','01.txt'); console.log(xhr.readyState); //请求头 xhr.setRequestHeader('Content-Type','text/html'); console.log(xhr.readyState); //以get的方式请求，请求主体为空。 //请求主体 xhr.send(null); //接收响应 xhr.onreadystatechange=function()&#123; console.log(xhr.readyState); if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; var result=xhr.responseText; console.log(result); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器控制台查看结果： readyState属性的所有取值以及它所使用的范围： 2.同步ajax请求的方式是一个典型的异步请求的方式。我们现在可以看一下同步请求 open()方法中的第三个参数为true时，表示异步，为false时表示同步，默认为true。 举例： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var xhr=new XMLHttpRequest; xhr.open(\"get\",\"02.php\",false); xhr.setRequestHeader('Content-Type','text/html'); xhr.send(null); console.log(\"我是同步消息\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 02.php 1234&lt;?phpecho '我是同步方式的';sleep(10);?&gt; 大家可以在控制台看一下，等到10秒之后才会在控制台输出“我是同步消息”这句话，也就是说以同步的方式发送消息，客户端会一直在等待服务器做出响应，这样的效率会很低。 注意：有关于php的代码只有在php中运行才会有效，在测试前应该配置好基本的环境。 3.XMLHttpRequest传递数据1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var xhr=new XMLHttpRequest; xhr.open(\"get\",\"03.php?name=yang\") xhr.setRequestHeader(\"Content-Type\",\"text/html\"); xhr.send(null); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp; xhr.status==200)&#123; var result=xhr.responseText; document.getElementById(\"result\").innerHTML=result; console.log(result); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 03.php 123&lt;?phpecho $_GET['name'];?&gt; 运行结果：很明显在客户端已经获取到了这样的结果 大家是不是很好奇为什么传递数据为什么要是这样的形式？把要传递的参数写在请求资源的后面。 xhr.open(&quot;get&quot;,&quot;03.php?name=yang&quot;) 原因：因为在get的请求方式中，浏览器在默认情况下就是把参数放在URL后面的,我们要遵从浏览器的默认行为。 那如果以post的方式该怎么传递数据呢？肯定是和get的方式有些区别的。 以post的形式的话，传递的数据是放在send()方法中的。 注意：当以post形式提交表单的时候，请求头里会设置Content-Type:application/x-www-form-urlencoded，以get形式时不需要请求主体。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var xhr=new XMLHttpRequest; xhr.open(\"post\",\"04.php\") xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); xhr.send(\"name=yang&amp;age=18\"); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4&amp;&amp; xhr.status==200)&#123; var result=xhr.responseText; document.getElementById(\"result\").innerHTML=result; console.log(result); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 04.php 123&lt;?phpecho $_POST['name'].$_POST['age'];?&gt; 运行结果： 4.XMLHttpRequest实现局部更新功能(表单事件提交)1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"text\" /&gt; &lt;input type=\"submit\" value=\"发送\" id=\"sub\" /&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;script&gt; var btn = document.getElementById(\"sub\"); var test = document.getElementById(\"text\"); btn.addEventListener('click', function() &#123; //点击的时候才去实例化XMLHttpRequest，而不是加载的时候实例化XMLHttpRequest var xhr = new XMLHttpRequest; xhr.open(\"post\", \"05.php\"); //因为是post请求的方式，所以一定要设置Content-Type xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send('text=' + test.value); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var result = xhr.responseText; document.getElementById(\"result\").innerHTML = result; console.log(result); &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 05.php 123&lt;?phpecho '&lt;strong&gt;'.$_POST['text'].'&lt;/strong&gt;';?&gt; 运行结果 那我们来看一个小案例吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; .chatbox &#123; width: 500px; height: 500px; margin: 0 auto; border: 1px solid #CCC; background-color: #FFF; border-radius: 5px; &#125; .messages &#123; height: 350px; padding: 20px 40px; box-sizing: border-box; border-bottom: 1px solid #CCC; overflow: scroll; &#125; .messages h5 &#123; font-size: 20px; margin: 10px 0; &#125; .messages p &#123; font-size: 18px; margin: 0; &#125; .self &#123; text-align: left; &#125; .other &#123; text-align: right; &#125; .form &#123; height: 150px; &#125; .form .input &#123; height: 110px; padding: 10px; box-sizing: border-box; &#125; .form .btn &#123; height: 40px; box-sizing: border-box; border-top: 1px solid #CCC; &#125; .form textarea &#123; display: block; width: 100%; height: 100%; box-sizing: border-box; border: none; resize: none; outline: none; font-size: 20px; &#125; .form input &#123; display: block; width: 100px; height: 30px; margin-top: 5px; margin-right: 20px; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"chatbox\"&gt; &lt;div class=\"messages\"&gt; &lt;/div&gt; &lt;div class=\"form\"&gt; &lt;div class=\"input\"&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"btn\"&gt; &lt;input type=\"button\" value=\"发送\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--&lt;script type=\"text/template\"&gt; &lt;div class=\"item self\"&gt; &lt;h5&gt;我说&lt;/h5&gt; &lt;p&gt;你好&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item other\"&gt; &lt;h5&gt;对方说&lt;/h5&gt; &lt;p&gt;你好&lt;/p&gt; &lt;/div&gt; &lt;/script&gt;--&gt; &lt;script&gt; var btn = document.querySelector('.btn'); var message = document.querySelector('.messages'); btn.onclick = function () &#123; var xhr = new XMLHttpRequest; // 获取表单的DOM节点 var input = document.querySelector('textarea'); // 获取文本内容 var val = input.value; // 通过一函数创建并接凑DOM节点 var item = createMessage('self', val); // 将创建完成的DOM节点追加到消息盒子里 message.appendChild(item); // 置空表单 input.value = ''; ] /******************以下是Ajax*******************/ // 发起请求 xhr.open('post', 'chat.php'); // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 发送到服务器 xhr.send('message=' + val); // 监听并处理响应 xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 接收返回的消息 var result = xhr.responseText; // 通过一函数创建并接凑DOM节点 var item = createMessage('other', result); // 将接凑好的DOM节点追加到消息盒子里 message.appendChild(item); &#125; &#125; &#125; // 动态创建DOM function createMessage(flag, text) &#123; // 创建结点 var item = document.createElement('div'), h5 = document.createElement('h5'), p = document.createElement('p'); // 添加类 item.classList.add('item'); item.classList.add(flag); // 判断主体 switch(flag) &#123; case 'self': h5.innerText = '我说'; break; case 'other': h5.innerText = '对方说'; break; &#125; // 插入文本 p.innerText = text; // 追加节点 item.appendChild(h5); item.appendChild(p); return item; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; chat.php 123456789101112&lt;?php $messages = array( '你说啥？', '你也好', '你找我有啥事？', '我在吃饭！' ); // 通过array_rand()随机获取数组下标 // var_dump(array_rand($messages)); echo $messages[array_rand($messages)]; sleep(1);?&gt; 5.简单的总结XMLHttpRequest：浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。 下面是一个简单的例子： 由于XMLHttpRequest本质基于HTTP协议实现通信，所以结合HTTP协议和上面的例子我们分析得出如下结果： 5.1.请求HTTP请求3个组成部分与XMLHttpRequest方法的对应关系 请求行 请求头 get请求可以不设置 请求主体 注意书写顺序 5.2.响应HTTP响应是由服务端发出的，作为客户端更应关心的是响应的结果。 HTTP响应3个组成部分与XMLHttpRequest方法或属性的对应关系。 由于服务器做出响应需要时间（比如网速慢等原因），所以我们需要监听服务器响应的状态，然后才能进行处理。 onreadystatechange是Javascript的事件的一种，其意义在于监听XMLHttpRequest的状态。 获取状态行（包括状态码&amp;状态信息） 获取响应头 响应主体 我们需要检测并判断响应头的MIME类型后确定使用request.responseText或者request.responseXML 5.3.API详解 xhr.open() 发起请求，可以是get、post方式 xhr.setRequestHeader() 设置请求头 xhr.send() 发送请求主体get方式使用xhr.send(null) xhr.onreadystatechange = function () {} 监听响应状态 xhr.readyState = 0时，UNSENT open尚未调用 xhr.readyState = 1时，OPENED open已调用 xhr.readyState = 2时，HEADERS_RECEIVED 接收到头信息 xhr.readyState = 3时，LOADING 接收到响应主体 xhr.readyState = 4时，DONE 响应完成 xhr.status表示响应码， xhr.statusText表示响应信息， xhr.getAllResponseHeaders() 获取全部响应头信息 xhr.getResponseHeader(‘key’) 获取指定头信息 xhr.responseText、xhr.responseXML都表示响应主体 注意：GET和POST请求方式的差异（面试题） GET没有请求主体，使用xhr.send(null) GET可以通过在请求URL上添加请求参数 POST可以通过xhr.send(&#39;name=itcast&amp;age=10&#39;)[键值对的形式] POST需要设置请求头： 1xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 5.4.GET效率更好（应用多）5.5.GET大小限制约4K，POST则没有限制。6.XML数据VSJSON数据问题：如何获取复杂数据呢？利用XML或者JSON，现在大多数情况下用的是JSON。我们可以先来看一下XML。 6.1.XML数据XML是一种标记语言，很类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。 语法规则 必须有一个根元素 不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和HTML一样 虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。 下面是一个关于XML的小案例 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;XML&lt;/title&gt; &lt;style&gt; table &#123; width: 300px; border-collapse: collapse; &#125; td &#123; height: 40px; text-align: center; border: 1px solid #CCC; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;/table&gt; &lt;div class=&quot;btn&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;获取数据&quot;&gt;&lt;/div&gt; &lt;script&gt; var btn = document.querySelector(&apos;.btn&apos;); btn.onclick = function() &#123; var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, &apos;stars.php&apos;); xhr.send(null); xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 一个新的属性，用来接收XML格式的数据 var result = xhr.responseXML; // console.log(result); //解析XML文档的内容 var items = result.getElementsByTagName(&apos;root&apos;)[0]; //console.log(items); var item = items.getElementsByTagName(&apos;item&apos;); //console.log(item); //&lt;item&gt;的子元素有多少个，就循环遍历几次(4) var html = &apos;&apos;; for(var i = 0; i &lt; item.length; i++) &#123; var name = item[i].getElementsByTagName(&apos;name&apos;)[0]; var photo = item[i].getElementsByTagName(&apos;photo&apos;)[0]; var album = item[i].getElementsByTagName(&apos;album&apos;)[0]; var age = item[i].getElementsByTagName(&apos;age&apos;)[0]; var sex = item[i].getElementsByTagName(&apos;sex&apos;)[0]; var nameText = name.firstChild.nodeValue; var photoText = photo.firstChild.nodeValue; var albumText = album.firstChild.nodeValue; var ageText = age.firstChild.nodeValue; var sexText = sex.firstChild.nodeValue; html += &apos;&lt;tr&gt;&apos;; html += &apos;&lt;td&gt;&apos; + nameText + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + albumText + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + ageText + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + sexText + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;/tr&gt;&apos;; &#125; document.querySelector(&apos;table&apos;).innerHTML = html; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; stars.php 12345678&lt;?php // 指定文档类型 header('Content-Type:text/xml; charset=utf-8'); $result = file_get_contents('stars.xml'); echo $result;?&gt; stars.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt; &lt;item&gt; &lt;name type=&quot;star&quot;&gt;王力宏&lt;/name&gt; &lt;photo&gt;./images/wlh.jpg&lt;/photo&gt; &lt;album&gt;&amp;lt;&amp;lt;改变自已&amp;gt;&amp;gt;&lt;/album&gt; &lt;age&gt;39&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/item&gt; &lt;item&gt; &lt;name type=&quot;star&quot;&gt;周杰伦&lt;/name&gt; &lt;photo&gt;./images/wlh.jpg&lt;/photo&gt; &lt;album&gt;&amp;lt;&amp;lt;我很忙&amp;gt;&amp;gt;&lt;/album&gt; &lt;age&gt;39&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/item&gt; &lt;item&gt; &lt;name type=&quot;star&quot;&gt;王力宏&lt;/name&gt; &lt;photo&gt;./images/wlh.jpg&lt;/photo&gt; &lt;album&gt;&amp;lt;&amp;lt;改变自已&amp;gt;&amp;gt;&lt;/album&gt; &lt;age&gt;39&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/item&gt; &lt;item&gt; &lt;name type=&quot;star&quot;&gt;王力宏&lt;/name&gt; &lt;photo&gt;./images/wlh.jpg&lt;/photo&gt; &lt;album&gt;&amp;lt;&amp;lt;改变自已&amp;gt;&amp;gt;&lt;/album&gt; &lt;age&gt;39&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/item&gt;&lt;/root&gt; 运行结果： 大家可以看出来真的是用xml来表示比较复杂的数据时，解析数据时真的是超级麻烦并且文档体积也很大。我们可以用JSON来表示复杂的数据，解析数据的时候也较为简单。 6.2.JSON：即JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。语法规则： 数据在名称/值对中 数据由逗号分隔(最后一个健/值对不能带逗号) 花括号保存对象方括号保存数组 使用双引号 我们可以看下JSON解析数据的时候是否也和XML解析数据时一样复杂？ index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;style&gt; table &#123; width: 300px; border-collapse: collapse; &#125; td &#123; height: 40px; text-align: center; border: 1px solid #CCC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;/table&gt; &lt;div class=&quot;btn&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;获取数据&quot;&gt;&lt;/div&gt; &lt;script&gt; var btn = document.querySelector(&apos;.btn&apos;); btn.onclick = function () &#123; var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, &apos;stars.php&apos;); xhr.send(null); xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var result = xhr.responseText; console.log(typeof(result)); //将JSON格式的字符串类型转化为JavaScript对象 var data = JSON.parse(result); console.log(data); var html = &apos;&apos;; for(var i=0; i&lt;data.length; i++) &#123; html += &apos;&lt;tr&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].name + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].ablum + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].age + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;td&gt;&apos; + data[i].sex + &apos;&lt;/td&gt;&apos;; html += &apos;&lt;/tr&gt;&apos;; &#125; document.querySelector(&apos;table&apos;).innerHTML = html; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; stars.json 123456789101112131415161718192021222324252627282930[ &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;, &#123; &quot;name&quot;: &quot;王力宏&quot;, &quot;photo&quot;: &quot;./images/wlh.jpg&quot;, &quot;ablum&quot;: &quot;&lt;&lt;改变自已&gt;&gt;&quot;, &quot;age&quot;: 39, &quot;sex&quot;: &quot;男&quot; &#125;] stars.php 123456&lt;?php // 指定文档类型 header(&apos;Content-Type:application/json; charset=utf-8&apos;); $result = file_get_contents(&apos;stars.json&apos;); echo $result;?&gt; 运行结果: parse()方法的作用：将JSON格式的字符串类型转化为JavaScript对象 为什么要转化呢？ 我们应该都知道不同的语言都有着自己的一套语法规则，比如说不同语言定义变量、定义数组、定义对象的方式肯定都有所不同，所以不同的语言之间的通信是通过字符串来表示的，比如说JSON格式的字符串，用””双引号包起来的不管是对象也好，数组也好，在不同的语言都是可以运行通过的，并不会报错，当各个不同的语言接收到了这个字符串之后，就利用自己所对应语言所封装的方法转化成自己可以识别的对象，以便后续的操作，比如说在JavaScript预言中，将JSON格式的字符串类型转化为JavaScript对象的方法是parse()。 现在我们可以得到一个毫无疑问的答案，JSON格式的数据要比XML格式的数据简单的多，我们以后还是尽量用JSON格式的数据，XML格式的数据已经淘汰了呢。 我们得需要了解一下XMLHttpRequest在标准浏览器和IE浏览器存在着兼容性问题，我们需要一个兼容性的写法","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"CSS禅意花园","slug":"CSS禅意花园","date":"2018-07-09T17:45:01.000Z","updated":"2018-10-12T14:47:31.242Z","comments":true,"path":"2018/07/10/CSS禅意花园/","link":"","permalink":"http://yoursite.com/2018/07/10/CSS禅意花园/","excerpt":"","text":"CSSGarden引言“CSS禅意花园”网站的超常创意让每一位访问者都惊叹不已，亘古不变的HTML文本，仅靠着数百个不同的CSS样式表，就成就了数百个风格迥异而又精彩绝伦的网页设计作品。 第二章（设计）2.1.Atlantis(亚特兰蒂斯)28-简洁的设计，统一，象征手法 视觉作品是用来交流的，一个成功的作品将传递给欣赏者用语言无法描述的信息。作者应该能够唤起某种气氛和感情，体现独特的风格，并最终引起欣赏着的共鸣。 亚特兰蒂斯是远古时期沉入到海底的一片大陆，页首锈迹斑斑的螺旋贝壳以及古典的石雕支柱都会让欣赏者陷入到对这个传说的深深回忆中，深色和黑色也营造出深海的气息。 2.2.Zunflower26-游离于光、影、形状和空间中 Zunflower的精妙之处在于，它并不是以&quot;框&quot;的形式设计的。如果仔细观察，可以看到每一栏的位置都被仔细调整过，在视觉上形成重叠的效果。这种效果表现了光和影之间、形状和空间之间的相互影响，最终成就了作者明亮积极的主色调。 2.3.Springtime(春天)83-用彩色激发情感 大家都知道，颜色可以引起人情绪的变化，红色让人容易联想到火焰或辛辣的胡椒粉，人们经常将象征着土地、大自然的棕色和褐色用于天然产品的包装上。 在春天中，冬日那单调乏味的颜色和春天万物萌发的颜色被混合在了一起，让作品的颜色选择既不显得过冷，也不显得过热。但整个设计却强烈表达出了温馨与和谐的意味，给欣赏者带来几级愉悦的感官享受。 2.4.Viridity(翠绿活力)22-在图案、材质和对比度中找到平衡 翠绿活力的色彩基调上单调的绿色，仔细观看作品，我们可能会联想到森林中长满苔藓的大地，或天鹅绒一般柔软的织物。通过使用重复的图案以及模拟的材质效果，用丰富的细节平衡了作品其他方面的简单，深沉的单一色系让作品不至于变得太过拥挤，且虽然作品中使用了繁复的图案，但大片的绿色空白区域也给眼睛留下来足够的休息空间。 2.5.Ballade(叙述曲)68-用想象创造视觉流向并引导视线 叙述曲是为了让人们沉思，在花园中来了一次精神上的散步，想象在花园中自由飞驰，一路上遇到了很多具有象征性的东西：一段楼梯、一座小桥、一只闲逛的毛。 2.6.Night Drive64-将网站设计变为代码，并解决转换过程中遇到的问题 深颜色确定了作品模糊、温暖的基调，文本和图像所使用的深橙色以及零星点缀的亮橙色平衡了作品的色调，让作品不至于显得过于沉闷，散布在作品各处的淡蓝色小块同样起到了很好的补充作用，表现朴素安静的同时也避免显得过于单调。 第三章3.1.Backyard(庭院)29-理解绝对定位和浮动 实现三栏布局效果 3.2.Entomology(昆虫学)30-当代Web设计中的居中布局 固定布局的合理使用 3.3.White Lily(白百何)36-创建有效布局的法则与步骤 作品应该给人以放松、平静的类似植物一般的平和感觉。 设计布局，应该有效地组织内容。 3.4.pret-a-porter37-在垂直的世界中使用水平布局 人的外形总会在艺术中占有相当的地位，美术专业的学生都会在人体上花费很多时间，学习如何把握人体的轮廓、面孔的线条以及不同人之间截然不同的气质。pret-a-porter就将大自然和人体完美地结合了起来，加上其一反常态的布局，更让整个作品显得独具匠心。 3.5.CS(S) Monk70-含义丰富的定位，充分理解网格 CS(S) Monk让首页部分成为了作品的焦点，其他部分均围绕在其周围，并且在页面中添加了花朵图案作为装饰，令人愉悦的红色和灰色基调也让作品魅力十足。 3.6.Not So Minimal24-处理布局中的常见的溢出问题 第四章4.1.Japanese Garden96-理解图像文件格式以及优化方法 &quot;和&quot;在日语里是协调、融洽的意思，虽然大胆、生动的设计也会让作品更有吸引力，该作品表现的是一种更易理解的、全球范围内的美感，该作品的设计模式显然带有日式风格，但痕迹却不是那么明显，任何国家的浏览器都会对其产生兴趣。 4.2.Revolution!(革命)102-在CSS中为作品应用图像 图像在传达信息、营造氛围和吸引目光方面都能地道独到的作用。Revolution页面部分的那张大幅图片一下就吸引了我们的注意，这是一张从前的宣传海报，加上一些能体现历史感的图像，例如曾被浸湿的旧址等，来营造作品的整体氛围。鲜血和标语、泥土和红星这些元素组合在一起，让作品给浏览者以强大的视觉震撼，在内容区域选择了较为平静的风格，最终完成了这幅充满活力的作品。 4.3.Deco94-用最少的图像带来最大限度的视觉冲击 南部海岸的装饰艺术建筑的特写效果 4.4.No Frontiers！97-用圆角图像打破方框的束缚 流式布局：页面随浏览器窗口大小的变化而自动调整。 4.5.Coastal Breeze13-为作品创建图像，并寻找额外的素材 被称为&quot;玻璃之城&quot;的温哥华是一座繁荣的城市，坐落于加拿大西海岸的一篇高耸入云的群山脚下，几根浮木，几片贝壳，加上一些玻璃碎片等海洋相关的作品主题让城市的形象呼之欲出，若是再加上几片寿司那就再好不过了。 4.6.What Lies Beneath19-在二维平面中表现出三维的意境 第五章5.1.Oceans Apart(天水之间)85-用简单的字体造就恒久之美 Oceans Apart中绚丽的色调取材于在加州南部拍下的照片，作品中宁静优雅的色调勾勒出了引人入胜的神秘之海的意境。 秉承简约的理念，Oceans Apart不带有任何唐突和喧嚣的部分，作者剔出了作品中一切哗众取宠的元素，彰显了他所恪守的海明威式哲学。而这部作品中的美绝非来自浮华的修饰，而是源于无处不在的简约和质朴。 5.2.si644-应对字体的困扰 si6在设计的过程中采用了一种特殊的网格化布局，这种网格式的布局在作品中形成了潜在的视觉边界，从而将页面水平划分为3栏，而文字间黯淡的线条则又将左侧的标题和中部的正文区域分割成多个部分。 5.3.Release One(释放)35-适应文字大小的变化 圆形的站点Logo象征着高雅的雏菊，再配以明亮的绿色和橙色作为前景和柔和的灰色调背景，最终营造出一种独特的设计风格。 5.4.Dead or Alive(生与死)9-设计优雅、带有&quot;重力感&quot;的文字 该作品的创意是将西方古朴的风格和日本武士道相结合，营造出令人着迷的历史反差感。为了引入西方古典派的主题，作者使用了带有强烈西方风格的字体，并加以额外的润饰，最终完成的作品同时具有东西方双重风格，给人们带来了深刻的视觉印象。 5.5.Blood Lust(血色欲望)5-探索文本样式的各种选项 在设计的过程中，作者将他收藏的图片依次排布于多个图层中，形成了富有怀旧效果的丝质套印背景，而背景上使用了黑、红、白三种色彩的组合，并没有太多的其他颜色，此外为了增强锐化效果，作者避免了一切柔化操作，而是使用GIF抖动图样替代，这也为作品增添了一丝现代气息。 5.6.Golden Mean(黄金平衡)17-将方法和创意结合起来创造文字排印的平衡 第六章6.1.This is Cereal57-级联和分层效果 高级浏览器和低级浏览器不兼容的情况 6.2.Gemination(双子座)62-基于同一样式表的两种设计 Gemination用一张样式表表现两种迥异风格的作品 6.3.Bonsai Sky(盆景天空)69-用富有创造性的图像和代码突破浏览器的限制 为了将&quot;启蒙、开导&quot;的主题推向一个新的高度，作者在Bonsai Sky作品中把禅意花园修建在了无涯的天际。作者以山石嶙峋的峭壁为页面核心，加上树木的点缀，最终完成了这部具有挑战性的作品。 作者将悬崖置于页面的右上方，再加上淡出的效果，从而和左端的文字天衣无缝地衔接了起来。 文字部分则使用了宽大的字符间距，逐渐地把浏览者引向了悬崖深处，在挺拔的峭壁上镌刻上游各种浏览器的标志，悬崖上还有一个登山者俯正瞰着深渊。 6.4.Tulipe(郁金香)88-为IE提供了后备选项的CSS下拉菜单。 一枝凋落了一叶花瓣的郁金香随风飘曳，勾起了作者的无限遐思，作者使用了通贯全页的横向布局，缀以页面上端的下拉菜单，再配用唯美的色调。 6.5.door to my garden(花园之门)41-用简单的CSS实现完善、震撼的视觉效果 6.6.Elastic Lawn(绿草如茵)63-处理视觉效果问题有时并非那么简单 第七章7.1.Hedges(树篱)31-让任意的前景都能与背景图像完美融合 作者抛开围绕植物的传统手法，设计出了具有卡通风格的&quot;田园风光&quot;，将自己装扮成手推小车的园丁，加之各种有趣的卡通元素的妆点，最终让他的花园充满着亮丽的色彩。 7.2.Radio Zen58-用固定的背景图像实现类似收音机频道调节器的效果 作者从他的老式收音机中获得了作品的灵感，通过使用固定背景图像，他模拟出了带有活动指针的频道调节器效果，由于页首的位置需要改变，且指针也要能够水平移动，所以采用了水平滚动布局。 7.3.South of the Border(南部边境)93-用外边距和定位体现框架之感 7.4.Corporate ZenWorks95-从竞争到和谐 从一封信开始，讲述一个故事 7.5.Open Window(敞开窗口)90-同一设计，三种布局 CSS hack 7.6.mnemonic(记忆)25-流式布局和高级效果的技巧","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"禅意花园","slug":"禅意花园","permalink":"http://yoursite.com/tags/禅意花园/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"less的基本使用","slug":"less的使用基本语法","date":"2018-07-09T09:23:16.000Z","updated":"2018-10-12T14:46:45.627Z","comments":true,"path":"2018/07/09/less的使用基本语法/","link":"","permalink":"http://yoursite.com/2018/07/09/less的使用基本语法/","excerpt":"","text":"1.demo.less1234567891011121314151617/*LESS的形式*/.content &#123; ul &#123; list-style: none; &#125; li &#123; height: 25px; line-height: 25px; padding-left: 35px; background: url(../image/hot.gif) no-repeat center left; a &#123; text-decoration: none; color: #535353; font-family: &quot;microsoft yahei&quot;; &#125; &#125;&#125; 2.variables.less2.1.普通的变量123456789101112@green:green;@white:white;header&#123; background-color: @green; h1&#123; color: @white; &#125;&#125;footer&#123; background-color: @green; color: @white;&#125; 2.2.作为选择器和属性名123456@width:width;.@&#123;width&#125;&#123; @&#123;width&#125;:150px; height: 60px;&#125; 2.3.作为URL123456@Imgurl:&quot;http://seopic.699pic.com/&quot;;body&#123; background-image: url(&quot;@&#123;Imgurl&#125;photo/50056/3725.jpg_wh1200.jpg&quot;); background-repeat:no-repeat; width:200px;&#125; 2.4.延迟加载 变量是延迟加载的，在使用前不一定要预先声明，可以先使用后定义 定义多个相同名称的变量时，只会使用最后定义的变量，Less会从当前作用域中向上搜索，这个行为类似于CSS的定义中始终使用最后定义的属性值。 12345678910111213@var:0;.class&#123; @var:1; .brass&#123; @var:2; three:@var; //three的值为3 @var:3; &#125; one:@var; //跳出.bress,one的值为1// two:@var;// @var:aaa;//注意：只能在它的作用域范围找，&#125; 3.mixins1.less3.1.普通混合混合就是一种将一系列属性从一个规则集引入(&#39;混合&#39;)到另一个规则集的方式 1234567891011121314.font_hn &#123; color: red; font-family: &quot;仿宋&quot;;&#125;.p1 &#123; font-size: 28px; .font_hn;&#125;.p2 &#123; font-size: 24px; .font_hn;&#125; 3.2.不带输出的混合 如果你想要创建一个混合集，但是却不想让它输出到你的样式中 在不想输出的混合集的名字后面加上一个括号，就可以实现 1234567891011121314.font_hn() &#123; color: red; font-family: &quot;仿宋&quot;;&#125;.p1 &#123; font-size: 28px; .font_hn;&#125;.p2 &#123; font-size: 24px; .font_hn;&#125; 3.3.带选择器的混合123456789101112131415.my-hover-mixin() &#123; &amp;:hover &#123; //&amp;：代表父级 border: 1px solid red; &#125; //&amp;:hover=.my-hover-mixin:hover&#125;button &#123; .my-hover-mixin();&#125;a &#123; .my-hover-mixin();&#125; 3.4.带参数的混合123456789.border1(@color) &#123; border: 1px solid @color;&#125;h1 &#123; &amp;:hover &#123; .border1(green); //一定要有参数，不然会报错 &#125;&#125; 3.5.带参数并且有默认值12345678.border2(@color:red) &#123; border: 1px solid @color;&#125;h6 &#123; &amp;:hover &#123; .border2(); &#125;&#125; 3.6.当有默认参数的时候，如果..border()有参数，并不会报错，会执行默认的参数12345h6 &#123; &amp;:hover &#123; .border2(pink); &#125;&#125; 3.7..border()有参数时，会执行参数里面的值4.mixins2.less4.1.带多个参数的混合 参数以分号或逗号分隔，建议使用分号。 符号逗号具有双重含义：它可以解释为混合参数分隔符或CSS列表分隔符。 1234567891011121314151617.mixin1(@color;@padding:xxx;@margin:2)&#123; color-3:@color; padding-3:@padding ; margin: @margin@margin@margin@margin;&#125;.divmaizi1&#123; .mixin1(red;)&#125;.maizi1&#123; .mixin1(1,2,3;something,else;132); //一个分号结束为一个参数，【以分号为分隔符】&#125;.div1&#123; .mixin1(1,2,3); //若没有分号，只有逗号，括号里面的所有参数则分别代表不同的值，【以逗号为分隔符】&#125;.div2&#123; .mixin1(1,2,3;); //若既有分号又有逗号，分号前的所有参数只分别代表1个整体参数，【以分号为分隔符】&#125; 4.2.定义多个具有相同名称和参数数量的混合 定义多个具有相同名称和参数数量的mixin是合法的，Less会使用它可以应用的属性。 如果使用mixin的时候只带一个参数，这个属性会导致所有的mixin。 123456789101112131415.mixin2(@color)&#123; color-1:@color ;&#125;.mixin2(@color;@padding:2)&#123; color-2: @color; padding-2:@padding ;&#125;.mixin2(@color;@padding;@margin:2)&#123; color-3:@color ; padding-3:@padding ; margin:@margin@margin@margin@margin;&#125;.some .selector div&#123; .mixin2(#008000);&#125; 4.3.命名参数 mixin参考可以通过名称而不是位置来提供参数值。任何参数都可以通过其名称来引用，而且它们不必按照任何特殊顺序进行引用 1234567891011121314.mixin3(@color:black;@margin:10px;@padding:20px)&#123; color: @color; margin: @margin; padding: @padding;&#125;.class1&#123; .mixin3(@margin:20px;@color:#33acfe);&#125;.class2&#123; .mixin3(#efca44;@padding:40px;);&#125;.class3&#123; .mixin3(@padding:20px;)&#125; 4.4.arguments变量 @arguments代表所有可变的参数，参数的项先后顺序就是你的()括号内的参数的先后顺序。 在使用赋值时：值的位置和个数也是一一对应的。 若只有一个值：把值赋值给第一个； 若有两个值：把值赋给第一个参数和第二个参数……以此类推。 123456.border1(@x:solid,@c:red)&#123; border:21px @arguments;&#125;.div3&#123; .border1(solid);&#125; 4.5.匹配模式：传值的时候定义一个字符，在使用的时候使用哪个字符，就调用哪条规则。123456789101112131415.border2(all,@w:10px)&#123; border-radius: @w;&#125;.border2(t_l,@w:10px)&#123; border-top-left-radius: @w;&#125;.border2(t_r,@w:10px)&#123; border-top-right-radius: @w;&#125;.border2(b_l,@w:10px)&#123; border-bottom-left-radius: @w;&#125;.border2(b_r,@w:10px)&#123; border-bottom-right-radius: @w;&#125; 4.6.可以传参数，也可以不传参数123456789101112131415161718button&#123; .border2(all);&#125;button&#123; .border2(all,5px);&#125;button&#123; .border2(t_l,5px);&#125;button&#123; .border2(t_r,5px);&#125;button&#123; .border2(b_l,5px);&#125;button&#123; .border2(b_r,5px);&#125; 4.7.得到混合中变量的返回值123456789.average(@x,@y)&#123; @average:((@x+@y)/2); @add:(@x+@y);&#125;div&#123; .average(16px,50px); padding: @average; margin: @add;&#125; 5.nested-rules.less5.1.嵌套规则嵌套规则模仿了HTML的结构，让我们的css代码更加简洁明了，清晰。 传统的写法 1234567891011121314//header&#123;// width:960px;// background-color: cornsilk;//&#125;//header p&#123;// font-size: 26px;// color:#535353;// font-family: &quot;仿宋&quot;;//&#125;//header .logo&#123;// width: 200px;// height: 200px;// border:2px solid #008000;//&#125; LESS写法 1234567891011121314header &#123; width: 960px; background-color: cornsilk; p &#123; font-size: 26px; color: #535353; font-family: &quot;仿宋&quot;; &#125; .logo &#123; width: 200px; height: 200px; border: 2px solid #008000; &#125;&#125; 5.2.父元素选择器：&amp;表示当前选择器的所有父选择器 传统的写法 123456789//header .logo&#123;// width: 200px;// height: 200px;// border:2px solid #008000;//&#125;//header .logo:hover&#123;// background-color: #EFCA44;////&#125; LESS写法 1234567891011121314151617header &#123; width: 960px; background-color: cornsilk; p &#123; font-size: 26px; color: #535353; font-family: &quot;仿宋&quot;; &#125; .logo &#123; width: 200px; height: 200px; border: 2px solid #008000; &amp;:hover&#123; //&amp;符号代表它的所有的父元素选择器 background-color: coral; &#125; &#125;&#125; 5.3.改变选择器的顺序将&amp;放到当前选择器之后，就会把当前选择器插入到所有的父选择器之前 1234567891011121314.a&#123; .b&#123; &amp;.c&#123; //选择当前的选择器 ,选择器顺序为.a .b .c color:bisque; &#125; &#125;&#125;.a&#123; .b&#123; .c &amp;&#123; //C的选择器将会被提到所有的父选择器之前.c .a .b color:bisque; &#125; &#125;&#125; 5.4.组合使用生成所有可能的选择器列表 [&amp; &amp;](表示两个组合)，要有一个空格 [&amp; &amp; &amp;](表示三个组合) [&amp; &amp; &amp; &amp;](表示四个组合) ……以此类推。 1234567891011121314151617p,a,ul,li&#123; border-top: 2px dotted #366; &amp;&#123; //当有一个&amp;时，表示选择当前的选择器 border-top: 0; &#125;&#125;p,a,ul,li&#123; border-top: 2px dotted #366; &amp; &amp;&#123; //当有两个&amp;&amp;时，表示混合所有的选择器 border-top: 0; &#125;&#125;a,b,c&#123; &amp; &amp;&#123; color:aqua; &#125;&#125; 6.operation.less6.1.运算说明 任何数值、颜色和变量都可以进行运算 LESS会为你自动推断数值的单位，所以你不必为每一个值都加上运算 运算符与值之间必须以空格分开，涉及优先级时以0进行优先级运算 123456//.wp&#123;// margin: 0 auto;// background-color: #FFC0CB;// width: 450px+450;// height: 400+400px;//&#125; 6.2.数值型运算：优先级运算[使用括号区分优先级]123456//.wp&#123;// margin: 0 auto;// background-color: #FFC0CB;// width:(550-50)*2px ;// height: 400+400px;//&#125; 6.3.颜色值运算：先将颜色值转换为rgb模式,然后再转换为16进制的颜色值并且返回12345678910.wp&#123; margin: 0 auto; width:(550-50)*2px ; height: 400+400px; background-color:#000000+21; //rgb(0,0,0)+21 =rgb(21,21,21) =#151515 //rgb模式的取值范围是(0~255，0~255，0~255)， //当你加的值超过了255之后，还是会按照最大值255来计算 //不能直接使用颜色的英文名称来进行运算(例如用red+21)&#125; 7.Function.lessLESS中提供了转换颜色、处理字符串和进行算术运算的函数。 7.1.rgb()函数：将rgb函数的值转换为16进制的值123.bgcolor&#123; background-color:rgb(255,0,0); //#ff0000&#125; 7.2.提取颜色值的函数[blue]|[red]|[green]，提取的是rgb模式的颜色值1234.bgcolor1&#123; z-index: blue(#5c7abd); //提取蓝色的值 border: red(#565656);//提取红色的值&#125; 8.命名空间123456789101112131415161718192021222324252627#bgcolor()&#123; background-color: #FFFFFF; .a&#123; color:#888888; &amp;:hover&#123; color:#ff6600; &#125; .b&#123; background-color: #ff0000; &#125; &#125;&#125;.wi&#123; background-color: #008000; color:#fff; .a&#123; color: #008000; background-color: #FFFFFF; &#125;&#125;.bgcolor1&#123; background-color: #fdfeeo; #bgcolor&gt;.a;&#125;.bgcolor2&#123; .wi&gt;.a;&#125; 9.作用域LESS中的作用域与编程语言中的作用域概念非常相似，首先会在局部查找变量和混合，如果没有找到，编译器就会在父作用域中查找，以此类推。 1234567891011121314151617@color:#fff;.bgcolor&#123; width:50px; a&#123; color: @color; &#125; @color:#ff0000;&#125;@color:#fff;.bgcolor1&#123; width:50px; a&#123; @color:green; color: @color; &#125; @color:#ff0000;&#125; 10.import.less10.1.可以引入一个或者多个less文件，然后这个文件中的所有变量都可以在当前的less项目中使用12345@import &quot;main.less&quot;;.content&#123; width: @wp; height: @wp;&#125; 10.2.引入CSS文件会被原样输出到编译的文件中@import &quot;index.css&quot;; 10.3.可带参数: once[默认、使用一次] reference[使用LESS文件但不输出] inline[在输出中包含源文件但不加工它] less[将作为LESS文件对象，无论是什么文件扩展名] css[将作为CSS文件对象，无论是什么文件扩展名] multiple[mutiple] 11.important.less在调用的混合集后面追加!important关键字，可以使混合集里面的所有属性都继承!important。 123456789101112.foo(@bg:#515151,@color:#900)&#123; background-color: @bg; color: @color; font-size: 16px; font-weight: 900;&#125;.unimport&#123; .foo();&#125;.important&#123; .foo()!important;&#125; 12.条件表达式12.1.带条件的混合123456789101112131415.mixin(@a)when(lightness(@a)&gt;=50%)&#123; //lightness:取颜色值亮度的函数,取值为0~100% background-color: black;&#125;.mixin(@a)when(lightness(@a)&lt;50%)&#123; //rgb模式中最大的取值为255，除以2为175.5,我们可以粗略的认为: background-color: white; //当a的值大于175.5时为亮色，a的值小于175.5时为暗色。&#125;.mixin(@a)&#123; color:@a;&#125;.class1&#123; .mixin(#ddd);//211&gt;175.5&gt;50%,显示的背景颜色为黑色&#125;.class2&#123; .mixin(#555); //85&lt;175.5&lt;50%,显示的背景颜色为白色&#125; 12.2.类型检查函数：可以基于值的类型来匹配函数 [iscolor]: [isnumber]: [isstring]: [iskeyword]: [isurl]: 12.3.单位检查函数:检查一个值除了数字是否是一个特定的单位 [ispixel]：px [ispercentage]:百分比 [isem]:厘米 [isunit]:单元 13.loop循环12345678910111213141516171819202122232425262728//.loop(@counter)when(@counter&gt;0)&#123;// .loop((@counter)-1); //递归调用自身4 3 2 1 0// width: (10px*@counter);//每次调用时产生的样式代码 50px 40px 30px 20px 10px//&#125;////div&#123;// .loop(5); //调用循环//&#125;//.loop(@counter)when(@counter&gt;0)&#123;// h@&#123;counter&#125;&#123;// padding: (10px*@counter);// &#125;//每次调用时产生的代码样式// .loop((@counter)-1); //递归调用自身//&#125;//div1&#123;// .loop(6); //调用循环//&#125;.loop(@counter)when(@counter&lt;=6)&#123; h@&#123;counter&#125;&#123; padding: (10px*@counter); &#125;//每次调用时产生的代码样式 .loop((@counter)+1); //递归调用自身&#125;div1&#123; .loop(1); //调用循环&#125; 14.合并属性14.1.在需要合并的属性的:的前面加上&quot;+&quot;就可以完成合并，合并时以&quot;,&quot;逗号分割属性。1234567//.mixin()&#123;// box-shadow+: inset 0 0 10px #555;//&#125;//.myclass&#123;// .mixin();// box-shadow+: 0 0 20px black;//&#125; 14.2.在需要合并的属性的:的前面加上”+_&quot;就可以完成合并，合并时以&quot; &quot;空格分割属性。1234567.a()&#123; background-color+_: #f60; background-image+_:url(../image/black.png);&#125;.myclass&#123; .a();&#125; 15.function15.1.其他函数15.2.字符串函数15.3.长度相关函数15.4.数字函数15.5.类型函数15.6.颜色值定义函数15.7.颜色值通道提取函数12345678body&#123;//background:color();background:url(../image/yinghua.jpg);default();unite();e();escape();&#125; main.less @wp:960px;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Less","slug":"Less","permalink":"http://yoursite.com/tags/Less/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"IE浏览器和标准浏览器的兼容性问题","slug":"IE浏览器和标准浏览器的兼容性问题","date":"2018-07-06T06:43:31.000Z","updated":"2018-10-12T14:47:21.811Z","comments":true,"path":"2018/07/06/IE浏览器和标准浏览器的兼容性问题/","link":"","permalink":"http://yoursite.com/2018/07/06/IE浏览器和标准浏览器的兼容性问题/","excerpt":"","text":"1、document.formName.item(&quot;itemName&quot;)IE浏览器：可以使用document.formName.item(&quot;itemName&quot;)或document.formName.elements[&quot;elementName&quot;]; 标准浏览器：只能使用document.formName.elements[&quot;elementName&quot;]。 解决方法：统一使用document.formName.elements[&quot;elementName&quot;]。 2、HTML对象获取问题 标准浏览器：可以使用document.getElementById(&quot;idName&quot;) IE浏览器使用document.idname或者document.getElementById(&quot;idName&quot;) 解决办法：统一使用document.getElementById(&quot;idName&quot;); 3、事件委托方法 IE浏览器：使用document.body.onload = inject;其中function inject()在这之前已被实现,在这里只是调用一下; 标准浏览器：使用document.body.onload = inject(); 解决方法：统一使用document.body.onload=new Function(&#39;inject()&#39;); 或者document.body.onload = function(){} 4、集合类对象 IE浏览器：可以使用()或[]获取集合类对象； 标准浏览器：只能使用[ ]获取集合类对象。 解决方法：统一使用[]获取集合类对象。 5、自定义属性问题 IE浏览器：可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性 标准浏览器：只能使用getAttribute()获取自定义属性。 解决方法：统一通过getAttribute()获取自定义属性，使用”.”点运算符访问更加方便。 6、eval(&quot;idName&quot;)问题 IE浏览器：可以使用eval(&quot;idName&quot;)或getElementById(&quot;idName&quot;)来取得id为idName的HTML对象 标准浏览器：只能使用getElementById(&quot;idName&quot;)来取得id为idName的HTML对象。 解决方法：统一用getElementById(&quot;idName&quot;)来取得id为idName的HTML对象。 7、变量名与某HTML对象ID相同的问题 IE浏览器：HTML对象的ID可以作为document的下属对象变量名直接使用;标准浏览器只能通过getElementById获取HTML5对象的ID值. 标准浏览器：可以使用与HTML对象ID相同的变量名;IE浏览器下则不能。 解决方法：使用document.getElementById(&quot;idName&quot;)代替document.idName，并且最好不要取HTML对象ID相同的变量名，以减少错误;在声明变量时，一律加上var,以避免歧义。 8、const问题 标准浏览器：可以使用const关键字或var关键字来定义常量。 IE浏览器：只能使用var关键字来定义常量。 解决方法：统一使用var关键字来定义常量。 9、input.type属性问题 IE浏览器：input.type属性为只读 标准浏览器：input.type属性为可读可写。 解决方法：可以分别创建输入框，让输入框尽可能只展现可读属性，尽量隐藏它的可写属性，因为IE浏览器浏览器不支持，想通过把type为password的值改为text，IE浏览器下是不允许的。 10、window.event问题 window.event只能在IE浏览器下运行，而不能在标准浏览器下运行,这是因为标准浏览器的event只能在事件发生的现场使用。标准浏览器必须从源处加入event作参数传递。IE浏览器忽略该参数，用window.event来读取该event。 解决方法： var e = e || window.event 举例：在IE浏览器下获得鼠标位置的方法 12345678&lt;script&gt;&lt;button&gt;获得鼠标点击横坐标&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn=document.getElementsByTagName(&quot;button&quot;); btn.onclick=function()&#123; alert(event.clientX); &#125;&lt;/script&gt; 兼容式的获得鼠标位置的方法 123456789&lt;script&gt;&lt;button&gt;获得鼠标点击横坐标&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; var btn=document.getElementsByTagName(\"button\"); btn.onclick=function(event)&#123; event = event || window.event; alert(event.clientX); &#125;&lt;/script&gt; 11、event.x与event.y问题 IE浏览器：even对象有x,y属性,但是没有pageX，pageY属性 标准浏览器：even对象有pageX，pageY属性，但是没有x,y属性。 解决方法：使用var x = e.x ? e.x : e.pageX;来代替IE浏览器下的event.x或者标准浏览器下的e.pageX； 12、event.srcElement问题 IE浏览器：event对象有srcElement属性,但是没有target属性; 标准浏览器：even对象有target属性,但是没有srcElement属性。 解决方法：使用obj(obj = event.srcElement ? event.srcElement : event.target;)来代替IE浏览器下的event.srcElement或者标准浏览器下的event.target，请同时注意event的兼容性问题(第10个)。 13、window.location.href问题 IE浏览器或者标准浏览器较高版本：可以使用window.location或window.location.href； 标准浏览器旧版本：只能使用window.location。 解决方法：使用window.location来代替window.location.href。 14、模态和非模态窗口问题 IE浏览器：可以通过showModalDialog和showModelessDialog打开模态和非模态窗口，标准浏览器下则不能。 解决方法：直接使用window.open(pageURL,name,parameters)方式打开新窗口。 如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。如果需要父窗口控制子窗口的话，使用var subWindow = window.open(pageURL,name,parameters); 来获得新开的窗口对象。 如果需要将frame中的参数传回父窗口，可以在frame中使用parent关键字来访问父窗口。 15、body载入问题 标准浏览器：body在body标签没有被浏览器完全读入之前就存在 IE浏览器：body必须在body标签被浏览器完全读入之后才存在 16、table操作问题 IE浏览器和标准浏览器对于&lt;table&gt;标签的操作都各不相同， IE浏览器中不允许对&lt;table&gt;标签和&lt;tr&gt;的innerHTML赋值，并且如果js增加一个tr时不支持使用appendChild方法。 标准浏览器：支持：document.appendChild方法 解决办法：把行插入到TBODY中，不要直接插入到表 123456//向table追加一个空行：var row = otable.insertRow(-1);var cell = document.createElement(&quot;td&quot;);cell.innerHTML = &quot;&quot;;cell.className = &quot;XXXX&quot;;row.appendChild(cell); 17、获取table的行数和列数 在IE中，获取行列数可以使用下面的代码： 12345var detailT= grid.gettable(\"11\"); //获取行的长度 var r=detailT.rows.length; //获取列的长度 var l=detailT.cells.length; 毫无疑问，在标准的浏览器，这样的方式获取列的长度就是无效的。 解决方案： 123456var detailT= grid.gettable(\"11\");//获取行的长度var r=detailT.rows.length;//获取列的长度var l=detailT.rows[0].cells.length; 18、访问父元素的区别 IE浏览器：支持parentElement和parentNode获取父节点， 标准浏览器：只支持parentNode。 解决方法：因为firefox与IE都支持DOM，因此全部使用obj.parentNode; 19、children与childNodes 标准浏览器：childNodes会把换行和空白字符都算作父节点的子节点。 IE浏览器：childNodes和`children不会把换行和空白字符都算作父节点的子节点，会直接忽略。 举例： 123&lt;div id=\"dd\"&gt; &lt;div&gt;yizhu2000&lt;/div&gt;&lt;/div&gt; ID值为dd的div在IE浏览器用childNodes查看，其子节点数为1，而在标准浏览器其子节点数为3，我们可以从标准浏览器的dom查看器里面看到他的childNodes为[&quot;\\n &quot;, div, &quot;\\n&quot;]。 解决办法： 123456789101112131415161718if (typeof(HTMLElement) != \"undefined\" &amp;&amp; !window.opera) &#123; HTMLElement.prototype.__defineGetter__(\"children\", function() &#123; for (var a = [], j = 0, n, i = 0; i &lt; this.childNodes.length; i++) &#123; n = this.childNodes[i]; if (n.nodeType == 1) &#123; a[j++] = n; if (n.name) &#123; if (!a[n.name]) a[n.name] = []; a[n.name][a[n.name].length] = n; &#125; if (n.id) a[n.id] = n; &#125; &#125; return a; &#125;); &#125; 20、对象宽高赋值问题 标准浏览器中类似 obj.style.height = imgObj.height 的语句无效。 解决方法：统一使用 obj.style.height = imgObj.height + &#39;px&#39;; 21、setAttribute(&#39;style&#39;,&#39;color:red;&#39;) 标准浏览器：支持setAttribute(&#39;style&#39;,&#39;color:red;&#39;) IE浏览器：不支持setAttribute(&#39;style&#39;,&#39;color:red;&#39;) 解决方法：使用object.style.cssText = ‘color:red;&#39; 22、类名设置setAttribute(&#39;class&#39;,&#39;styleClass&#39;) 标准浏览器：支持setAttribute(&#39;style&#39;,&#39;color:red;&#39;)，指定属性名为class。 IE浏览器：不支持setAttribute(&#39;style&#39;,&#39;color:red;&#39;) ，IE浏览器不会设置元素的class属性，相反只使用setAttribute时IE获取className属性。 解决方法： 12345setAttribute('class','styleClass') setAttribute('className','styleClass') 或者直接 object.className='styleClass'; IE浏览器和标准浏览器都支持object.className。 23、用setAttribute设置事件 标准浏览器：支持用setAttribute设置事件 举例： 12var obj = document.getElementById('objId'); obj.setAttribute('onclick','funcitonname();'); IE浏览器：不支持用setAttribute设置事件 解决办法：IE浏览器中必须用点记法来引用所需的事件处理程序,并且要用赋予匿名函数 举例： 12var obj = document.getElementById('objId'); obj.onclick=function()&#123;fucntionname();&#125;; 这种形式所有浏览器都支持，不存在兼容性问题。 24、innerText问题 IE浏览器：支持innerText 标准浏览器：不支持innerText，但是支持textContent。 解决方法：elem.innerText = elem.textContent = &quot;值&quot; 举例： 12345if (navigator.appName.indexOf(\"Explorer\") &gt; -1) &#123;document.getElementById('element').innerText = \"my text\";&#125; else &#123;document.getElementById('element').textContent = \"my text\";&#125; 25、样式关键字冲突问题 CSS属性与Javascript中的保留关键字命名相同，IE浏览器中style+属性，标准浏览器中css+属性。 26、removeChild和removeNode的问题 IE浏览器：支持appendNode和removeNode。 标准浏览器：支持removeChild。 27、事件监听函数的问题 标准浏览器的写法：addEventListener() IE浏览器的写法：attachEvent() 解决方法：判断addEventListener是否存在，如果存在则用否则用IE浏览器8以下的版本的绑定方法attachEvent，removeEventListener()和detachEvent()也是一样的用法。 28、AJAX获取XMLHTTP的区别 IE浏览器：用window.ActiveXObject获取XMLHTTP 标准浏览器：用window.XMLHttpRequest获取XMLHTTP 解决办法： 123456var xhr; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; elseif (window.ActiveXObject) &#123; // IE的获取方式 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; 29、阻止事件冒泡 标准浏览器：stopPropagation() IE浏览器：cancelBubble 解决方法：判断stopPropagation是否存在，如果存在则用标准写法否则则用IE浏览器的写法。 30、阻止默认事件 标准浏览器：preventDefault() IE浏览器：returnValue() 解决方法：一般情况可以直接使用return false阻止，虽然可以达到相同的效果，但和取消默认事件的意义并不是相同的 31、css()方法可以获取指定元素集合中第一个元素的样式属性的计算值。 标准浏览器：通过的 getComputedStyle()方法取得某些属性 IE浏览器：通过currentStyle和runtimeStyle属性取得某些特定的属性 32、float属性 IE浏览器的DOM 将float属性写成styleFloat实现， 标准浏览器将float 属性写成cssFloat。 解决方法：使用&quot;float&quot;，那就需要引入jQuery库，jQuery将为每个浏览器返回它需要的正确值。 33、frame问题 &lt;frame src=&quot;xxx.html&quot; id=&quot;frameId&quot; name=&quot;frameName&quot; /&gt; 访问frame对象 IE浏览器：使用window.frameId或者window.frameName来访问这个frame对象，frameId和frameName可以同名; 标准浏览器：只能使用window.frameName来访问这个frame对象； 在IE浏览器和标准浏览器中都可以使用window.document.getElementById(&quot;frameId&quot;)来访问这个frame对象； 切换frame内容 在IE浏览器和标准浏览器中都可以使用下面的方式来切换frame的内容； 12345window.document.getElementById(\"testFrame\").src = \"xxx.html\"或window.frameName.location = \"xxx.html\" 34、建立单选钮 标准浏览器： 1234var rdo = document.createElement(&apos;input&apos;); rdo.setAttribute(&apos;type&apos;,&apos;radio&apos;); rdo.setAttribute(&apos;name&apos;,&apos;radiobtn&apos;); rdo.setAttribute(&apos;value&apos;,&apos;checked&apos;); IE浏览器： 1var rdo =document.createElement(”&lt;input name=”radiobtn” type=”radio” value=”checked” /&gt;”); 这一点区别和前面的都不一样。这次完全不同，所以找不到共同的办法来解决，那么只有IF-ELSE了万幸的是，IE可以识别出document的uniqueID属性，别的浏览器都不可以识别出这一属性","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"浏览器兼容性","slug":"浏览器兼容性","permalink":"http://yoursite.com/tags/浏览器兼容性/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javaScript客户端与服务器端的五种通信方式","slug":"javaScript客户端与服务器端的五种通信方式","date":"2018-07-04T02:06:12.000Z","updated":"2018-10-12T14:47:19.391Z","comments":true,"path":"2018/07/04/javaScript客户端与服务器端的五种通信方式/","link":"","permalink":"http://yoursite.com/2018/07/04/javaScript客户端与服务器端的五种通信方式/","excerpt":"","text":"在Web项目中，要实现客户端与服务端的交互，可通过cookie、隐藏框架、使用iframe、HTTP请求、LiveConnect请求和智能HTTP请求等方式实现。下面我就来一一的说下。 一、cookie cookie是第一个JavaScript可以利用的客户端-服务端之间的交互手段。浏览器向服务器发送请求时，为这个服务器存储的cookie会与其他信息一起发送到服务器。这使得JavaScript可以在客户端设置一个cookie，之后服务器端就能够读取它了。 我截取了百度首页的cookie的情况，如下图。 1.cookie的成分 名称(name):每一个cookie由一个唯一的名称代表。这个名称可以包含字母、数字和下划线。不区分大小写。 值(Value):保存在cookie中的字符串值。这个值在存储之前必须用encodeURIComponent()对其进行编码，以免丢失数据或占用了cookie。名称和值加起来的字节数不能超过4095字节，也就是4KB。 encodeURIComponent():函数可把字符串作为 URI 组件进行编码。 语法：encodeURIComponent(URIstring); 参数：URIstring:必需。一个字符串，含有 URI 组件或其他要编码的文本。 123456789&lt;script type=\"text/javascript\"&gt;document.write(encodeURIComponent(\"http://www.w3school.com.cn\"))document.write(\"&lt;br /&gt;\")document.write(encodeURIComponent(\"http://www.w3school.com.cn/p 1/\"))document.write(\"&lt;br /&gt;\")document.write(encodeURIComponent(\",/?:@&amp;=+$#\"))&lt;/script&gt; 输出结果: 123http%3A%2F%2Fwww.w3school.com.cnhttp%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F%2C%2F%3F%3A%40%26%3D%2B%24%23 域(Domain):处于安全考虑，网站不能访问其他域创建的cookie。创建cookie后，域的信息会作为cookie的一部分存储起来。 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 那什么叫做跨域呢？不同地址，不同端口，不同级别，不同协议都会构成跨域。 举例： 123456789101112131415161718192021222324URL 说明 是否允许通信https://yingy0.github.io/a.jshttps://yingy0.github.io/b.js 同一域名下 允许https://yingy0.github.io/lab/a.jshttps://yingy0.github.io/script/b.js 同一域名下不同文件夹 允许https://yingy0.github.io:8000/a.jshttps://yingy0.github.io/b.js 同一域名，不同端口 不允许http://yingy0.github.io/a.jshttps://yingy0.github.io/b.js 同一域名，不同协议 不允许http://www.baidu.com/a.jshttp://119.75.217.109/b.js 域名和域名对应iphttp://www.baidu.com/a.jshttp://about.baidu.com/b.js 主域相同，子域不同 不允许http://www.baidu.com/a.jshttp://baidu.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.hao123.com/a.jshttp://www.haorooms.com/b.js 不同域名 不允许 路径(path):另一个cookie的安全特性，路径限制了对Web服务器上的特定目录的访问。 失效日期(Expires/Max-Age):确定cookie何时删除。默认情况下，关闭浏览器时，即将cookie删除，不过可以自己设置删除时间。这个值是个GMT格式的日期（可以使用Date对象的toGMTString()方法），用于制定应该删除cookie的准确时间。如果设置的日期是当前日期以前的时间，则cookie被立刻删除。 安全标志(Secure)：用于表示cookie是否只能从安全网站（使用SSL和https协议的网站）中访问。可以将这个值设为true以加强保护，进而确保cookie不被其他网站访问。 2.其他安全限制 每个域最多只能只能在一台用户的机器上存储20个cookie； 每个cookie的总尺寸不能超过4096字节； 一台用户的机器上的cookie总数不能超过30个。 3.举例: setCookie方法：给cookie属性上赋值 12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; //setCookie方法：给cookie属性上赋值 function setCookie(sName, sValue, oExpires, sPath, sDomain, bSecure) &#123; var sCookie = sName +\"=\"+encodeURIComponent(sValue); if(oExpires) &#123; sCookie += \";expires = \"+oExpires.toGMTString(); &#125; if(sPath) &#123; sCookie += \";path\" + sPath; &#125; if(sDomain) &#123; sCookie += \";domain\" + sDomain; &#125; if(bSecure) &#123; sCookie += \";secure\"; &#125; document.cookie = sCookie; &#125; //setCookie()函数只有前两个参数是必须的，函数的调用方法如下： setCookie('name', \"Asci\"); setCookie('book', 'JavaScript', new Date(Date.parse('1 10,2019'))); setCookie(\"message\", \"hello\", new Date(Date.parse('1 10,2019')), \"/books\", 'http://127.0.0.1:8020', true);&lt;/script&gt; 运行结果： 另外一种给cookie属性赋值的代码，比较简单大家可以参考着来。 12345678910&lt;script type=\"text/javascript\"&gt; function setCookie(key,value,time) &#123; var date=new Date(); date.setDate(date.getDate()+time); document.cookie=key+\"=\"+value+\";expires\"+date.toGMTString(); &#125; setCookie('username','Asci',7); setCookie('password','123456',7) &lt;/script&gt; 运行结果： 下一次打开浏览器的时候，利用getCookie()方法.可以请求上次的cookie数据 12345678910111213&lt;script type=\"text/javascript\"&gt; function getCookie(sName) &#123; var arr = document.cookie.split(\";\"); for(var i = 0; i &lt; arr.length; i++) &#123; var kv = arr[i].split('='); if(kv[0] == sName) &#123;&#125; return kv[1]; &#125; &#125; //调用该方法可以获取指定名称的cookie，调用举例如下： var sName = getCookie(\"name\"); var sName = getCookie(\"book\");&lt;/script&gt; 运行结果： 当获取到用户名和密码之后，调用ajax请求，直接可以向服务端发送请求，输入用户名和密码的过程通过自动处理从本地文件已经获取了，不需要手动输入了，表现的形式就是自动登录。 删除cookie的数据用deleteCookie()方法，只需将失效时间设为过去的一个时间即可。 123456function deleteCookie(sName, sPath, sDomain) &#123; setCookie(sName, \"\", new Date(0), sPath, sDomain);&#125; 4.JavaScript中的cookie doucment对象有个cookie特性，是包含所有给定页面可访问的cookie的字符串，cookie特性设置为新值只会改变对页面可访问的cookie，并不会真正改变cookie本身。 cookie字符串的格式： 12345678cookie_name=cookie_valueexpires=expiration_timepath=domain_pathdomain=dsecuresetCookie()函数getCookie()函数deleteCookie()函数 5.服务器端的cookie：JSP Jsp提供了非常简单的处理cookie的接口，request对象会在执行JSP时自动初始化，有一个返回一个Cookie对象数组的方getCookies()方法。每个Cookie对象都具有getName()，getPath()，getDomain()，getSecure()，getMaxAge()等方法。 举例： getCookie()方法：请求cookie的值 12345678910111213141516public static Cookie getCookie(HttpServletRequest request, String name) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (int i = 0; i&lt;cookies.length; i++) &#123; if (cookies[i].getName().equals(name)) &#123; return cookies[i]; &#125; &#125; &#125;&#125; 新建一个cookie： 1234567Cookie nameCookie = new Cookie(\"name\", \"Asci\");nameCookie.setDomain(\"https://yingy0.github.io/\");nameCookie.setPath(\"/books\");response.addCookie(nameCookie); 删除cookie： 12345Cookie cookieToDelete = getCookie(&quot;name&quot;);cookieToDelete.setMaxAge(0); //设置有效时间为0response.addCookie(cookieToDelete); 二、隐藏框架 创建一个可用JavaScript与服务器进行通信的0像素高的框架,用于处理客户端通信的JavaScript对象和在服务端处理通信的特殊页面。 方法： 123getServerInfo()：发送请求函数handleResponse()：在隐藏框架从服务器返回页面之后调用 发送请求的函数如下： 123456//向服务器发送请求function getServerInfo() &#123; parent.frames[\"hiddenFrame\"].location.href = \"hiddenFrameCom.html\";&#125; 处理回应的函数handleResponse()如下： 12345function handleResponse(sResponseTextt) &#123; alert(\"服务器返回:\" + sResponseTextt);&#125; 处理隐藏请求的页面必须输出一个普通的HTML页面，需要使用&lt;textarea/&gt;元素，方便的处理多行数据，这个页面必须在主框架中调用handleResponse()函数。 123456789101112131415161718&lt;html&gt; &lt;head&gt;&lt;title&gt; 隐藏框架的例子&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; parent.frames[0].handleResponse( document.forms[\"formResponse\"].result.value); &#125;;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;form name=\"formResponse\"&gt; &lt;textarea name=\"result\"&gt;传送回的数据&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 三、HTTP请求 现在很多浏览器都可以直接从JavaScript中初始化HTTP请求并获取结果，完全不用隐藏框架和其他取巧的小技巧。核心是，微软创建的XMLHTTP请求的对象。这个对象是与MSXML一起出现的，XMLHTTP请求实质上是添加了额外的用于发送和接收XML代码的功能的普通的HTTP请求。 在IE中重新创建XMLHTTP请求对象，需要使用ActiveXObject，如下所示： var oRequest = new ActiveXObject(&quot;&quot;); 标准浏览器创建XMLHTTP请求对象 var oRequest = new XMLHttpRequest(&quot;&quot;); 在IE浏览器中创建XMLHTTP()的方法： 1234567891011&lt;script type=\"text/javascript\"&gt;function createXMLHTTP() &#123; var arrSignatures = [\"MSXML2.XMLHTTP.5.0\", \"MSXML2.XMLHTTP.4.0\",\"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\",\"Microsoft.XMLHTTP\"]; for (var i=0; i&lt; arrSignatures.length; i++) &#123; var oRequest = new ActiveXObject(arrSignatures[i]); return oRequest; &#125; &#125;&lt;/script&gt; 创建好HTTP请求后可用open()方法来指定要发送的请求,参数如下： 第一个参数：值可为”get”或”post”，或其他受服务器支持的HTTP方法； 第二个参数：请求的URL地址; 第三个参数：表示请求是否以异步方式发送的布尔值。true表示以异步的方式，false表示以同步的方式。 举例：oRequest.open(&quot;get&quot;, &quot;example.txt&quot;, false); 打开后，可用send()方法将请求发送出去，该方法必须带一个参数，该参数一般情况下值为null。 举例:oRequest.send(null); 一个完整的栗子：创建、打开、发送(同步发送)。 12345678910111213141516171819202122 &lt;script type=\"text/javascript\"&gt; function createXMLHTTP() &#123; var arrSignatures = [\"MSXML2.XMLHTTP.5.0\", \"MSXML2.XMLHTTP.4.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\" ]; for(var i = 0; i &lt; arrSignatures.length; i++) &#123; //我在Chrome浏览器下运行，所以用的是XMLHttpRequest,IE浏览器的朋友们用的是ActiveXObject var oRequest = new XMLHttpRequest(arrSignatures[i]); return oRequest; &#125; &#125; var oRequest = createXMLHTTP(); oRequest.open(\"get\", \"example.txt\", false); //以同步的方式发送数据 oRequest.send(null); console.log(\"状态:\" + oRequest.status + \"(\" + oRequest.statusText + \")\"); console.log(\"回应的文本信息:\" + oRequest.responseText); &lt;/script&gt; 结果会获取服务器端的一个纯文本文件(example.txt)，也就是说以同步的方式请求该txt文件，然后在浏览器中显示此内容。如果使用同步调用（第三个参数为false），则JavaScript解释程序就会等待请求返回,返回响应后，status特性中会放入请求的HTTP状态，同时在statuesText特性中放入描述状态的信息，在responseText特性放入服务器上接收到的文本。 运行结果： 如果发送异步请求，必须使用onreadystatechange事件处理函数，并检查readyState特性是否等于4。 举例： 1234567891011121314151617181920212223242526 &lt;script type=\"text/javascript\"&gt; function createXMLHTTP() &#123; var arrSignatures = [\"MSXML2.XMLHTTP.5.0\", \"MSXML2.XMLHTTP.4.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\" ]; for(var i = 0; i &lt; arrSignatures.length; i++) &#123; var oRequest = new XMLHttpRequest(arrSignatures[i]); return oRequest; &#125; &#125; var oRequest = createXMLHTTP(); oRequest.open(\"get\", \"example.txt\", true); //以异步的方式发送数据 oRequest.onreadystatechange = function() &#123; if(oRequest.readyState == 4) &#123; console.log(\"状态:\" + oRequest.status + \"(\" + oRequest.statusText + \")\"); console.log(\"回应的文本信息:\" + oRequest.responseText); &#125;&#125; oRequest.send(null); &lt;/script&gt; 运行结果： 1.使用HTTP头部 每个HTTP请求发送时都包含一组带有额外信息的首部，在XML HTTP请求对象提供了获取和设置它们的方法 getAllResponseHeaders()：返回包含所有响应的HTTP首部信息的字符串； getResponseHeader()：获取指定的某个头部，参数为获取的首部的名称， var sValue = oRequest.getResponseHeader(&quot;Server&quot;); setResponseHeader()：设置XML HTTP请求的首部信息， oRequest. setResponseHeader(&quot;myheader&quot;, &quot;Asci&quot;); 2.实现的复制品 Mozilla第一个复制了XMLHTTP实现，创建了名为XMLHTTPRequest的JavaScript，行为完全与微软的版本相同，Opera(7.6)和Safari（1.2）也复制了Mozilla的实现，创建了自己的XMLHTTPRequest对象。 3.进行GET请求 Web上最常见的请求类型就是GET请求，每次在浏览器中输入URL并打开页面时，就是像服务器发送一个GET请求,GET请求的参数就是用问号追加到URL的结尾，后面跟着用&amp;号连接起来的”名称/值”。 每个名称和值都必须在编码后才能用在URL中,在JavaScript中可以用encodeURI Component()进行编码.URL最大长度为2048字符,问号后面的内容为查询字符串，这些参数可以在服务器端的页面中读取。 要是用XMLHTTP请求对象发送一个GET请求，只需将URL(包含所有的参数)传入open()方法，同时第一个参数设为“get”,参数必须追加到URL的末尾. addURLParam()函数有三个参数: 要添加参数的URL 参数名称 参数值 首先，函数检查URL中是否已经存在一个问号（存在就表示已经有参数了）。如果没有，函数就追加一个问号，否则就追加一个&amp;号。 举例： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot;&gt; function createXMLHTTP() &#123; var arrSignatures = [&quot;MSXML2.XMLHTTP.5.0&quot;, &quot;MSXML2.XMLHTTP.4.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot; ]; for(var i = 0; i &lt; arrSignatures.length; i++) &#123; var oRequest = new XMLHttpRequest(arrSignatures[i]); return oRequest; &#125; &#125; var oRequest = createXMLHTTP(); //为了添加参数的方便性，让我们增加一个添加参数的方法，然后为请求构建一个URL地址 function addURLParam(url, sParamName, sParamValue) &#123; url += (url.indexOf(&quot; ? &quot;) == -1 ? &quot; ? &quot; : &quot; &amp; &quot;); url += encodeURIComponent(sParamName) + &quot; = &quot; + encodeURIComponent(sParamValue); return url; &#125; var url = &quot;https://yingy0.github.io/&quot;; url = addURLParam(url, &quot;gender&quot;, &quot;女&quot;); url = addURLParam(url, &quot;age&quot;, &quot;25&quot;); oRequest.open(&quot;get&quot;, url, false);&lt;/script&gt; 一般情况下，用同步的方式请求不安全，最好用异步的方式请求。 123456789101112131415161718192021222324252627282930&lt;script type=\"text/javascript\"&gt; function createXMLHTTP() &#123; var arrSignatures = [\"MSXML2.XMLHTTP.5.0\", \"MSXML2.XMLHTTP.4.0\", \"MSXML2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\" ]; for(var i = 0; i &lt; arrSignatures.length; i++) &#123; var oRequest = new XMLHttpRequest(arrSignatures[i]); return oRequest; &#125; &#125; var oRequest = createXMLHTTP(); oRequest.open(\"get\", \"example.txt\", true); //以异步的方式发送数据 oRequest.onreadystatechange = function() &#123; if(oRequest.readyState == 4) &#123; //为了添加参数的方便性，让我们增加一个添加参数的方法，然后为请求构建一个URL地址 function addURLParam(url, sParamName, sParamValue) &#123; url += (url.indexOf(\" ? \") == -1 ? \" ? \" : \" &amp; \"); url += encodeURIComponent(sParamName) + \" = \" + encodeURIComponent(sParamValue); return url; &#125; &#125; var url = \"https://yingy0.github.io/\"; url = addURLParam(url, \"gender\", \"女\"); url = addURLParam(url, \"age\", \"25\"); oRequest.open(\"get\", url, false); &#125;&lt;/script&gt; 4.进行POST请求 POST请求用于在表单中输入数据后的提交过程，因为POST可以比GET方式发送更多数据（最多2GB），POST请求的参数也必须进行编码，并用&amp;进行分割，但是这些参数不会被附加到URL上。 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt; function createXMLHTTP() &#123; var arrSignatures = [&quot;MSXML2.XMLHTTP.5.0&quot;, &quot;MSXML2.XMLHTTP.4.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot; ]; for(var i = 0; i &lt; arrSignatures.length; i++) &#123; var oRequest = new XMLHttpRequest(arrSignatures[i]); return oRequest; &#125; &#125; var oRequest = createXMLHTTP(); oRequest.open(&quot;get&quot;, &quot;example.txt&quot;, true); //以异步的方式发送数据 oRequest.onreadystatechange = function() &#123; if(oRequest.readyState == 4) &#123; function addPostParam(sParams, sParamName, sParamValue) &#123; if(sParams.length &gt; 0) &#123; sParams += &quot; &amp;&quot;; &#125; return sParams + encodeURIComponent(sParamName) + &quot;= &quot; + encodeURIComponent(sParamValue); &#125; var sParams = &quot;&quot;; sParams = addPostParam(sParams, &quot;gender&quot;, &quot;女&quot;); sParams = addPostParam(sParams, &quot;age&quot;, &quot;25&quot;); oRequest.open(&quot;open&quot;, &quot;example.txt&quot;, false); oRequest.send(sParams); &#125; &#125;&lt;/script&gt; 注意：该小节所有关于HTTP请求的代码都在本地根目录下面运行，没有配置服务器环境的同学们，请配置好环境之后，再来测试该代码。 四、LiveConnect请求 LiveConnect由Netscape Navigator引入，一般可以让JavaScript与Java类实现交互的能力。用户必须安装JRE,并且还需在浏览器中启用Java。 1.进行GET请求： 创建java.net.URL的实例 使用Live Connect时，必须提供类的完整名称，才能初始化一个Java对象。 创建URL后，就可以打开一个输入流并使用读取器来读取数据。缓冲阅读器是逐行获取数据的，要创建一个变量来将响应组成完整的文本,响应文本的变量必须是空字符串&quot; &quot;. 最好的方法是创建一个InputStreamReader，然后再基于它创建一个BufferReader。 1234567891011121314151617181920function httpGet(url) &#123; var ourl = new java.net.URL(url); var oStream = ourl.openStream(); var oReader = new java.io.BufferedReader(new java.io.InputStreamReader(oStream)); var oResponseText =&quot; &quot;; var sLine = oReader.readLine(); while (sLine != null) &#123; oResponseText += sLine + &quot;\\n&quot;; sLine = oReader.readLine();&#125; oReader.close(); return oResponseText;&#125; 注意：与XMLHTTP请求对象不同，LiveConnect要求输入完整的请求的URL，从http://开始，这是因为，这个Java对象没有任何解释相对URL的上下文。 2.进行POST请求 使用Connection对象来协助进行请求确定连接对象的设置. 因为POST请求可看作是双向的，所以必须使用setDoInput()和setDoOutput()方法将连接设成接受输入和输出。 另外，连接不应该使用任何缓存数据，所以要调用setUseCaches(false)。 必须用setRequestProperty()方法将&quot;Content-Type&quot;设为相应的值。 建立连接后获取请求的输出流,利用writeBytes()方法：输出流。 从连接中取得输入流并逐行读取数据。 123456789101112131415161718192021222324252627282930313233function httpPost(url, sParams) &#123; var ourl = new java.net.URL(url); //创建java.net.URL的实例 var oConnection = ourl.openConnection(); oConnection.setDoInput(true); oConnection.setDoOutput(true); oConnection.setUseCaches(false); oConnection.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); var output = new java.io.DataOutputStream(oConnection.getOutputStream()); output.writeBytes(sParams); output.flush(); output.close(); var sLine =&quot;&quot;, sResponseText = &quot;&quot;; var input = new java.io.DataInputStream(oConnection.getInputStream()); sLine = input.readLine(); while (sLine != null) &#123; sResponseText += sLine + “\\n”; sLine = input.readLine(); &#125; input.close(); return oResponseText;&#125; 五、智能HTTP请求 检测是否要使用XMLHTTP请求对象，判断XMLHTTPRequest的类型是否等于&quot;object&quot;(针对标准浏览器)，以及window.ActiveXObject(针对IE浏览器)是否有效 get()方法：用于对指定的URL进行一个GET请求，有两个参数： 发送请求的URL 一个回调函数 传给这个回调函数的唯一参数是从HTTP请求中获取的数据(sData)。 智能HTTP请求的步骤： 首先用XMLHTTP请求的对象进行GET请求时，使用异步请求可以设置另一个回调函数，同时在readyState为4时，调用上述的回调函数。 onreadystatechange事件处理函数调用指定的回调函数fnCallback。 如果浏览器不支持XMLHTTP请求，就必须检查是否用了LiveConnect，没有任何特性或者设置能够表示LiveConnect是否可用，唯一的办法是用navigator.javaEnabled()方法来保证已经浏览器中的java,并）判断java和java.net是否已定义。 如果要模仿异步调用，可用setTimeout()来延迟这一段时间，然后在调用回到函数。 因为LiveConnect要求必须输入完整的URL，所以每次都必须提供完整的URL给Http.get()方法 123456789101112131415161718192021222324252627282930313233var bXmlHttpSupport = (typeof XMLHttpRequest == “object” || window.ActiveXObject);Http.get = function (url, fnCallback) &#123; if (bXmlHttpSupport) &#123; var oRequest = new XMLHttpRequest(); oRequest.open(“get”, url, true); oRequest.onreadystatechange = function() &#123; if (oRequest.readyState == 4) &#123; fnCallback(oRequest.responseText); &#125;&#125;oRequest.send(null);&#125; else if(navigator.javaEnabled()&amp;&amp;typeof java != &quot;undefined&quot;&amp;&amp; type java.net != &quot;undefined&quot;) &#123;setTimeout(function() &#123; fnCallback(httpGet(url));&#125;, 10);&#125; else &#123; alert(&quot;你的浏览器不支持HTTP请求!&quot;); &#125;&#125; post()方法：对请求首部的设置、参数的数量以及方法发送的是一个POST请求，除了需要三个参数（URL、参数字符串和回调函数）外，post()方法类似于get()方法，大家可以参照get()方法来对比着看，不过get()只需要两个参数。 1234567891011121314151617181920212223242526272829303132var bXmlHttpSupport = (typeof XMLHttpRequest == “object” || window.ActiveXObject);Http.post = function(url, sParams, fnCallback) &#123; if (bXmlHttpSupport) &#123; var oRequest = new XMLHttpRequest(); oRequest.open(“post”, url, true); oRequest.setRequestHeader(“Content-Type”,“application/x-www-form-urlencoded”); oRequest.onreadysatechange = function() &#123; if (oRequest.readyState == 4) &#123; fnCallback(oRequest.responseText); &#125; &#125;&#125; else if ((navigator.javaEnabled() &amp;&amp; typeof java != “undefined”&amp;&amp; type java.net != “undefined”) &#123; setTimeout(function() &#123; fnCallback(httpPost(url, sParams));&#125;, 10);&#125; else &#123; alert(“你的浏览器不支持HTTP请求!”); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"客户端与服务器通信方式","slug":"客户端与服务器通信方式","permalink":"http://yoursite.com/tags/客户端与服务器通信方式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Gulp详解","slug":"Gulp详解","date":"2018-07-02T01:56:31.000Z","updated":"2018-10-12T14:47:28.020Z","comments":true,"path":"2018/07/02/Gulp详解/","link":"","permalink":"http://yoursite.com/2018/07/02/Gulp详解/","excerpt":"","text":"一名合格的前端开发人员，怎么可能不想办法尽可能的做到更好的性能优化。如果可以合理的利用一些构建工具，例如Gulp、Grunt等，这样可以达到事半功倍的效果，本篇文章就来介绍一下Gulp的基本用法。 Gulp是什么以及用来做什么？gulp是基于node的一个自动化构建工具 用途： 1、搭建Web服务器 2、浏览器自动刷新 3、使用预处理器Sass、Less 4、浏览器的兼容处理(添加前缀) 5、外部文件的自动压缩(图片文件、css文件、JS文件) 创建Gulp工具我们需要下载Gulp,gulp是基于node的一个自动化构建工具,node可以做网站、但是更大的用处是用作构建工具的。 （1）package.json文件 （2）下载gulp： 下载全局的gulp 路径地址：C:\\Users\\dell\\AppData\\Roaming\\npm\\node_modules\\gulp\\bin\\gulp.js 下载非全局gulp 我们首先的搭建一个像样的工程的目录结构： gulpfile.js就是我们需要编写的地方了,加油吧！！！ 第一步：引入gulpvar gulp = require(&#39;gulp&#39;); 这行命令告知Node去node_modules中查找gulp包，先局部查找，找不到就去全局环境中查找。找到之后就会赋值给gulp变量，然后我们就可以使用它了。 第二步：创建一个简单任务：123gulp.task(&apos;task-name&apos;, function() &#123;&#125;); task-name是任务的名字，我们想要查看运行结果的话，就在Git中输入gulp task-name，将运行该任务。 我们可以测试一下：(在git中输入gulp hello) 1234var gulp = require('gulp');gulp.task('hello', function() &#123; console.log('Hello World!');&#125;); 我们可以看到成功输出了Hello World，但是如果你真的认为Gulp这么简单的话，那你就错了,我们来看一些我们在平时的项目开发中可以用到的一些。 第三步：创建复杂任务Gulp任务通常会包含两个特定的Gulp方法和一些Gulp插件。 12345gulp.task('task-name', function () &#123; return gulp.src('source-files') // 输入源文件的地址 .pipe(aGulpPlugin()) // 通过一个Gulp插件发送 .pipe(gulp.dest('destination')) // 输出目标文件的地址 &#125;) 解释： gulp().task:配置我们的具体任务 gulp.src()：获取需要构建资源的路径，传递的参数必须是一个路径。 gulp.dest()：放置我们构建好的资源的路径，传递的参数也必须是一个路径。 pipe()：类似于管道的作用，起到一个’承上启下’的作用，上一次的处理结果，当做下一次传递参数。 注意：Gulp的开发者很厉害，所有的功能都是采用插件的机制，你需要用什么功能你直接安装插件、引入就可以使用了，这样做避免了将所有的方法都封装在Gulp当中，避免了Gulp过于庞大、笨重的问题。Gulp只是有个这样的任务gulp().task，但是具体的功能还是要依靠安装插件来实现。说的通俗一点就是Gulp什么事情都不干，专门&quot;指挥&quot;别人干。 第四步：将.sass文件转化成.css文件。需要给sass任务提供源文件和输出位置,所以我们先在项目中创建app/scss文件夹,里面有个styles.scss文件。 在第三个步骤中我们说过Gulp任务通常会包含两个特定的Gulp方法和一些Gulp插件，现在我们需要先安装gulp-sass插件我们再来写具体的方法。 插件安装：npm install gulp-sass --save-dev 引入gulp和sass。 12var gulp=require(&quot;gulp&quot;);var sass=require(&quot;gulp-sass&quot;); 输入和输出的方法 sass处理之后，我们希望它生成css文件并产出到app/css目录下(style.css)，可以这样写 1234567var gulp=require(&quot;gulp&quot;);var sass=require(&quot;gulp-sass&quot;);gulp.task(&apos;sass&apos;,function()&#123; return gulp.scr(&quot;app/scss/styles.scss&quot;)//源文件位置 .pipe(sass()) .pipe(gulp.dest(&quot;app/css&quot;)) //目标位置。&#125;) 好了，我们先在需要测试一下，在style.scss中写入一些scss命令， 12345//自定义变量$color:pink;.test1&#123; background-color:$color;&#125; 使用Git执行gulp sass,你将看到app/css/目录中多了styles.css文件,并且有下面的代码. 123.test1 &#123; background-color: pink; &#125; 这样我们就把.sass文件转化成.css文件，这个是Gulp自动转化成的，我们就只需要写几行代码就可以办到了，我们使用sass写css样式大大简化了操作，提高了开发效率。在实际的开发过程中。不只有一个.sass文件，我们可以使用Node通配符来匹配多个.css文件,我们应该学会合理的使用正则表达式。 第五步：Node通配符了解一下使用通配符，计算机检查文件名和路径进行匹配。 大部分时候，我们只需要用到下面4种匹配模式： *.scss：:*号匹配当前目录任意文件，所以这里*.scss匹配当前目录下所有scss文件 **/*.scss：:匹配当前目录及其子目录下的所有scss文件。 !not-me.scss：:！号移除匹配的文件，这里将移除not-me.scss *.+(scss|sass)：+号后面会跟着圆括号，里面的元素用|分割，匹配多个选项。这里将匹配scss和sass文件。 现在需要将任何app下的scss文件，在执行命令之后将生成对应的css文件存放到app/css/。 1234567var gulp=require(&apos;gulp&apos;);var sass=require(&apos;gulp-sass&apos;);gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&quot;app/sass/**/*.scss&quot;) .pipe(sass()) .pipe(gulp.dest(&quot;app/css&quot;)) &#125;) 第六步：给所有的css添加前缀给css添加不同的浏览器内核的前缀有着重要的意义，这个可以很好地解决浏览器之间的兼容性问题，如果让我们一个一个去加的话那也太麻烦了，幸好Gulp可以帮助我们自动完成这个繁琐的任务，那就需要用到autoprefixer插件了。 插件的安装：npm install gulp-autoprefixer --save-dev 引入var autoprefixer=require(&quot;gulp-autoprefixer&quot;); 输入输出函数： 1234567var autoprefixer=require(&quot;gulp-autoprefixer&quot;);gulp.task(&apos;css&apos;,function()&#123; return gulp.src(&quot;app/css/**/*.css&quot;) //pipe()方法：前一次的结果会当成后一次的输入 .pipe(autoprefixer()) .pipe(gulp.dest(&quot;dist&quot;));&#125;) 第六步：开启自动监听我们有没有发现每次我们写一些新的功能的时候，我们都要输入gulp task-name，这样是不是超级麻烦，我们需要自动监听。 语法格式如下： 1gulp.watch(&apos;files-to-watch&apos;, [&apos;tasks&apos;, &apos;to&apos;, &apos;run&apos;]); 监听一个文件：gulp.watch(&#39;app/scss/**/*.scss&#39;, [&#39;sass&#39;]); 监听一个任务 123gulp.task(&apos;watch&apos;, function()&#123; gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]);&#125;) 我们可以来测试一下： 12345678910var gulp = require('gulp');var sass = require('gulp-sass');gulp.task('sass', function() &#123; return gulp.src('app/scss/styles.scss') .pipe(sass()) .pipe(gulp.dest('app/css'))&#125;);gulp.task('watch', function()&#123;gulp.watch('app/scss/**/*.scss', ['sass']);&#125;) 在Gulp中执行gulp watch,可以看到现在的从.sass文件到.css文件的转换过程是处于监听状态的， 也就是说，我们每次修改.sass文件，就有Gulp帮我们自动执行，不用再手动执行了。这是一张盗的图,很炫酷的图。 第七步：浏览器的自动刷新(Browser Sync)Gulp可不可以帮忙自动刷新浏览器呢，好期待呀,可以试一下。 插件的安装：npm install browser-sync --save-dev 引入sync 123var gulp=require(&quot;gulp&quot;);var sass=require(&quot;gulp-sass&quot;);var sync=require(&quot;gulp-sync&quot;); 输入和输出的方法 创建一个broswerSync任务，我们需要告知它，根目录在哪里 1234567gulp.task(&apos;sync&apos;,function()&#123; browserSync(&#123; server: &#123; baseDir: &apos;app&apos; //根目录的位置 &#125; &#125;)&#125;) 修改一下任务sass，让每次css文件更改都刷新一下浏览器 12345678gulp.task('sass', function() &#123; return gulp.src('app/scss/styles.scss') .pipe(sass()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;))&#125;); 注意：我们必须在watch任务之前告知Gulp，先把任务browserSync和任务Sass执行了再说。 语法格式如下: 123gulp.task(&apos;watch&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;tasks&apos;, &apos;to&apos;, &apos;complete&apos;,&apos;before&apos;, &apos;watch&apos;], function ()&#123;&#125;) 终极板的浏览器自动刷新效果: 12345678910111213141516171819202122var gulp = require('gulp');// Requires the gulp-sass pluginvar sass = require('gulp-sass');var browserSync = require('browser-sync');gulp.task('browserSync', function() &#123; browserSync(&#123; server: &#123; baseDir: 'app'//根目录的位置 &#125;, &#125;)&#125;)gulp.task('sass', function() &#123; return gulp.src('app/scss/**/*.scss') .pipe(sass()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;))&#125;); //在监听之前先执行browserSync和sass函数gulp.task('watch', ['browserSync', 'sass'], function ()&#123; gulp.watch('app/scss/**/*.scss', ['sass']);&#125;) 当执行gulp watch命令之后，首先会执行browserSync在执行Sass，才会开始监听。 并且现在浏览器的显示的页面为app/index.html。修改了styles.scss之后，浏览器会自动刷新。 我们已经让.sass文件自动刷新了，应该让所有的文件都实现自动刷新的效果。 12345gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123; gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); gulp.watch(&apos;app/*.html&apos;, browserSync.reload); gulp.watch(&apos;app/js/**/*.js&apos;, browserSync.reload);&#125;); 第八步：合并多个JS文件。一般我们引入的JS文件都是这样的，路径都不太相同，那么该怎么合并呢? 12&lt;script type=&quot;text/javascript&quot; src=&quot;js/lib/commonobj.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/lib/require.js&quot; &gt;&lt;/script&gt; gulp-useref插件会将多个文件拼接成单一文件，并输出到相应目录。我们需要把合并的信息写到&lt;!--bulid--&gt;当中。 123&lt;!-- build:&lt;type&gt; &lt;path&gt; --&gt; 在这里引入外部资源文件&lt;!-- endbuild --&gt; 不仅需要明确要压缩的文件的路径，还必须知道输出的路径，最终的产出为main.min.js 12345&lt;!--build:js js/main.min.js --&gt; &lt;script type=\"text/javascript\" src=\"js/lib/commonobj.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/lib/require.js\" &gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 插件安装：npm install gulp-useref --save-dev 引用：var useref = require(&#39;gulp-useref&#39;); 输入和输出的方法： 12345gulp.task('useref', function()&#123; return gulp.src('app/*.html') .pipe(useref()) .pipe(gulp.dest('dist'));&#125;); 执行 gulp useref命令，Gulp将合并三个script标签成一个文件，并保存到dist/js/main.min.js。 第九步：压缩合并后的JS文件 插件安装：npm install gulp-uglify --save-dev 引用：var uglify = require(&#39;gulp-uglify&#39;); 123456gulp.task(&apos;useref&apos;, function()&#123; return gulp.src(&apos;app/*.html&apos;) .pipe(uglify()) .pipe(useref()) .pipe(gulp.dest(&apos;dist&apos;))&#125;); 执行 gulp useref命令，dist/js/main.min.js中的文件就被压缩了。 这下压缩、合并就搞定了，开心开心…… 现在执行完gulp useref命令后，我们会发现.html文件中的script路径将只剩下main.min.js，这是很正常的事情，因为已经生成新的main.min.js文件，并且体积更小，肯定引入的是最新生成的JS文件。 第十步：压缩CSS文件 插件安装：npm install gulp-if gulp-minify-css --save-dev 引用： 12var gulpIf = require(&apos;gulp-if&apos;);var minifyCSS = require(&apos;gulp-minify-css&apos;); 输入输出方法： 12345678910gulp.task('useref', function()&#123; return gulp.src('app/*.html') // 只有当它是一个CSS文件时才会出现 .pipe(gulpIf('*.css', minifyCSS())) // 只有当它是一个Javascript文件时才会出现 .pipe(gulpIf('*.js', uglify())) .pipe(useref()) .pipe(gulp.dest('dist'))&#125;); 第十一步：图片文件处理 插件安装：npm install gulp-imagemin --save-dev 引入：var imagemin = require(&#39;gulp-imagemin&#39;); 输入输出方法： 12345gulp.task(&apos;images&apos;, function()&#123; return gulp.src(&apos;app/images/**/*.+(png|jpg|gif|svg)&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;))&#125;); 压缩图片可能会占用较长时间，使用 gulp-cache插件可以减少重复压缩。 插件安装：npm install gulp-cache --save-dev 引入：var cache = require(&#39;gulp-cache&#39;); 输入输出： 1234567gulp.task(&apos;images&apos;, function()&#123; return gulp.src(&apos;app/images/**/*.+(png|jpg|jpeg|gif|svg)&apos;) .pipe(cache(imagemin(&#123; interlaced: true &#125;))) .pipe(gulp.dest(&apos;dist/images&apos;))&#125;); 第十二步：清理生成文件自动生成了新的压缩版文件之后，就可以把旧的未压缩的、分散的文件给删除了。 插件安装：npm install del --save-dev 引入var del = require(&#39;del&#39;); 输入输出函数： 123gulp.task(&apos;clean&apos;, function() &#123; del(&apos;dist&apos;);&#125;); 但是我们又不想图片被删除，因为图片改动的几率不大,这里就得利用正则表达式了。 123gulp.task(&apos;clean:dist&apos;, function(callback)&#123; del([&apos;dist/**/*&apos;, &apos;!dist/images&apos;, &apos;!dist/images/**/*&apos;], callback)&#125;); 这个任务会删除，除了images/文件夹，dist下的任意文件。 为了知道clean:dist任务什么时候完成，我们需要提供callback参数。 在某些时候我们还是需要清除图片，所以clean任务我们还需要保留。 1234gulp.task(&apos;clean&apos;, function(callback) &#123; del(&apos;dist&apos;); return cache.clearAll(callback);&#125;) 在实际的项目中可能用到的就只有这些了，我们需要组合一下这些task,组合成整体。 第十三步：整合通篇文章总共有两方面的内容： 第一是开发过程，Sass的使用，监听文件，刷新浏览器。 第二是优化，优化CSS,JavaScript,压缩图片，并把资源从app移动到dist 第一个方面： 12gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123;&#125;) 第二个方面： 123gulp.task(&apos;build&apos;, [`clean`, `sass`, `useref`, `images`, `fonts`], function()&#123;&#125;) 对于第二个来说，这样Gulp会同时触发多个事件，这样执行的逻辑是不对的，我们要让clean在其他任务之前完成。 这里需要用到RunSequence插件 插件安装：$ npm install run-sequence --save-dev 引入：var runSequence = require(&#39;run-sequence&#39;); 语法格式： 123gulp.task(&apos;task-name&apos;, function(callback) &#123; runSequence(&apos;task-one&apos;, &apos;task-two&apos;, &apos;task-three&apos;, callback);&#125;); 执行task-name时，Gulp会按照顺序执行task-one,task-two,task-thre。 RunSequence也允许你同时执行多个任务。 123gulp.task(&apos;task-name&apos;, function(callback) &#123; runSequence(&apos;task-one&apos;, [&apos;tasks&apos;,&apos;two&apos;,&apos;run&apos;,&apos;in&apos;,&apos;parallel&apos;], &apos;task-three&apos;, callback);&#125;); 我们需要改变一下代码 第二条线路： 123456gulp.task(&apos;build&apos;, function (callback) &#123; runSequence(&apos;clean:dist&apos;, [&apos;sass&apos;, &apos;useref&apos;, &apos;images&apos;, &apos;fonts&apos;], callback )&#125;) 第一条线路： 12345gulp.task(&apos;gulpdemo&apos;, function (callback) &#123; runSequence([&apos;sass&apos;,&apos;browserSync&apos;, &apos;watch&apos;], callback )&#125;) 现在只需要执行 gulp gulpdemo命令,就可以完成上述所有的功能。 参考链接：https://w3ctrain.com/2015/12/22/gulp-for-beginners/?utm_source=tuicool&amp;utm_medium=referral 最终版的代码在我的Github仓库，大家可以看一下。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://yoursite.com/tags/Gulp/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"js的解析与执行过程","slug":"js的解析与执行过程","date":"2018-07-02T01:52:37.000Z","updated":"2018-10-12T14:46:47.080Z","comments":true,"path":"2018/07/02/js的解析与执行过程/","link":"","permalink":"http://yoursite.com/2018/07/02/js的解析与执行过程/","excerpt":"","text":"1.全局预处理与执行1.1.预处理1.1.1 引例： 第一种情况 1234567&lt;script type=\"text/javascript\"&gt;var a=1;function xx()&#123; console.log(a);&#125;xx();&lt;/script&gt; 运行结果：在控制台输出1 原因：在xx()函数中可以访问一个全局的变量a,而现在这个全局变量a的值为1,所以输出结果为1。 第二种情况： 12345678&lt;script type=\"text/javascript\"&gt;var a=1;function xx()&#123; console.log(a); var a=5;&#125;xx();&lt;/script&gt; 运行结果：在控制台输出undefind 原因：在我们看来输出结果绝对不可能是5,因为浏览器引擎都是按照程序的顺序渲染程序的，那为什么会输出undefind？首先我们需要注意的是该代码在运行的时候并没有报错，而我们一般使用不存在的变量的时候，浏览器都会报错,但是现在不报错，值却是undefined，这个现象就是js内部的解析机制在捣鬼。现在我们就一起来了解一下JS的解析机制。 1.1.2 预处理阶段 JS的解析与执行过程主要分为两个阶段：预处理的阶段和执行阶段 注意：浏览器在解析JS代码的时候，并不是读一行就处理一行代码，它分为两块，第一块就是在正式处理代码之前的预处理阶段，第二块就是执行阶段，现在我人为的将它分为两部分：全局部分和函数部分，如下图所示： 在预处理阶段分为两部分： 第一部分：创建一个词法环境对象 第二部分：扫描你整个JS全局代码中的两个部分 用声明的方式创建的函数 用var定义的变量 12345//词法环境对象LexicalEnvironment&#123;&#125; 扫描出来以后就把这些变量的名字、函数的名字加到全局的词法环境对象中去。 举例： 12345678&lt;script type=\"text/javascript\"&gt;var a=5;var b;c=5; //没有var，所以不能加到词法环境中function xxx()&#123;&#125;&lt;/script&gt; 词法环境对象： 12345LexicalEnvironment &#123; a:undefined b:undefined xxx:对函数的一个引用 &#125; 注意：一定要用声明方式的创建函数，例如像这样var g=function()这样的方式叫做函数表达式，而不是声明的方式。 举例： 12345678910&lt;script type=\"text/javascript\"&gt;f();g();function f()&#123; //以声明的方式创建的函数 console.log('ff');&#125;var g=function()&#123; //以函数表达式创建的函数 console.log('gg');&#125;&lt;/script&gt; 运行结果： 原因：f函数会被正常的调用，函数f在词法环境中，g函数的调用会报错，在浏览器在执行过程中，在预处理阶段，将f函数写在词法环境中，是对函数的一个引用，f-&gt;ff，在g函数在词法环境中根本不存在，这里的g代表的是一个普通的变量，在预处理阶段的值为undefined,而不是一个函数，所以调用的时候会报错。 1234567&lt;script type=\"text/javascript\"&gt;console.log(a);console.log(b)var a=5;b=6;&lt;/script&gt; 运行结果： 原因我就不细说了，相信大家通过上面的例子已经看明白了吧。 总结：说白了预处理阶段就是分为两种情况 用var声明的变量的时候，变量是存在的，但值为undefined 用声明的方式声明的函数的时候，保持着对函数的引用。 1.1.3 全局的词法环境对象就window对象： LexicalEnvironment===window 1.2.命名冲突问题1.2.1 引例： 12345678910&lt;script type=\"text/javascript\"&gt;var f=5;fucntion f()&#123;&#125;var f=6function f()&#123; &#125;&lt;/script&gt; 面对这种函数和变量同名的情况，词法环境对象(window对象)会怎么处理呢？ 123456window&#123;f:可能出现出现两次 //在JS中是不可能存在的情况，不可能一个名称既代表函数名又代表变量名f:出现一次的策略 &#125; 在预处理阶段是JS引擎自己解析的，人为是无法参与的进去的，所以所有的预处理过程是在代码执行之前工作的。 1234567&lt;script type=\"text/javascript\"&gt;alert(f);var f=5;function f()&#123; console.log('111');&#125;&lt;/script&gt; 123456789&lt;script type=\"text/javascript\"&gt;console.log(f);function f()&#123; console.log('111');&#125;var f=5;&lt;/script&gt; 运行结果: 原因：并不是因为以f命名的函数在靠后的位置，输出结果为函数f的字符串表示，调整变量和函数的位置，输出结果还是相同的，所以并不是简单的顺序的扫描程序，若发生重名冲突的话，以后面的覆盖前面的，而真正的原因是因为JS引擎解决变量和函数的冲突机制。现在我们来一起了解一下吧。 1.2.2 命名冲突策略： 先扫描函数声明后扫描var声明的变量 处理函数声明有冲突，会覆盖 处理变量声明有冲突，会忽略 注意：是函数声明的方式而不是函数表达式的方式，我一直在强调这一点。 所以上述代码的词法环境为(处理变量和函数冲突) 123456window&#123; f:指向函数// f:undefined 变量声明有冲突，会忽略&#125; 处理函数冲突： 1234567891011&lt;script type=\"text/javascript\"&gt;console.log(f);var f=5;function f()&#123; console.log('111');&#125;function f()&#123; console.log('222');&#125;&lt;/script&gt; 运行结果： 这充分的说明了JS引擎在处理函数同名冲突的时候，会覆盖上一个函数。同时也说明了JavaScript中函数是占据十分重要的位置。 1.3执行阶段，123456789101112131415161718&lt;script type=\"text/javascript\"&gt;console.log(a);console.log(b); //会报错，应该注释掉，具体原因看图2所表达的意思console.log(f);console.log(g);var a=5; //var声明的局部变量b=6; //没有var声明的全局变量console.log(b);function f()&#123; //函数声明形式 consolg.log('f');&#125;var g=function()&#123; //函数表达式形式 console.log('g');&#125;console.log(g);&lt;/script&gt; 分析： 预理阶段:浏览器在运行过程中会扫描用声明的方式创建的函数，用var定义的变量 123f:指向函数a:undefinedg:undefined //注意：g因为是函数表达式的形式，所以这里代表的是变量,值为undefined而不是函数 执行阶段: 123456&#123; f:指向函数 a:5 g:指向函数 b:6&#125; 所以运行结果大家应该很清楚了吧，我把运行结果放着，大家可以参考下。运行结果： 总结：有var和没有var声明变量最主要的区别， 当有var声明变量时，在预处理阶段变量的值为undefined，在执行阶段变量的值为用户所赋给变量的值。 当没有var声明变量时，在预处理阶段变量的没有值，在执行阶段变量的值为用户所赋给变量的值。 2.函数预处理与执行注意:全局预处理和函数预处理是人为分的，实际并不存在的，并不是说全局预处理阶段完成后才进入到函数处理阶段 预处理阶段在全局预处理阶段创建的词法环境对象在浏览器中就是window对象，但是在函数预处理中阶段创建的词法环境对象是真实存在，看不见，摸不着的。也就是说，我们是访问不了的，因为这是JS解析器做的事情。 因为函数是有参数的，所有这个函数的参数已经就是预处理阶段词法环境对象的成员了。在预处理阶段的步骤如下： 每调用一次，产生一个LexicalEnvironment 先函数的参数 内部声明式函数 内部var变量 冲突情况与全局处理一样(函数覆盖，变量忽略) 123456789101112&lt;script type=\"text/javascript\"&gt;function f(a,b)&#123; console.log(a,b); var b=100; function a()&#123; &#125;&#125;f(1,2);&lt;/script&gt; 分析之前先看一个小案例：12345678910//如果声明一个函数function A(a,b)&#123;&#125;A(1);//声明的时候有两个参数，但是调用的时候只有一个参数，那么它所产生的词法环境对象为lexical env&#123;a:1;b:undefined &#125; 分析:预处理阶段：123456lexical env&#123; //词法环境对象 a:1 b:2 arguements:2 //实际穿的参数的个数&#125; 执行阶段123456lexical env&#123; //词法环境对象 a:指向函数 //函数a有冲突，此时现有的函数会覆盖原有的函数 b:2 //变量b有冲突，会忽略 arguements:2 //实际穿的参数的个数&#125; 运行结果: 执行阶段执行阶段主要有两个作用如下： 给预处理阶段的成员赋值，参考上一个代码，给预处理阶段的数据成员和成员变量该赋值的赋值、该忽略的忽略、该覆盖的覆盖。视具体的情况而定 如果没有用var声明的变量，会成为最外部LexicalEnvironment(window,全局)123456789&lt;script type=\"text/javascript\"&gt;function f()&#123; function g()&#123; b=100; &#125; g();&#125;f();&lt;/script&gt; 我们可以发现运行这段代码并没有任何结果，那么大家肯定会有疑问b的值跑去哪里了，这时候没有用var声明的b变成了全局变量，跑到了最外部window对象的词法环境去了，而不是某一个函数的词法环境，所以可以通过window.b去访问它。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"预解析过程","slug":"预解析过程","permalink":"http://yoursite.com/tags/预解析过程/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery-lazyload","slug":"jQuery-lazyload","date":"2018-06-30T10:44:36.000Z","updated":"2018-10-12T13:49:06.251Z","comments":true,"path":"2018/06/30/jQuery-lazyload/","link":"","permalink":"http://yoursite.com/2018/06/30/jQuery-lazyload/","excerpt":"","text":"Lazy Load Plugin for jQueryLazy Load delays loading of images in long web pages. Images outside of viewport wont be loaded before user scrolls to them. This is opposite of image preloading. Using Lazy Load on long web pages containing many large images makes the page load faster. Browser will be in ready state after loading visible images. In some cases it can also help to reduce server load. Lazy Load is inspired by YUI ImageLoader Utility by Matt Mlinac. How to Use?Lazy Load depends on jQuery. Include them both in end of your HTML code: 12&lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.lazyload.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; You must alter your HTML code. URL of the real image must be put into data-original attribute. It is good idea to give Lazy Loaded image a specific class. This way you can easily control which images plugin is binded to. Note that you should have width and height attributes in your image tag. 1&lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; height=&quot;480&quot;&gt; then in your code do: 1$(&quot;img.lazy&quot;).lazyload(); This causes all images of class lazy to be lazy loaded. More information on Lazy Load project page. InstallYou can install with bower or npm. 12$ bower install jquery.lazyload$ npm install jquery-lazyload LicenseAll code licensed under the MIT License. All images licensed under Creative Commons Attribution 3.0 Unported License. In other words you are basically free to do whatever you want. Just don’t remove my name from the source.","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"jQuery实例","slug":"jQuery实例","date":"2018-06-29T07:48:54.000Z","updated":"2018-10-12T14:46:50.128Z","comments":true,"path":"2018/06/29/jQuery实例/","link":"","permalink":"http://yoursite.com/2018/06/29/jQuery实例/","excerpt":"","text":"1.动态创建表格 功能：当点击按钮的时候才会创建表格。 重点：Jquery对象转换成DOM对象。然后使用DOM对象的innerHTML()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; padding: 0; margin: 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff; &#125; td &#123; font: 14px &quot;微软雅黑&quot;; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; &lt;/style&gt; &lt;script src=&quot;../js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 模拟从后台拿到的数据 var data = [&#123; name: &quot;天使在人间博客&quot;, url: &quot;https://www.yingy0.github.io&quot;, type: &quot;个人博客&quot; &#125;, &#123; name: &quot;百度&quot;, url: &quot;http://www.baidu.com&quot;, type: &quot;中国最大的搜索引擎&quot; &#125;, &#123; name: &quot;Github&quot;, url: &quot;http://github.com&quot;, type: &quot;开源&quot; &#125;]; $(function() &#123; $(&quot;#j_btnGetData&quot;).click(function() &#123; var tbHtml = &quot;&quot;, dataLen = data.length, i = 0; for(; i &lt; dataLen; i++) &#123; tbHtml += &quot;&lt;tr&gt;&quot;; tbHtml += &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot;; tbHtml += &quot;&lt;td&gt;&quot; + data[i].url + &quot;&lt;/td&gt;&quot;; tbHtml += &quot;&lt;td&gt;&quot; + data[i].type + &quot;&lt;/td&gt;&quot;; tbHtml += &quot;&lt;/tr&gt;&quot;; &#125; $(&quot;#j_tbData&quot;)[0].innerHTML = tbHtml; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;获取数据&quot; id=&quot;j_btnGetData&quot; /&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;说明&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tbData&quot;&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 运行效果： 注意：jQuery库本身有$(&quot;#j_tbData&quot;).html方法可以将内容动态添加到浏览器中，把jQuery对象转化为DOM对象的主要用途就是为了使用DOM对象中的某些方法。 2.手风琴效果 功能：当点击标题的时候，会让标题后面的一个div显示出来，并且让其他所有兄弟的元素隐藏起来。 重点：parent()、siblings()、children()、hide()、next()、show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; &#125; ul &#123; list-style-type: none; &#125; .parentWrap &#123; width: 200px; text-align: center; &#125; .menuGroup &#123; border: 1px solid #999; background-color: #e0ecff; &#125; .groupTitle &#123; display: block; height: 20px; line-height: 20px; font-size: 16px; border-bottom: 1px solid #ccc; cursor: pointer; &#125; .content &#123; height: 200px; background-color: #fff; display: none; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\".groupTitle\").click(function() &#123; //$(\".content\").hide(); $(this).parent(\".menuGroup\").siblings(\"li\").children(\"div\").hide(); //让当前元素后面的div展示出来 $(this).next(\"div\").show(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"parentWrap\"&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题1&lt;/span&gt; &lt;div class=\"content\"&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题2&lt;/span&gt; &lt;div class=\"content\"&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题3&lt;/span&gt; &lt;div class=\"content\"&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题4&lt;/span&gt; &lt;div class=\"content\"&gt;我是弹出来的div4&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 3.tab栏操作 功能：鼠标经过某个元素，当前元素样式和内容可以展现出来，其他的兄弟节点的样式和内容隐藏。 重点：mouseenter()、addClass()、siblings()、removeClass()、index()、eq()、show()、hide() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrapper &#123; width: 1000px; height: 475px; margin: 0 auto; margin-top: 100px; &#125; .tab &#123; border: 1px solid #ddd; border-bottom: 0; height: 36px; width: 320px; &#125; .tab li &#123; position: relative; float: left; width: 80px; height: 34px; line-height: 34px; text-align: center; cursor: pointer; border-top: 4px solid #fff; &#125; .tab span &#123; position: absolute; right: 0; top: 10px; background: #ddd; width: 1px; height: 14px; overflow: hidden; &#125; .products &#123; width: 1002px; border: 1px solid #ddd; height: 476px; &#125; .products .main &#123; float: left; display: none; &#125; .products .main.selected &#123; display: block; &#125; .tab li.active &#123; border-color: red; border-bottom: 0; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; // 给tab栏菜单绑定鼠标经过事件 $(\".tab&gt;li\").mouseenter(function()&#123; // 让当前元素添加样式，让兄弟元素删除样式 $(this).addClass(\"active\").siblings().removeClass(\"active\"); // $(this):表示的是让DOM对象转化为Jquery对象, //DOM对象转化为Jquery对象的方法是用括号\"()\"包起来，然后加一个\"$\"符号。 // 让当前tab栏对应的内容展示出来，让内容的兄弟隐藏掉 // 获取当前元素的索引号 var index=$(this).index(); $(\".main\").eq(index).show().siblings().hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrapper\"&gt; &lt;ul class=\"tab\"&gt; &lt;li class=\"tab-item active\"&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=\"tab-item\"&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=\"tab-item\"&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=\"tab-item\"&gt;男士精品&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"products\"&gt; &lt;div class=\"main selected\"&gt; &lt;a href=\"###\"&gt;&lt;img src=\"imgs/guojidapai.jpg\" alt=\"\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;a href=\"###\"&gt;&lt;img src=\"imgs/guozhuangmingpin.jpg\" alt=\"\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;a href=\"###\"&gt;&lt;img src=\"imgs/qingjieyongpin.jpg\" alt=\"\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;a href=\"###\"&gt;&lt;img src=\"imgs/nanshijingpin.jpg\" alt=\"\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 4.淘宝精品服装广告从图中可以看出左侧的菜单项有9项，右侧的菜单项也有9项，所以左侧菜单项的索引为0~8，右侧菜单项的索引为9~17。 功能：鼠标经过某个元素，当前元素样式和内容可以展现出来，其他的兄弟节点的样式和内容隐藏。 重点：mouseenter()、index()、show()、eq(index)、siblings()、hide() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; font-size: 12px; &#125; ul &#123; list-style: none; &#125; img &#123; border: 0; &#125; a &#123; text-decoration: none; &#125; .wrapper &#123; width: 298px; height: 248px; margin: 100px auto 0; border: 1px solid pink; overflow: hidden; &#125; #left,#center,#right&#123; float: left; &#125; #left li , #right li&#123; background: url(images/lili.jpg) repeat-x; &#125; #left li a,#right li a&#123; display: block; width: 48px; height: 27px; border-bottom: 1px solid pink; line-height: 27px; text-align: center; color: black; &#125; #left li a:hover,#right li a:hover&#123; background-image: url(images/abg.gif); &#125; #center &#123; border-left: 1px solid pink; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; //上个案例已经讲了mouseover和mouseenter区别，大家一定要认真的看下。 // 1. 给左边菜单绑定鼠标进入事件 mouseenter $(\"#left &gt; li\").mouseenter(function () &#123; var index = $(this).index(); // 获取当前元素的序号 // 根据序号选择到要展示的元素，让它展示出来，并且让它所有的兄弟元素都隐藏掉 $(\"#center &gt; li\").eq(index).show(); $(\"#center &gt; li\").eq(index).siblings().hide(); &#125;); // 2. 给右边菜单绑定鼠标进入事件 mouseenter $(\"#right &gt; li\").mouseenter(function () &#123; var index = $(this).index(); // 获取当前元素的索引号 // 由于当前序号跟中间广告的序号存在一个数量差的关系，所以，这个地方我们应该给 // 所有的序号 + 9 $(\"#center &gt; li\").eq(index+9).show(); $(\"#center &gt; li\").eq(index+9).siblings().hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrapper\"&gt; &lt;ul id=\"left\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;雪地靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;冬裙&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;呢大衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;羽绒服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"center\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女靴.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/雪地靴.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/冬裙.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/呢大衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/毛衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/棉服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女裤.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/羽绒服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/牛仔裤.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女包.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男包.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/登山鞋.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/皮带.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/围巾.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/皮衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男毛衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男棉服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男靴.jpg\" width=\"200\" height=\"250\" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;登山鞋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;皮带&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;围巾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;皮衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男靴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.表格全选反选效果 功能：当点击全选的复选框时，所有的子复选框都会被选中，当点击全部选的复选框时，所有的子复选框都不被选中，当所有的子复选框被选中是，全选的复选框自动被选中。 重点：Jquery对象转换成DOM对象、然后使用DOM对象的innerHTML()方法、(“:checkbox”)、(“:checked”)、DOM对象中的checked()、三元表达式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .wrap &#123; width: 300px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px \"微软雅黑\"; color: #fff; &#125; td &#123; font: 14px \"微软雅黑\"; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; var $j_cbAll = $(\"#j_cbAll\"), // 获取全选checkbox：jQuery对象 j_cbAll = $j_cbAll[0], // 获取全选checkbox：DOM对象 $tb = $(\"#j_tb\"), // 获取tbody $cbs = $tb.find(\":checkbox\"), // 获取tbody中所有的复选框 cbsLen = $cbs.length; // 获取复选框的长度 // 给全选checkbox绑定单击事件：处理所有选项的checkbox选中状态 $j_cbAll.click(function() &#123; var i = 0; // 注意此处i的使用 // 全选 // if(this.checked) 可以吗？ if(this.checked === true) &#123; for(; i &lt; cbsLen; i++) &#123; // 设置复选框被选中 $cbs[i].checked = true; &#125; &#125; else &#123; // 全不选 for(; i &lt; cbsLen; i++) &#123; // 设置复选框不被选中 $cbs[i].checked = false; &#125; &#125; &#125;); // 给所有 tbody中的 checkbox元素 绑定click事件 $cbs.click(function() &#123; // 获取所有被选中的checkbox个数 var $selCbLen = $tb.find(\":checkbox:checked\"); // 此处只有复选框 // 判断是否选中 全选checkbox /*if(selCbLen.length === cbsLen) &#123; j_cbAll.checked = true; &#125; else &#123; j_cbAll.checked = false; &#125;*/ $selCbLen.length === cbsLen ? j_cbAll.checked = true : j_cbAll.checked = false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"j_cbAll\" /&gt;&lt;/th&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;所属学院&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"j_tb\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;JavaScript&lt;/td&gt; &lt;td&gt;前端与移动开发学院&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;css&lt;/td&gt; &lt;td&gt;前端与移动开发学院&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;html&lt;/td&gt; &lt;td&gt;前端与移动开发学院&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;jQuery&lt;/td&gt; &lt;td&gt;前端与移动开发学院&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注意：for循环和for in循环的区别 for/in 循环会访问该对象的原型，应该用在非数组对象的遍历上，for循环应该遍历数组。 6.省选择案例 功能：全部选择和单个选择 重点：Jquery对象转换成DOM对象，然后使用DOM对象的innerHTML()、outerHTML()、removeClass()、(“:selected”)、children()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; select &#123; width: 200px; background-color: teal; height: 200px; font-size: 20px; &#125; .btn-box &#123; width: 30px; display: inline-block; vertical-align: top; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var $srcCity = $(\"#src-city\"), // 获取到 左边（源） 选择框：jQuery对象 $tarCity = $(\"#tar-city\"), // 获取到 右边（目标） 选择框：jQuery对象 srcCity = $srcCity[0], // 左边（源） 选择框：DOM对象 tarCity = $tarCity[0]; // 右边（目标） 选择框：DOM对象 // &gt;&gt; 操作 $(\"#btn-sel-all\").click(function () &#123; // 把 源选择框 中的数据 添加到 目标选择框 中 tarCity.innerHTML += srcCity.innerHTML; // 清空源 所有数据 srcCity.innerHTML = \"\"; &#125;); // &lt;&lt; 操作 $(\"#btn-sel-none\").click(function () &#123; // 把 目标选择框 中的数据 添加到 源选择框 中 srcCity.innerHTML += tarCity.innerHTML; // 清空目标 所有数据 tarCity.innerHTML = \"\"; &#125;); // &gt; 操作 （不支持多选） $(\"#btn-sel\").click(function () &#123; // 获取到当前选中的option var selCitySel = $srcCity.children(\":selected\")[0]; // 把 源选择框 选中的数据 添加到 目标选择框 中 tarCity.innerHTML += selCitySel.outerHTML; // 移除 源中的选中元素 srcCity.removeChild(selCitySel); &#125;); // &lt; 操作 （不支持多选） $(\"#btn-back\").click(function () &#123; // 获取到当前选中的option var tarCitySel = $tarCity.children(\":selected\")[0]; // 把 目标选择框 选中的数据 添加到 源选择框 中 srcCity.innerHTML += tarCitySel.outerHTML; // 移除 目标中的选中元素 tarCity.removeChild(tarCitySel); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;城市选择：&lt;/h1&gt; &lt;select id=\"src-city\" name=\"src-city\" multiple&gt; &lt;option value=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\"&gt;上海&lt;/option&gt; &lt;option value=\"3\"&gt;深圳&lt;/option&gt; &lt;option value=\"4\"&gt;广州&lt;/option&gt; &lt;option value=\"5\"&gt;西红柿&lt;/option&gt; &lt;/select&gt; &lt;div class=\"btn-box\"&gt; &lt;button id=\"btn-sel-all\"&gt; &amp;gt;&amp;gt; &lt;/button&gt; &lt;button id=\"btn-sel-none\"&gt; &amp;lt;&amp;lt; &lt;/button&gt; &lt;button id=\"btn-sel\"&gt; &amp;gt;&lt;/button&gt; &lt;button id=\"btn-back\"&gt; &amp;lt; &lt;/button&gt; &lt;/div&gt; &lt;select id=\"tar-city\" name=\"tar-city\" multiple&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 注意：”+=”表示一个累加的过程，”+”表示一个迭代覆盖的过程 运行结果： 7.下拉菜单 功能：当鼠标进入出现下拉菜单、当鼠标移除隐藏下拉菜单 重点：mouseover()、mouseenter()函数、mouseleave()、children()函数、show()、hide()、css() 不论鼠标指针穿过被选元素或其子元素，都会触发mouseover事件 只有在鼠标指针穿过被选元素时，才会触发mouseenter事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!-- demo1.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-image: url(imgs/bg.jpg); &#125; .wrap li &#123; background-image: url(imgs/libg.jpg); &#125; .wrap&gt;ul&gt;li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; // 1. 获取到事件源,并绑定鼠标进入事件 $(\".wrap &gt; ul &gt; li\").mouseenter(function() &#123; // 让当前一级菜单下面的二级菜单展示出来 $(this).children(\"ul\").show(); $(this).children(\"ul\").css(\"display\",\"block\"); &#125;); // 2. 获取到事件源，并绑定鼠标离开事件 $(\".wrap &gt; ul &gt; li\").mouseleave(function() &#123; // 让当前一级菜单下面的二级菜单隐藏掉 $(this).children(\"ul\").hide(); // hide() 方法表示：隐藏 $(this).children(\"ul\").css(\"display\",\"none\"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 8.动画效果的下拉菜单 功能：当鼠标进入出现卷帘门式的出现下拉菜单、当鼠标移除的时候卷帘门式的隐藏下拉菜单 重点：mouseover()、mouseleave、mouseenter()函数、children()函数、css()、slideDown()、slideUp()、hover()、toggle()、stop()。 第一种方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-image: url(imgs/bg.jpg); &#125; .wrap li &#123; background-image: url(imgs/libg.jpg); &#125; .wrap&gt;ul&gt;li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; // 1. 获取到事件源,并绑定鼠标进入事件 $(&quot;.wrap &gt; ul &gt; li&quot;).mouseenter(function() &#123; // 让当前一级菜单下面的二级菜单展示出来 $(this).children(&quot;ul&quot;).slideDown(); $(this).children(&quot;ul&quot;).css(&quot;display&quot;,&quot;block&quot;); &#125;); // 2. 获取到事件源，并绑定鼠标离开事件 $(&quot;.wrap &gt; ul &gt; li&quot;).mouseleave(function() &#123; // 让当前一级菜单下面的二级菜单隐藏掉 $(this).children(&quot;ul&quot;).slideUp(); // hide() 方法表示：隐藏 $(this).children(&quot;ul&quot;).css(&quot;display&quot;,&quot;none&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二种方式： 123456789&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").slideDown(); &#125;,function()&#123; $(this).children(\"ul\").slideUp(); &#125;) &#125;)&lt;/script&gt; 第三种方式： 1234567 &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").slideToggle(); &#125;) &#125;)&lt;/script&gt; 第四种方式 stop()：slideToggle()动画的效果是切换卷帘门，当鼠标进入或者离开的时候会触发切换效果，该动画默认有一定的执行时间，只有当时间间隔到达时才会停止动画，并不是说鼠标离开就会停止动画，利用stop()方法可以立即停止动画，没有时间间隔，这样的效果更贴近现实情况一些。 1234567 &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").stop().slideToggle(); &#125;) &#125;)&lt;/script&gt; 9右侧的QQ交谈 功能：点击在线客服就会出现QQ在线客服的界面 重点：animate()、children()、attr() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 131px; height: 311px; position: fixed; right: -131px; top: 50%; margin-top: -155px; &#125; .all span &#123; position: absolute; left: -29px; top: 50%; margin-top: -58px; cursor: pointer; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; var bl = true; $('.all span').click(function(e) &#123; //如果能判断是折叠还是展开即可； if(bl === true) &#123; $('.all').animate(&#123; right: 0 &#125;); $(this).children().attr('src', 'imgs/qqLOpen.jpg'); bl = false; &#125; else &#123; $('.all').animate(&#123; right: -131 &#125;); $(this).children().attr('src', 'imgs/qqL.jpg'); bl = true; &#125; &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"all\"&gt; &lt;span&gt;&lt;img src=\"imgs/qqL.jpg\" width=\"29\" height=\"117\"&gt;&lt;/span&gt; &lt;img src=\"imgs/qq.jpg\" width=\"131\" height=\"311\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 10.上下焦点图的制作 功能：当鼠标每经过一个小图标时，图片会自动上下转换，当鼠标不在图片上时，图片会自动上下转换。 重点：mouseenter()、addClass()、siblings()、removeClass()、index()、stop()、animate()、setInterval()、addClass()、hover()、clearInterval() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 490px; height: 170px; margin: 100px auto; position: relative; padding: 5px; border: 1px solid #ccc; &#125; .all div &#123; width: 490px; height: 170px; position: relative; overflow: hidden; &#125; .all ul &#123; position: absolute; left: 0; top: 0; &#125; .all img &#123; display: block; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; &#125; .all ol li &#123; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; float: left; margin-left: 10px; line-height: 20px; text-align: center; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\".all ol li\").mouseenter(function() &#123; $(this).addClass(\"current\").siblings().removeClass(\"current\"); var index = $(this).index(); $(\"ul \").stop().animate(&#123; top: index * -170 &#125;); num = index; //index()获取当前元素的索引号 &#125;); //制作一个定时器去实现自动播放功能； 定时器模块 var timer = null; var num = 0; timer = setInterval(autoplay, 2000); function autoplay() &#123; num++; if(num &gt; 4) &#123; num = 0; &#125; $('.all ol li').eq(num).addClass('current').siblings().removeClass(); $('.all ul').stop().animate(&#123; top: num * -170 &#125;; &#125; //鼠标移上停止定时器模块，hover切换动画 $('.all div').hover(function(e) &#123; //停止自动播放，清除定时器； clearInterval(timer); &#125;, function(e) &#123; clearInterval(timer); timer = setInterval(autoplay, 2000); &#125;); &#125;); &lt;/script&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"all\"&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"imgs/01.jpg\" width=\"490\" height=\"170\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"imgs/02.jpg\" width=\"490\" height=\"170\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"imgs/03.jpg\" width=\"490\" height=\"170\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"imgs/04.jpg\" width=\"490\" height=\"170\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"imgs/05.jpg\" width=\"490\" height=\"170\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=\"current\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 11.左右焦点图的制作 功能：当鼠标每经过一个小图标时，图片会自动左右转换，当鼠标不在图片上时，图片会自动左右转换。 重点：mouseenter()、addClass()、siblings()、removeClass()、index()、stop()、animate()、setInterval()、addClass()、hover()、clearInterval() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 400px; height: 307px; border: 5px solid #ccc; margin: 100px auto; position: relative; &#125; .all .show &#123; position: relative; overflow: hidden; width: 400px; height: 307px; &#125; .all ul &#123; width: 9999px; height: 307px; position: absolute; left: 0; top: 0; &#125; .all ul li &#123; float: left; &#125; .all span &#123; width: 52px; height: 52px; background: url(imgs/arr.png); position: absolute; top: 50%; margin-top: -26px; left: -21px; cursor: pointer; &#125; .all .right &#123; width: 52px; height: 52px; background: url(imgs/arr.png) no-repeat right 0; position: absolute; top: 50%; margin-top: -26px; right: -21px; left: auto; &#125; .all ol &#123; position: absolute; bottom: -30px; left: 30%; cursor: pointer; &#125; .all ol li &#123; width: 13px; height: 13px; background: url(imgs/00.png) no-repeat 0 0; float: left; margin-left: 10px; font-size: 0; &#125; .all ol .current &#123; background-position: 0 bottom; &#125; .box li &#123; background: red; border: 1px solid #000; &#125; &lt;/style&gt; &lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; var sx = 0 var timer = null; //var num=0; $(&apos;.all ol li&apos;).click(function(e) &#123; var index = $(this).index(); $(this).addClass(&apos;current&apos;).siblings().removeClass(); $(&apos;.all ul&apos;).stop().animate(&#123; left: index * -400 &#125;); sx = index; &#125;); //箭头工作 $(&apos;.all .right&apos;).click(function(e) &#123; sx++; if(sx &gt; 5) &#123; sx = 0; &#125; //都有谁需要跟着这个顺序走。 $(&apos;.all ol li&apos;).eq(sx).addClass(&apos;current&apos;).siblings().removeClass(); $(&apos;.all ul&apos;).stop().animate(&#123; left: sx * -400 &#125;); &#125;); $(&apos;.all .left&apos;).click(function(e) &#123; sx--; if(sx &lt; 0) &#123; sx = 5; &#125; //都有谁需要跟着这个顺序走。 $(&apos;.all ol li&apos;).eq(sx).addClass(&apos;current&apos;).siblings().removeClass(); $(&apos;.all ul&apos;).stop().animate(&#123; left: sx * -400 &#125;); &#125;); //自动播放模块 //制作一个定时器去实现自动播放功能； 定时器模块 timer = setInterval(autoplay, 2000); function autoplay() &#123; sx++; if(sx &gt; 5) &#123; sx = 0; &#125; $(&apos;.all ol li&apos;).eq(sx).addClass(&apos;current&apos;).siblings().removeClass(); //表示的是角标 $(&apos;.all ul&apos;).stop().animate(&#123; left: sx * -400 &#125;); &#125; //鼠标移上停止定时器模块 $(&apos;.all&apos;).hover(function(e) &#123; //停止自动播放，清除定时器； clearInterval(timer); &#125;, function(e) &#123; clearInterval(timer); timer = setInterval(autoplay, 2000); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;body&gt; &lt;div class=&quot;all&quot;&gt; &lt;div class=&quot;show&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;imgs/001.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imgs/002.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imgs/003.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imgs/004.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imgs/005.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imgs/006.jpg&quot; width=&quot;400&quot; height=&quot;307&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;span class=&quot;left&quot;&gt;&lt;/span&gt; &lt;span class=&quot;right&quot;&gt;&lt;/span&gt; &lt;ol&gt; &lt;li class=&quot;current&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/body&gt; &lt;/body&gt;&lt;/html&gt; 12.表格全选、反选增强版 功能：当点击全选的复选框时，所有的子复选框都会被选中，当点击全部选的复选框时，所有的子复选框都不被选中，当所有的子复选框被选中是，全选的复选框自动被选中，所有的选中与不选中都包括新创建的节点。当点击添加袁术时，会弹出新的对话框，当点击get时，会删除这一项，或者同时删除好几项。 重点：(“:checkbox”)、find()、prop()、attr()、(:checked”)、三元表达式、parent()、remove(); show()、val()、append()、hide() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; &#125; .wrap &#123; width: 410px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px \"微软雅黑\"; color: #fff; &#125; td &#123; font: 14px \"微软雅黑\"; &#125; td a.get &#123; text-decoration: none; &#125; a.del:hover &#123; text-decoration: underline; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; .form-item &#123; height: 100%; position: relative; padding-left: 100px; padding-right: 20px; margin-bottom: 34px; line-height: 36px; &#125; .form-item&gt;.lb &#123; position: absolute; left: 0; top: 0; display: block; width: 100px; text-align: right; &#125; .form-item&gt;.txt &#123; width: 300px; height: 32px; &#125; .mask &#123; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background: #000; opacity: 0.15; display: none; &#125; .form-add &#123; position: fixed; top: 30%; left: 50%; margin-left: -197px; padding-bottom: 20px; background: #fff; display: none; &#125; .form-add-title &#123; background-color: #f7f7f7; border-width: 1px 1px 0 1px; border-bottom: 0; margin-bottom: 15px; position: relative; &#125; .form-add-title span &#123; width: auto; height: 18px; font-size: 16px; font-family: 宋体; font-weight: bold; color: rgb(102, 102, 102); text-indent: 12px; padding: 8px 0px 10px; margin-right: 10px; display: block; overflow: hidden; text-align: left; &#125; .form-add-title div &#123; width: 16px; height: 20px; position: absolute; right: 10px; top: 6px; font-size: 30px; line-height: 16px; cursor: pointer; &#125; .form-submit &#123; text-align: center; &#125; .form-submit input &#123; width: 170px; height: 32px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; var $j_cbAll = $(\"#j_cbAll\"), // 获取全选checkbox：jQuery对象 j_cbAll = $j_cbAll[0], // 获取全选checkbox：DOM对象 $tb = $(\"#j_tb\"), // 获取tbody $cbs = $tb.find(\":checkbox\"), // 获取tbody中所有的复选框 cbsLen = $cbs.length; // 获取复选框的长度 // 给全选checkbox绑定单击事件：处理所有选项的checkbox选中状态 $j_cbAll.click(function() &#123; var i = 0; // 注意此处i的使用 // 全选 // if(this.checked) 可以吗？ $cbs = $tb.find(\":checkbox\"); // 获取tbody中所有的复选框 cbsLen = $cbs.length; if($(this).prop(\"checked\") === true) &#123; for(; i &lt; cbsLen; i++) &#123; // 设置复选框被选中(第一种方式是DOM对象方式、第二种方式Jquery对象，只能选择一次、第三种方式是Jquery对象、复选框可以选择多次) //$cbs[i].checked = true; //$cbs.attr(\"checked\",true); $cbs.prop(\"checked\", true); &#125; &#125; else &#123; // 全不选 for(; i &lt; cbsLen; i++) &#123; // 设置复选框不被选中(第一种方式是DOM对象方式、第二种方式Jquery对象，只能选择一次、第三种方式是Jquery对象、复选框可以选择多次) //$cbs[i].checked = false; //$cbs.attr(\"checked\",false); $cbs.prop(\"checked\", false); &#125; &#125; &#125;); // 给所有 tbody中的 checkbox元素 绑定click事件 // 给所有 tbody中的 checkbox元素 绑定click事件 $cbs.click(function() &#123; $cbs = $tb.find(\":checkbox\"); // 获取tbody中所有的复选框 cbsLen = $cbs.length; // 获取所有被选中的checkbox个数 var $selCbLen = $tb.find(\":checkbox:checked\"); // 此处只有复选框 // 判断是否选中 全选checkbox /*if(selCbLen.length === cbsLen) &#123; j_cbAll.checked = true; &#125; else &#123; j_cbAll.checked = false; &#125;*/ $selCbLen.length === cbsLen ? j_cbAll.checked = true : j_cbAll.checked = false; &#125;); //get $(\".get\").click(function() &#123; //选择到当前这个a标签的父元素td，在获取到td的父元素tr，让tr自己remove掉 $(this).parent().parent().remove(); &#125;) //get选中按钮 $(\"#j_btnDelSel\").click(function() &#123; //获取到选中的复选框的个数 var checkedLen = $tb.find(\":checkbox:checked\").length; if(checkedLen &lt;= 0) &#123; alert(\"请选择要get的技能\"); return; &#125; //选择到所有的被选中的checkbox, $tb.find(\":checkbox:checked\").parent(\"td\").parent(\"tr\").remove(); $j_cbAll.prop(\"checked\", false) &#125;) //添加按钮展示 添加表单层 $(\"#j_btnAddData\").click(function() &#123; $(\"#j_mask\").show(); $(\"#j_formAdd\").show(); &#125;); //添加数据功能 $(\"#j_btnAdd\").click(function() &#123; //因为用的是DOM对象中的方法，所以要jQuery对象要转化成DOM对象 //获取到课程的值(Val()函数，获取文本框的值) var lessonvalue = $(\"#j_txtLesson\").val(); //获取到所属学院的值 var BelSch = $(\"#j_txtBelSch\").val(); var trHml = \"&lt;tr&gt;\" + \"&lt;td&gt;&lt;input type='checkbox' /&gt;&lt;/td&gt;\" + \"&lt;td&gt;\" + lessonvalue + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + BelSch + \"&lt;/td&gt;\" + \"&lt;td&gt;&lt;a href='javascrip:;' class='get'&gt;GET&lt;/a&gt;&lt;/td&gt;\" + \"&lt;/tr&gt;\" //tr、td是tbody的子元素 $tb.append(trHml); //直接添加到所指定元素的所有子元素的最后面 $(\"#j_mask\").hide(); $(\"#j_formAdd\").hide(); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"GET选中\" id=\"j_btnDelSel\" /&gt; &lt;input type=\"button\" value=\"添加数据\" id=\"j_btnAddData\" /&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"j_cbAll\" /&gt;&lt;/th&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;所属学院&lt;/th&gt; &lt;th&gt;已学会&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"j_tb\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;JavaScript&lt;/td&gt; &lt;td&gt;传智播客-前端与移动开发学院&lt;/td&gt; &lt;td&gt; &lt;a href=\"javascrip:;\" class=\"get\"&gt;GET&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;css&lt;/td&gt; &lt;td&gt;传智播客-前端与移动开发学院&lt;/td&gt; &lt;td&gt; &lt;a href=\"javascrip:;\" class=\"get\"&gt;GET&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;html&lt;/td&gt; &lt;td&gt;传智播客-前端与移动开发学院&lt;/td&gt; &lt;td&gt; &lt;a href=\"javascrip:;\" class=\"get\"&gt;GET&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" /&gt;&lt;/td&gt; &lt;td&gt;jQuery&lt;/td&gt; &lt;td&gt;传智播客-前端与移动开发学院&lt;/td&gt; &lt;td&gt; &lt;a href=\"javascrip:;\" class=\"get\"&gt;GET&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"j_mask\" class=\"mask\"&gt;&lt;/div&gt; &lt;div id=\"j_formAdd\" class=\"form-add\"&gt; &lt;div class=\"form-add-title\"&gt; &lt;span&gt;添加数据&lt;/span&gt; &lt;div id=\"j_hideFormAdd\"&gt;x&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;label class=\"lb\" for=\"j_txtLesson\"&gt;课程名称：&lt;/label&gt; &lt;input class=\"txt\" type=\"text\" id=\"j_txtLesson\" placeholder=\"请输入课程名称\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;label class=\"lb\" for=\"j_txtBelSch\"&gt;所属学院：&lt;/label&gt; &lt;input class=\"txt\" type=\"text\" id=\"j_txtBelSch\" value=\"传智播客-前端与移动开发学院\"&gt; &lt;/div&gt; &lt;div class=\"form-submit\"&gt; &lt;input type=\"button\" value=\"添加\" id=\"j_btnAdd\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 13.右下角弹出广告 功能：右下角的小广告先展示再隐藏后显示，同时可以关闭广告 重点：slideDown()、slideUp()、fadeIn()、parent()、fadeOut() 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .ad &#123; position: fixed; right: 0; bottom: 0; width: 230px; height: 120px; background-image: url(imgs/ad.jpg); display: none; &#125; .ad span &#123; position: absolute; right: 0; top: 0; width: 40px; height: 18px; background-image:url(imgs/h.jpg); &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.11.1.min.js&quot; &gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $(&apos;.ad&apos;).slideDown(1000).slideUp(1000).fadeIn(); $(&apos;span&apos;).click(function()&#123; $(this).parent().fadeOut(); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;ad&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 14.鼠标跟随效果 功能：图片会跟随着鼠标的移动而变化着 重点：mousemove()、offset()、pageX、pageY、监听整个document的鼠标移动事件 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; body&#123; background-color: antiquewhite; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(document).on(\"mousemove\",function(e)&#123; $(\"img\").offset(&#123; top: e.pageY, left:e.pageX &#125;) &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"imgs/ts.gif\"/&gt; &lt;/body&gt;&lt;/html&gt; 15.五角星评论案例 功能:当鼠标移入时，自己和自己前面的五角星都变成实心，自己后面的五角星是空心，当鼠标离开时，实心显示到被点击的五角星上。 重点:text()、prevAll()、end()、nextAll()、addClass()、siblings()、removeClass()、(“.clicked”)、mouseleave()、mouseenter() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;五角星评论案例&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .comment &#123; font-size: 40px; color: teal; &#125; .comment li &#123; float: left; &#125; ul &#123; list-style: none; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; var wjx_none = '☆', wjx_sel = '★'; $(\".comment li\").mouseenter(function()&#123; //鼠标移入: 自己和前面的兄弟变实心，其余变空心 $(this).text(wjx_sel).prevAll().text(wjx_sel).end().nextAll().text(wjx_none); &#125;).click(function()&#123; //鼠标点击后，把自己添加clicked类，其余的清除clicked类 $(this).addClass('clicked').siblings().removeClass('clicked'); &#125;); //当鼠标移开评分控件时，实心显示到被点击的五角星的上 $(\".comment\").mouseleave(function()&#123; $(\".comment li\").text(wjx_none);//先给所有五角星都变空心 $(\".clicked\").text(wjx_sel).prevAll().text(wjx_sel).end().nextAll().text(wjx_none); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"comment\"&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS封装库","slug":"Yquery","date":"2018-06-28T07:48:54.000Z","updated":"2018-10-12T14:04:34.597Z","comments":true,"path":"2018/06/28/Yquery/","link":"","permalink":"http://yoursite.com/2018/06/28/Yquery/","excerpt":"","text":"如果了解并且用过JQuery的人，应该知道它的强大与方便吧，是不是也想自己利用原生的JavaScript封装一个简单的属于自己的库呢？ 在JQuery的选择器中，有三种类型的参数，我们可以传一个函数、传一个字符串、传一个对象。如果传进来的是字符串的话，又分为三种类型，$(&quot;#ID&quot;),$(&quot;.class&quot;),$(&quot;selector&quot;) 123456$(function()&#123; &#125;)==&gt;事件绑定$(\"sEv\")=$(\"#ID\"),$(\".class\"),$(\"selector\")$(obj)==&gt;直接插入 1.第一步：封装函数1234567891011function Yquery(yArg)&#123; //yArg这里表示任何类型的参数，命名要规范。 //我们需要根据传进来的不同参数做不同的事情 //首先判断传进来的参数的类型 switch (typeof yArg)&#123; //如果传进来的参数是函数类型,就直接让window.onload执行 case 'function': window.onload=yArg; break; &#125;&#125; 封装好了函数，是不是内心有一丝的小激动呢，那我们现在赶紧来测试一下吧。 12345&lt;script&gt; new Yquery(function()&#123; console.log(\"a\") &#125;)&lt;/script&gt; 我们可以在控制台中看到a，这样一个简单的封装就好了，但是这里面存在这一个极大的问题。我们熟悉jQuery的人都知道可以在一个页面中写多个入口函数，并且不会发生冲突问题。 123456789$(document).ready(function)&#123;&#125;$(document).ready(function)&#123;&#125;$(document).ready(function)&#123;&#125; 如果我们在自己封装的库里面写多个呢?会出现什么情况呢？ 12345678&lt;script&gt; new Yquery(function()&#123; console.log(\"a\") &#125;) new Yquery(function()&#123; console.log(\"b\") &#125;)&lt;/script&gt; 我想大家应该都知道结果了，结果为b,并没有a,这就说明函数b覆盖了函数a,原因是我们把函数直接交给window.onload去执行，大家应该都知道在JavaScript中只能有一个入口函数&quot;window.onload=function(){}&quot;如果有多个的话，就会产生覆盖。 2.第一次修改Yquery.js如何解决函数覆盖的问题？ 在Jquery中采用的是事件队列的机制，这里面使用事件绑定机制。我们需要定义一个绑定事件的函数，myAddEvent(); 12345678910111213141516171819202122function myAddEvent(obj,sEv,fn)&#123; //IE浏览器 if(obj.attachEvent)&#123; obj.attachEvent(\"on\"+sEv,fn); //标准浏览器 &#125;else&#123; obj.addEventListener(sEv,fn,false); //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 &#125;&#125;function Yquery(yArg)&#123; //yArg这 里表示任何类型的参数，命名要规范。 //我们需要根据传进来的不同参数做不同的事情 //首先判断传进来的参数的类型 switch (typeof yArg)&#123; //如果传进来的参数是函数类型,就直接让window.onload执行 case 'function': //使用绑定的方式， myAddEvent(window,\"load\",yArg); break; &#125;&#125; 3.封装字符串Yquery.js描述： 我们只需要判断第一个字符就可以判断传进来的字符串具体是哪一种类型(ID选择器、标签选择器、类选择器). 选择符本身只是用来选择元素的，而不对它做任何操作，对它做操作的是选择符后面的方法。 substring(1)：截取字符串，从位置1开始截取，一直到结束，返回值是截取的字符串，在这里这个方法非常有用。 用一个参数保存选择器选择的元素，this.elements = []; getByClass()：类选择器的获取，getElementsByTagName()、className(); 123456789101112131415161718192021222324252627282930313233343536373839//通过JavaScript操作DOM方式获取类选择器function getByClass(oParent, sClass) &#123; var aEle = oParent.getElementsByTagName('*'); var aResult = []; var i = 0; for(i = 0; i &lt; aEle.length; i++) &#123; if(aEle[i].className == sClass) &#123; aResult.push(aEle[i]); &#125; &#125; return aResult;&#125;function Yquery(yArg) &#123; //yArg这 里表示任何类型的参数，命名要规范。 //我们需要根据传进来的不同参数做不同的事情 //首先判断传进来的参数的类型 this.elements = []; //用来保存选择器选择的元素 switch(typeof yArg) &#123; //如果传进来的参数是字符串类型，又分为三种情况 case 'string': switch(yArg.charAt(0)) &#123; case '#': //ID //如果选择器是ID选择器，那么yArg的值可能是\"#div\",我们需要把#去掉，剩下的才是我们想要的 var obj = document.getElementById(yArg.substring(1)); //这时，elements数组就存了被ID选择器选中的字符串 this.elements.push(obj); break; case '.': //class //从哪个父元素选择元素？从整个文档选取类选择器。 //用substring(1)去掉类选择器的\". \" //用返回的数组aResult，替换elements数组 this.elements = getByClass(document, yArg.substring(1)); break; default: //tagName this.elements = document.getElementsByTagName(yArg); &#125; break; &#125;&#125; 字符串的封装就完成了，现在我们来测试一下吧。 12345678910&lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt;&lt;/body&gt;&lt;script&gt; new Yquery(function()&#123; new Yquery(\"button\").click(function()&#123; console.log(\"a\") &#125;) &#125;) &lt;/script&gt; 输出结果：在控制台中可以看到a,这里我只测试了标签选择器，大家也可以测测ID选择器和类选择器. 4.封装对象Yquery.js封装对象特别简单，只需要把对象直接push到elements数即可。 1234567891011function Yquery(yArg) &#123; //yArg这 里表示任何类型的参数，命名要规范。 //我们需要根据传进来的不同参数做不同的事情 //首先判断传进来的参数的类型 this.elements = []; //用来保存选择器选择的元素 switch(typeof yArg) &#123; case &apos;object&apos;: //如果传进来的参数是字符串对象类型，就直接放到elemens数组 this.elements.push(yArg); &#125;&#125; 5.入口函数的封装我们现在自己封装的库每次测试的时候的入口函数为 1234&lt;script&gt; new Yquery(function()&#123; &#125;)&lt;/script&gt; 我们参照一下JQuery的入口函数 123456789&lt;script&gt; $(document).ready(function()&#123; &#125;) $(function()&#123; &#125;)&lt;/script&gt; 那我们怎样才能实现这样的写法呢？ 做法：声明一个$符号函数，函数内部返回我们的构造函数，以代替每次的的入口函数都要写new Yquery() 123456//声明一个$符号函数，函数内部返回我们的构造函数以代替每次的的入口函数都要写new Yqueryfunction $(yArg)&#123; return new Yquery(yArg);&#125; 经过这样修改之后，我们的入口函数就可以写成下面的形式了。 123456789&lt;script&gt; $(document).ready(function()&#123; &#125;) $(function()&#123; &#125;)&lt;/script&gt; 6.封装类似JQuery中的click()函数123456789//给Yquery函数绑定click事件Yquery.prototype.click = function(fn) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加单击事件 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; myAddEvent(this.elements[i], \"click\", fn); &#125;&#125;; 7.封装类似JQuery中的show()函数和hide()函数display:block==show() display:none==hide() 1234567891011121314151617181920//封装类似jQuery中的show()函数Yquery.prototype.show= function() &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加show事件 var i = 0; //elements数组里面放的就是被选中的元素,让被选中的每一个元素都在展示出来 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style.display=\"block\"; &#125;&#125;;//封装类似jQuery中的hide()函数Yquery.prototype.hide= function(fn) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加show事件 var i = 0; //elements数组里面放的就是被选中的元素,让被选中的每一个元素都在隐藏起来 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style.display=\"none\"; &#125;&#125;; 8.封装hover()函数1234567891011//封装类似jQuery中的hover()函数//hover()方法需要两个参数，一个是mouseenter(),一个是mouseleave()Yquery.prototype.hover= function(fnEnter,fnLeave) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加hover方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; myAddEvent(this.elements[i], \"mouseenter\", fnEnter); myAddEvent(this.elements[i], \"mouseleave\", fnLeave); &#125;&#125;; 那我们现在来测试一下hover()函数 123456789101112&lt;body&gt; &lt;div id=\"div1\" style=\"width: 100px; height: 100px; background: red;\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function() &#123; $('#div1').hover(function ()&#123; document.title='mouseenter'; &#125;, function ()&#123; document.title='mouseleave'; &#125;);&lt;/script&gt; 9.封装css()函数参数个数不固定(arguements.length) 注意：在利用css()函数获取值的时候，如下代码 $(&quot;div&quot;).css(&quot;background-color&quot;); ,假设现在页面上有三个div，到底获取的是哪一个”div”的背景颜色值呢？ 答案：是获取第一个匹配元素的样式属性值。 那我们这样封装css()函数有问题吗？ 123456789101112131415161718//封装css(方法)//CSS()方法主要有两个功能：设置样式(两个参数)和获取样式(一个参数),也就是说参数个数不固定Yquery.prototype.css = function(attr, value) &#123; if(arguments.lenght == 2) //设置样式 &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加css方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style[attr] = value; &#125; &#125; else &#123; //获取样式 //获取第一个匹配元素的样式属性值,直接给style()方法 return this.elements[0].style[attr]; &#125;&#125; 肯定是有问题的，Javascript中的style()方法在设置属性值的时候一切正常，但是在获取值的时候却出现了问题：Javascript中的style()方法只能获取的是行间样式，其他的样式值获取不到。但是绝大样式都不是行间样式，都是写在一个外部文件然后引入。 什么是行间样式呢？就是直接写在标签元素内部的,例如下面的代码。 1&lt;div style=\"width:150px;height:150px;background-color:pink;\"&gt;&lt;/div&gt; 如果不相信的话我们可以测试一下 123456789101112131415161718&lt;style&gt; #div1 &#123; width: 100px; height: 100px; background: red; &#125;&lt;/style&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() &#123; $('#div1').click(function() &#123; console.log($('#div1').css('width')); &#125;); &#125;); &lt;/script&gt; 这样的形式获取的width值为空，那我们换成行间样式在测试一下， 1234567891011&lt;body&gt; &lt;div id=\"div1\" style=\"width:150px;height:150px;background-color:pink;\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() &#123; $('#div1').click(function() &#123; console.log($('#div1').css('width')); &#125;); &#125;); &lt;/script&gt; 这样的形式就可以获取到CSS的width值。 我们总不可能以后把样式就写在标签内部吧，我们总得寻找一个解决的办法。 解决办法：我们封装一个getStyle()函数，然后绑定在CSS()函数的获取值的方法中。 用到的方法：currentStyle属性、getComputedStyle()方法： 1234567891011121314151617181920212223242526272829//getStyle()：用来获取CSS样式属性值。function getStyle(obj,attr)&#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else&#123; return getComputedStyle(obj,false)[attr]; //参数中的false并没有什么实际的意义，只要随便传一个值就行， //你也可以写true,或者随便的一个数字、字符。 &#125;&#125;//封装css(方法)//CSS()方法主要有两个功能：设置样式(两个参数)和获取样式(一个参数),也就是说参数个数不固定Yquery.prototype.css = function(attr, value) &#123; if(arguments.length == 2) //设置样式 &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加css方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style[attr] = value; &#125; &#125; else &#123; //获取样式 //获取第一个匹配元素的样式属性值。 return getStyle(this.elements[0],attr); &#125;&#125; 现在的代码应该就没有什么问题了，我们可以测试一下发现，不论是行间样式的属性值，还是外部引入的，我们都可以获得它的属性值，而不会是一个空值。 10.第二次修改关于this在测试中，我们总能发现各种各样有趣的问题，现在再来看一个有趣的问题吧。 1234567891011121314151617181920&lt;style&gt; #div1 &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() &#123; $('#div1').hover(function ()&#123; $('#div1').css('background-color', 'green'); &#125;, function ()&#123; $('#div1').css('background-color', 'red'); &#125;); &#125;); &lt;/script&gt; 我们可以发现上述代码运行的结果本身并没有什么问题，但是在代码书写的方面确是有些怪异的。如果上述代码我们引入jQuery的库，我们肯定是这样写的: 1234567891011121314151617181920&lt;style&gt; #div1 &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(function() &#123; $('#div1').hover(function ()&#123; $(this).css('background-color', 'green'); &#125;, function ()&#123; $('this').css('background-color', 'red'); &#125;); &#125;); &lt;/script&gt; 直接用this替换？？我们自己写的库可以做到吗？我们来测试一下 我们可以发现在标准的浏览器下，换成this这个也是可以顺利执行的，但是在IE浏览器下不出乎意料的就报错了，IE浏览器总是让我们头疼的浏览器,我们来想一下这是为什么呢? 我们console.log一下this,看下标准浏览器和IE浏览器的差异。 123456789$(function ()&#123; $('#div1').hover(function ()&#123; console.log(this); alert(this); $(this).css('background', 'green'); &#125;, function ()&#123; $(this).css('background', 'red'); &#125;);&#125;); 谷歌浏览器下this指向这个对象div本身. 比较老的IE浏览器下的this指向的是window，this指向window而不是指向对象div本身，肯定就不出乎意料的就报错了。 这时我们就想起来了不能用this的四种情况： 行间样式、套一层、绑定、定时器。 hover()函数是把mouseenter()和mouseleave()通过绑定封装的，我们再看一下我们的绑定函数 12345678910function myAddEvent(obj,sEv,fn)&#123; //IE浏览器 if(obj.attachEvent)&#123; obj.attachEvent(\"on\"+sEv,fn); //标准浏览器 &#125;else&#123; obj.addEventListener(sEv,fn,false); //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 &#125;&#125; IE下面的绑定attachEvent()有bug,会把被绑的函数中的this指向window,而不是指向对象本身,标准浏览器下面的addEventListener()没有这个问题，this就是指向对象本身， 那我们怎么去解决IE浏览器下的这个问题呢？为了统一，我们把它们看作是都有bug的，这样处理起来比较方便。我们可以利用call()函数和apply()函数，改变this的指向。所以我们改变一下绑定函数myAddEvent()。 123456789101112function myAddEvent(obj,sEv,fn)&#123; //IE浏览器 if(obj.attachEvent)&#123; obj.attachEvent(\"on\"+sEv,function()&#123; fn.call(obj); &#125;); //标准浏览器 &#125;else&#123; obj.addEventListener(sEv,fn,false); //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 &#125;&#125; 通过call()函数我们手动将IE浏览器的this指向了对象，这下就和标准浏览器执行一样的效果了。 11.toggle()函数的封装toggle()函数有两个参数，这两个参数可以来回切换： 参照toggle()函数我们可以发现一个规律：如果我们给一个按钮添加一个click事件，第一次点击按钮的时候，触发fn1函数，第二次点击按钮的时候触发fn2函数，第三次点击按钮的时候触发fn1函数，第四次点击按钮的时候触发fn2函数，以此类推，所以，我们需要设置一计数器。 11.1.计数器的封装1234567891011121314&lt;body&gt;&lt;input id=\"btn1\" type=\"button\" value=\"我是按钮\" /&gt;&lt;/body&gt;&lt;script&gt;window.onload=function ()&#123; var oBtn=document.getElementById('btn1'); var count=0; oBtn.onclick=function () &#123; console.log(count++); &#125;;&#125;;&lt;/script&gt; 运行结果： 上述形式的计数器在只有一个button按钮,没有一点问题，那如果页面上存在多个Button按钮、并且想要这些按钮都可以计数，而且是分别从0开始计数，这个该怎么实现呢？ 12345678910111213141516171819202122&lt;body&gt;&lt;input type=\"button\" value=\"按钮1\" /&gt;&lt;input type=\"button\" value=\"按钮2\" /&gt;&lt;input type=\"button\" value=\"按钮3\" /&gt;&lt;input type=\"button\" value=\"按钮4\" /&gt;&lt;/body&gt;&lt;script&gt;window.onload=function ()&#123; var aBtn=document.getElementsByTagName('input'); var i=0; var count=0; for(i=0;i&lt;aBtn.length;i++) &#123; aBtn[i].onclick=function () &#123; console.log(count++); &#125;; &#125;&#125;;&lt;/script&gt; 运行结果： 我们打开控制台测试了一下发现：这些按钮并不是分别从0开始计数的，而是累加起来计数的，那我们怎么样可以分离每个按钮的计数呢？让每个按钮都分别从0开始计数，那我们可能需要多个计数器。这样才可以分离每个按钮的计数情况。 解决办法：我们封装一个addClick()方法，我们先来简单的封装一下。 123456789101112131415161718192021222324&lt;body&gt;&lt;input type=\"button\" value=\"按钮1\" /&gt;&lt;input type=\"button\" value=\"按钮2\" /&gt;&lt;input type=\"button\" value=\"按钮3\" /&gt;&lt;input type=\"button\" value=\"按钮4\" /&gt;&lt;/body&gt;window.onload=function ()&#123; var aBtn=document.getElementsByTagName('input'); var i=0; var count=0; for(i=0;i&lt;aBtn.length;i++) &#123; addClick(aBtn[i]); &#125; function addClick(obj) &#123; obj.onclick=function () &#123; console.log(count++); &#125;; &#125;&#125;;&lt;/script&gt; 这样封装其实并没有什么作用，运行结果还是如上图所示，这些按钮并不是分别从0开始计数的，而是累加起来计数的。 我们可以再来稍微改变一下。我们目前最需要的就是增加多个计数器，我们可以这样做。 这里用的其实是闭包的特性。 123456789101112131415161718192021&lt;body&gt;&lt;input type=\"button\" value=\"按钮1\" /&gt;&lt;input type=\"button\" value=\"按钮2\" /&gt;&lt;input type=\"button\" value=\"按钮3\" /&gt;&lt;input type=\"button\" value=\"按钮4\" /&gt;&lt;/body&gt;&lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var i = 0; for(i = 0; i &lt; aBtn.length; i++) &#123; addClick(aBtn[i]); &#125; function addClick(obj) &#123; var count = 0; obj.onclick = function() &#123; console.log(count++); &#125;; &#125; &#125;;&lt;/script&gt; 经过这么一番改变，我们想要的的效果可算是好了，不同的按钮会从0开始计数，有多少个按钮就会添加多少个计数器。 我们可以改变一下函数的形式，让它变得更加好看一些，更加符合JS的语法规范,熟悉JavaScript语法的人都知道在JavaScript中函数有两种形式，一种是带参数的形式，一种是不带参数的形式，那我们可以这样改写一下。 1234567891011function a()&#123; console.log(a);&#125;div.onclick=a;div.onclick=function()&#123; console.log(a);&#125;//上面两种形式的函数的写法都是正确的。 那参照上面我们可以将我们的计数器函数也改变一下。 (function(){})() 12345678910111213141516window.onload=function ()&#123; var aBtn=document.getElementsByTagName('input'); var i=0; for(i=0;i&lt;aBtn.length;i++) &#123; (function (obj)&#123; var count=0; obj.onclick=function () &#123; alert(count++); &#125;; &#125;)(aBtn[i]); &#125;&#125;;&lt;/script&gt; 我们对于这样的写法可能还不太满意，那么我们可以再来改变一下,一个更加简便的方法。 123456789101112131415&lt;script&gt;window.onload=function ()&#123; var aBtn=document.getElementsByTagName('input'); var i=0; for(i=0;i&lt;aBtn.length;i++) &#123; aBtn[i].onclick=(function (count)&#123; return function ()&#123; alert(count++); &#125;; &#125;)(0); &#125;&#125;;&lt;/script&gt; 11.2我们接着来封装我们toggle()函数1234567891011121314151617181920//封装toggle()函数//toggle()函数可以有无数多个参数Yquery.prototype.toggle = function() &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加toggle方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; //计数函数的封装 (function addToggle(obj) &#123; var count = 0; myAddEvent(obj, 'click', function() &#123; //arguments()函数获取一个函数形参的个数 //这里面的函数指的是就是封装的toggle()函数， //也就是说，arguments()函数获取的是toggle()函数的形参的个数。 arguments[count % arguments.length].call(obj); count++; &#125;) &#125;)(this.elements[i]); &#125;&#125; 这样封装对不对呢？我们来测试一下。 1234567891011121314151617&lt;script&gt;$(function ()&#123; $('input').toggle(function ()&#123; console.log('a'); &#125;, function ()&#123; console.log('b'); &#125;, function ()&#123; console.log('c'); &#125;);&#125;);&lt;/script&gt;&lt;body&gt;&lt;input type=\"button\" value=\"1\" /&gt;&lt;input type=\"button\" value=\"2\" /&gt;&lt;input type=\"button\" value=\"3\" /&gt;&lt;input type=\"button\" value=\"4\" /&gt;&lt;/body&gt; 经过测试，我们可以发现报错了，那原因是为什么呢？ 我们给myAddEvent()中console.log(arguments.length);发现值为1，并且还报错了，可是我们明明给toggle()函数传了3个函数，按道理说值应该为3呀， 通过以往我们学javascript的经验，我们可以知道在javascript中一个this、另一个就是arguments非常容易混乱，这里就是arguments在捣鬼。我们再次测试一下， 1234567891011121314151617Yquery.prototype.toggle = function() &#123; var i = 0; console.log(arguments.length);//在控制台输出3 for(i = 0; i &lt; this.elements.length; i++) &#123; //计数函数的封装 addToggle(this.elements[i]); &#125; function addToggle(obj) &#123; var count = 0; myAddEvent(obj, 'click', function() &#123; console.log(arguments.length);//在控制台输出1，并且报错 arguments[count%arguments.length].call(obj); count++; &#125;) &#125;&#125; 这下我们就明白了，我们需要保存输出结果为3的这个arguments.length的值，用这个值去绑定我们的myAddEvent()函数肯定就是不会错了。如下代码 11.3.第三次修改toggle()函数1234567891011121314151617181920212223//封装toggle()函数//toggle()函数可以有无数多个参数Yquery.prototype.toggle = function() &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加toggle方法 var i = 0; //我们需要提前将arguments的值保存下来，以免被后面的函数的arguments所覆盖。 var _arguments=arguments; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; //计数函数的封装 addToggle(this.elements[i]); &#125; function addToggle(obj) &#123; var count = 0; myAddEvent(obj, 'click', function() &#123; //arguments()函数获取一个函数形参的个数 //这里面的函数指的是就是封装的toggle()函数， //也就是说，arguments()函数获取的是toggle()函数的形参的个数。 _arguments[count% _arguments.length].call(obj); count++; &#125;) &#125;&#125; 我们可以再来测试一下 1234567891011121314151617&lt;script&gt;$(function ()&#123; $('input').toggle(function ()&#123; console.log('a'); &#125;, function ()&#123; console.log('b'); &#125;, function ()&#123; console.log('c'); &#125;);&#125;);&lt;/script&gt;&lt;body&gt;&lt;input type=\"button\" value=\"1\" /&gt;&lt;input type=\"button\" value=\"2\" /&gt;&lt;input type=\"button\" value=\"3\" /&gt;&lt;input type=\"button\" value=\"4\" /&gt;&lt;/body&gt; 这下就完全没有问题了 11.4.封装的toogle()函数的小实例1234567891011121314151617&lt;style&gt;#div1 &#123;width:100px; height:100px; background:red;&#125;&lt;/style&gt;&lt;script&gt;$(function ()&#123; $('input').toggle(function ()&#123; $('#div1').hide(); &#125;, function ()&#123; $('#div1').show(); &#125;);&#125;);&lt;/script&gt;&lt;body&gt;&lt;input type=\"button\" value=\"我是按钮\" /&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt; 点击按钮会隐藏，如果在点击一次按钮会显示，这就是toogle()函数的效果。 12.封装attr()方法和封装css()方法有些类似 12345678910111213141516//封装attr(方法)//attr()方法主要有两个功能：设置属性(两个参数)和获取属性(一个参数),也就是说参数个数不固定Yquery.prototype.attr = function(attr, value) &#123; if(arguments.length == 2) //设置属性值 &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加attr方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i][attr] = value; &#125; &#125; else &#123; //获取属性值 //获取第一个匹配元素的属性值。 return this.elements[0][attr]; &#125;&#125; 我们可以简单地测试一下： 123456789101112131415&lt;body&gt;&lt;input id=\"txt1\" type=\"text\" /&gt;&lt;input id=\"btn1\" type=\"button\" value=\"读取文字\" /&gt;&lt;input id=\"btn2\" type=\"button\" value=\"设置文字\" /&gt;&lt;/body&gt;&lt;script&gt;$(function ()&#123; $('#btn2').click(function ()&#123; $('#txt1').attr('value', '我是设置的值') &#125;); $('#btn1').click(function ()&#123; console.log($('#txt1').attr('value')); &#125;);&#125;);&lt;/script&gt; 13.封装eq()方法，索引值从0开始。1234567//封装eq()函数//eq()函数有一个参数，获取第几个元素，索引值从0开始。Yquery.prototype.eq=function (n)&#123; //所有能选择到的元素都存在elements数组中 //需要将返回的普通DOM对象封装成我们自己写的Yquery对象。 return $(this.elements[n]);&#125; 我们可以测试一下 1234567891011121314151617181920212223&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; float: left; margin: 10px; &#125;&lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;script&gt; $(function() &#123; $('div').eq(0).css('background', 'green'); &#125;);&lt;/script&gt; 14.封装find()方法在jQuery的find()方法中的作用是查找指定元素的子元素。 find()方法的参数只有一个，但是都有什么类型的呢？我们可以先看一下在jQuery库中find()方法都有哪些参数？ 123456789101112131415161718192021222324&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; $(\"ul\").find(\"li\"); $(\"ul\").find(\"ol\"); $(\"#ul1\").find(\"li\"); $(\"ul\").find(\".box\"); //注意find()方法没有这种形式： $(\"#div1\").find(\"#ul1\"); 由此我们可以得出find()方法的参数有两种形式：一种直接是标签名的形式、一种是类名的形式。 123456789101112131415161718192021//封装find()函数//find()函数只有一个参数，但是参数分为两种形式//一种直接是标签名的形式、一种是类名的形式。Yquery.prototype.find = function(str) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加find() var i = 0; var aResult = []; //用来存放临时数据的数组 //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; switch(str.charAt(0)) &#123; case &apos;.&apos;: //参数是类名的形式 var aEle = getByClass(this.elements[i], str.substring(1)); aResult = aResult.concat(aEle); break; default: //参数是标签名的形式 var aEle = this.elements[i].getElementsByTagName(str); aResult = aResult.concat(aEle); &#125; &#125; return aResult;&#125; 我们现在已经算是初步封装好了，那有没有什么问题呢？？我们看一下源代码，我们直接返回的是一个数组aResult，我们可以直接返回一个普通的数组吗？？ 答案：这是不可以的，我们一般情况下利用find()方法找到一个元素或者多个元素，是直接要给后面添加我们封装好的方法的,比如css()、show()、click()方法等，但是普通的数组没有这些方法，我们不可能强行的加上去，所以我们还是需要再改改的。 解决办法：我们需要创建一个空的Yquery对象newYquery，这个空的Yquery对象newYquery可以直接给后面添加我们封装好的方法的,比如css()、show()、click()方法等，也就是说，用一个空的Yquery对象newYquery来装载我们的普通的数组，把JavaScript对象转化成Yquery对象。 123456789101112131415161718192021222324//封装find()函数//find()函数只有一个参数，但是参数分为两种形式//一种直接是标签名的形式、一种是类名的形式。Yquery.prototype.find = function(str) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加find() var i = 0; var aResult = []; //用来存放临时数据的数组 //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; switch(str.charAt(0)) &#123; case '.': //参数是类名的形式 var aEle = getByClass(this.elements[i], str.substring(1)); aResult = aResult.concat(aEle); break; default : //参数是标签名的形式 var aEle = this.elements[i].getElementsByTagName(str); aResult = aResult.concat(aEle); &#125; &#125; var newYquery = $(); //我们需要创建一个空的Yquery对象， newYquery.elements = aResult; return newYquery;&#125;; 那现在赶紧来测试一下吧。 1234567891011121314151617181920212223&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li&gt;我是无序列表&lt;/li&gt; &lt;li&gt;我是无序列表&lt;/li&gt; &lt;li&gt;我是无序列表&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li class=\"box\"&gt;我是box&lt;/li&gt; &lt;li class=\"box\"&gt;我是box&lt;/li&gt; &lt;li&gt;我是无序列表&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是有序列表&lt;/li&gt; &lt;li&gt;我是有序列表&lt;/li&gt; &lt;li&gt;我是有序列表&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;script&gt; $(function() &#123; $('ul').find('.box').css('background-color', 'red'); $('ul').find('li').css('background-color', 'red'); &#125;);&lt;/script&gt; 经过测试，我们可以发现，可以正确的找到参数是类名的形式并且正确的设置样式，但是不能找到参数是标签名的形式，而且会报错，原因是使用的concat()方法。那我们先来看下concat()方法。 concat()方法：用于连接两个或多个数组，该方法不会改变现有的数组,而仅仅会返回被连接数组的一个副本。 参数是类名的形式可以使用concat()方法的原因：getByClass()方法获取的值的返回结果就是一个数组。 参数是标签名的形式不能使用concat()方法的原因：通过getElementsByTagName(&#39;li&#39;);获取到的是一个HTML集合，虽然看起来像是一个数组，但不是一个数组，并不具备数组的操作，所以不能用concat()方法来连接。 123456&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var li=document.getElementsByTagName('li'); console.log(li) &#125;&lt;/script&gt; 我们可以再看一下数组的集合。 解决办法：我们封装一个函数appendArray()实现连接两个或两个以上HTML集合的功能。 12345678//函数appendArray():实现连接两个或两个以上HTML集合的功能function addendArr(arr1, arr2) &#123; var i = 0; //把arr2数组的值都push到arr1中。 for(i = 0; i &lt; arr2.length; i++) &#123; arr1.push(arr2[i]); &#125;&#125; 这下可以看一下我们终极的find()方法。 12345678910111213141516171819202122232425//封装find()函数//find()函数只有一个参数，但是参数分为两种形式//一种直接是标签名的形式、一种是类名的形式。Yquery.prototype.find = function(str) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加find() var i = 0; var aResult = []; //用来存放临时数据的数组 //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; switch(str.charAt(0)) &#123; case '.': //参数是类名的形式 var aEle = getByClass(this.elements[i], str.substring(1)); aResult = aResult.concat(aEle); break; default: //参数是标签名的形式 var aEle = this.elements[i].getElementsByTagName(str); addendArr(aResult, aEle); &#125; &#125; var newYquery = $(); //我们需要创建一个空的Yquery对象， newYquery.elements = aResult; return newYquery;&#125;; 我们再来测试一下上面有问题的代码，这下可以发现不论是参数是标签形式的，还是参数是类形式的都可以正确的获取到指定元素，并且正确的设置样式。 15.封装index()方法描述： 从匹配的元素中搜索给定元素的索引值，从0开始计数。 获取元素的索引值(同辈元素)，索引的序号从0开始。 这时的this.elements会有好多个元素，因为elements数组里面放的就是被选中的元素， 和封装css()方法，如果css()只有一个参数(获取属性值)时类似,如果有多个匹配的元素，只获取第一个匹配元素的属性值。this.elements[0] 我们现在最主要的就是获取指定元素在其同辈元素的位置， 我们可以先看一个小案例，点击不同的按钮然后返回对应的索引值 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; function getIndex(obj) &#123; //获取obj的父节点(body)的孩子节点(4个&lt;input&gt;标签) var aBrother = obj.parentNode.children; var i = 0; //obj的节点肯定和aBrother的某个节点相等，可以循环遍历判断一下 for(i = 0; i &lt; aBrother.length; i++) &#123; if(aBrother[i] == obj) &#123; return i; &#125; &#125; &#125; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var i = 0; for(i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function() &#123; console.log(getIndex(this)); &#125;; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" value=\"我是按钮1\" /&gt; &lt;input type=\"button\" value=\"我是按钮2\" /&gt; &lt;input type=\"button\" value=\"我是按钮3\" /&gt; &lt;input type=\"button\" value=\"我是按钮4\" /&gt; &lt;/body&gt;&lt;/html&gt; 这下我们想要的效果达成了，我们可以将上面的getIndex()方法应用到我们的案例上面。 封装的index()方法： 1234567891011121314151617//获取指定元素在同辈元素处的索引值。function getIndex(obj) &#123; //获取obj的父节点(body)的孩子节点(4个&lt;input&gt;标签) var aBrother = obj.parentNode.children; var i = 0; //obj的节点肯定和aBrother的某个节点相等，可以循环遍历判断一下 for(i = 0; i &lt; aBrother.length; i++) &#123; if(aBrother[i] == obj) &#123; return i; &#125; &#125;&#125;//封装index()方法Yquery.prototype.index = function() &#123; return getIndex(this.elements[0]);&#125; 还是来测试一下吧，是不是有点不放心写的对不对？？ 123456789101112131415 &lt;body&gt; &lt;button&gt;我是按钮1&lt;/button&gt; &lt;button&gt;我是按钮2&lt;/button&gt; &lt;button&gt;我是按钮3&lt;/button&gt; &lt;button&gt;我是按钮4&lt;/button&gt; &lt;button&gt;我是按钮5&lt;/button&gt; &lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").click(function()&#123; var index=$(this).index(); console.log(index); &#125;) &#125;) &lt;/script&gt; 看到这样的结果就放心了。 我们现在封装了这么多的方法，那我们现在做一个小案例吧，来满足一个我们的成就感。 16.高级版的css()方法的封装在我们以前封装的css()方法中，可以设置或者获取属性，但是我们封装的时候，有两个参数的话是设置属性值，有一个参数的话是获取属性值，所以局限于获取或者设置一个属性值，例如： 123.css('background-color','#ffe')//设置背景色.css('background-color')//获取背景色 那如果想要一次添加多个属性值，或者通过链接的结构设置属性值，例如下面的样式，该怎么实现呢？ 123456.css(&#123;width: &apos;200px&apos;, height: &apos;200px&apos;, background:&apos;red&apos;&#125;).css(&apos; width&apos;, &apos;200px&apos;&apos;).css(&apos;height&apos;,&apos;200px&apos;).css(&apos;background&apos;,&apos;green&apos;)//把添加多个属性值的形式看作是JSON字符串var obj=&#123;width: &apos;200px&apos;, height: &apos;200px&apos;, background:&apos;red&apos;&#125;.css(obj) 我们可以把一次性添加多个属性值的这种看作是一个json字符串，那么在css()方法中当有一个参数时不仅能表示获取属性值了，而且还可以表示设置多个属性值。 那么我们怎么循环遍历json字符串呢？利用for..in循环 12345678&lt;script&gt;var json=&#123;width: '200px', height: '200px', background:'red'&#125;;var i='';for(i in json)&#123; console.log(i+':'+json[i]);&#125;&lt;/script&gt; 输出结果 12345678910111213141516171819202122232425262728//封装css(方法)//CSS()方法主要有两个功能：设置样式(两个参数)和获取样式(一个参数),也就是说参数个数不固定Yquery.prototype.css = function(attr, value) &#123; if(arguments.length == 2) //设置样式 &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加css方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style[attr] = value; &#125; &#125; else &#123; //可能是设置多个样式也可能是获取样式 if(typeof attr=='string')&#123; //如果是字符串类型的话还是获取样式属性值。 //获取第一个匹配元素的样式属性值。 return getStyle(this.elements[0], attr); &#125;else&#123;//表示是一个json形式的字符串，设置多个样式属性值 //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123;//现在开始循环attr,JSON字符串 var k=''; //空字符串 for(k in attr)&#123; this.elements[i].style[k]=attr[k]; &#125; &#125; &#125; &#125;&#125;; 高级版的css()方法我们也封装完了，我们可以来测试一下， 12345678910111213141516&lt;body&gt; &lt;input type=\"button\" value=\"我是按钮\" /&gt; &lt;div id=\"div1\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function() &#123; $('input').click(function() &#123; $('#div1').css(&#123; width: '200px', height: '200px', background: 'green' &#125;); &#125;); &#125;);&lt;/script&gt; 现在我们实现了一次性添加多个属性值的效果,那链式操作的行为可以不可以实现呢？ .css(&#39;width&#39;, &#39;200px&#39;).css(&#39;height&#39;,&#39;200px&#39;).css(&#39;background&#39;,&#39;green&#39;); 运行结果图17，可以发现只设置成功了第一个css的属性值，其他的并没有设置成功，并没有链式操作的属性，那么我们必须使我们封装的函数有链式操作的特点，那就必须在函数的结束部分加上return this. 最终极的css()函数的封装： 1234567891011121314151617181920212223242526272829//封装css(方法)//CSS()方法主要有两个功能：设置样式(两个参数)和获取样式(一个参数),也就是说参数个数不固定Yquery.prototype.css = function(attr, value) &#123; if(arguments.length == 2) //设置样式 &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加css方法 var i = 0; //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123; this.elements[i].style[attr] = value; &#125; &#125; else &#123; //可能是设置多个样式也可能是获取样式 if(typeof attr=='string')&#123; //如果是字符串类型的话还是获取样式属性值。 //获取第一个匹配元素的样式属性值。 return getStyle(this.elements[0], attr); &#125;else&#123;//表示是一个json形式的字符串，设置多个样式属性值 //elements数组里面放的就是被选中的元素 for(i = 0; i &lt; this.elements.length; i++) &#123;//现在开始循环attr,JSON字符串 var k=''; //空字符串 for(k in attr)&#123; this.elements[i].style[k]=attr[k]; &#125; &#125; &#125; &#125; return this;&#125;; 先不管是什么原因，我们先来测试一下。 12345678910&lt;script&gt; $(function() &#123; $('input').click(function() &#123; $('#div1') .css('width', '200px') .css('height','200px') .css('background','green'); &#125;); &#125;);&lt;/script&gt; 运行结果： 这下我们成功的封装了一次设置多个样式属性和链式操作。 大家是不是有个疑问？？为什么要return this呢？？ 参考：jQuery常用方法之事件对象 我们先看一个小案例，然后在解释： 12345678&lt;script&gt; function show(str) &#123; console.log(str); return show; &#125; show('abc')('bcd')(13)(444)('bdsf')(3123);&lt;/script&gt; 为什么函数可以一直一直调用呢？ 这就是函数的链式操作，简单来说就是函数调用之后不断地返回自己，调用之后就返回自己，不断地往后前进。我们给函数的最后加上了return this,就可以实现Yquery库中的类似的链式操作。 我们可以给我们以前封装的函数都加上return this，它们就都有了链式操作的属性，可以随意的组合，具有强大的效果。 我们可以测试一下，看下这些方法是不是都可以随意地组合。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script src=\"../Yquery.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function ()&#123; $('input').hover(function ()&#123; document.title='mouseenter'; &#125;, function ()&#123; document.title='mouseleave'; &#125;).css(&#123; width: '200px', height: '100px', background: 'green'&#125;) .click(function ()&#123; console.log('a'); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"我是按钮\" /&gt;&lt;/body&gt;&lt;/html&gt; 图18：我们可以发现所有的混搭都可以实现，这下心里是不是很高兴呢？ 17.JQuery中阻止默认事件如果想要在jQuery中阻止默认事件，直接在它的事件处理函数中加上return false即可。 举例：contextmenu():右键菜单 功能：禁止浏览器右键菜单的弹出。 1234567&lt;script&gt;$(function ()&#123; $(document).on('contextmenu', function ()&#123; return false; &#125;);&#125;);&lt;/script&gt; 18.JQuery中阻止冒泡123456789101112131415&lt;body&gt;&lt;div style=\"background:red;\"&gt; &lt;div style=\"background:green;\"&gt; &lt;div style=\"background:#CCC;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(function ()&#123; $('div').click(function ()&#123; console.log(this.style.background); return false; &#125;);&#125;);&lt;/script&gt; 描述： 没有阻止冒泡的输出(没有return false)： 阻止了冒泡的输出(有return false)： 注意： 在jQuery中，其实return false既代表了阻止默认事件，又代表了阻止冒泡。 但是在原生的javascript中，return false只代表阻止默认事件。 在我们自己封装的Yquery中，我们同样可以使用return false阻止默认事件和冒泡吗？ 上述的同样的阻止默认事件和阻止冒泡的代码中，换成我们自己封装的Yquery库,测试一下，我们可以得出的结论是： 我们自己封装的Yquery库用return false当然不能阻止冒泡事件和阻止默认事件，原因是因为在JQuery阻止默认事件时，我们用on()方法绑定了contextmenu，但是在我们的Yquery库中却没有这个方法，所以我们也要封装一个on()方法，不能阻止冒泡事件的原因我们在后面再说，让我们先开始封装on()函数吧。 19.on()函数的封装我们先暂时设定on()函数有两个参数，一个是事件名，一个是事件函数。 1234567891011//封装on()函数Yquery.prototype.on=function(sEv,fn)&#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加on()方法 var i=0; //循环的给每个元素都绑定事件 for(i=0;i&lt;this.elements.length;i++) &#123; //给每个元素绑定sEv事件，执行fn函数 myAddEvent(this.elements[i],sEv,fn); &#125;&#125; 我们来测试一下，看看有没有用 1234567&lt;script&gt;$(function ()&#123; $(document).on('contextmenu', function ()&#123; return false; &#125;);&#125;);&lt;/script&gt; 给过测试发现并没有什么用，根本就阻止不了默认行为，到底是哪里出了问题呢？再看一下之前封装的on()函数，先来排查错误，肯定不会是for()循环出错了，那么很有可能就是myAddEvent()函数有些问题，那我们再来看一下这个函数： 123456789101112function myAddEvent(obj, sEv, fn) &#123; //IE浏览器 if(obj.attachEvent) &#123; obj.attachEvent(\"on\" + sEv, function() &#123; fn.call(obj); &#125;); //标准浏览器 &#125; else &#123; obj.addEventListener(sEv, fn, false); //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 &#125;&#125; myAddEvent()函数中的第三个函数fn其实就是我们传给on()函数的第二个参数，也就是事件处理函数， 1234567&lt;script&gt;$(function ()&#123; $(document).on('contextmenu', function ()&#123; return false; &#125;);&#125;);&lt;/script&gt; 事件处理函数中的return false，我们想一想有没有别的函数接收，其实根本就没有人接收，不管我们return什么值都没有其他的函数接收，return 什么都没有什么意思，因为根本就没有人接收，没人管你return什么值。所以我们需要修改myAddEvent()函数，给它里面添加return false。 我们先把IE浏览器的阻止默认事件封装好 1234567891011121314function myAddEvent(obj, sEv, fn) &#123; //IE浏览器 if(obj.attachEvent) &#123; obj.attachEvent(\"on\" + sEv, function() &#123; if(false==fn.call(obj))&#123; return false; &#125; &#125;); //标准浏览器 &#125; else &#123; obj.addEventListener(sEv, fn, false); //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 &#125;&#125; 在IE浏览器下测试，没有问题，阻止了右键的弹出事件。 那我们的标准浏览器该怎么办呀？ 大家应该都知道如果事件绑定用addEventListener()方法， return false;会失效，我们可以用preventDefault()方法来代替 return false; 1234567891011121314151617181920function myAddEvent(obj, sEv, fn) &#123; //IE浏览器 if(obj.attachEvent) &#123; obj.attachEvent(\"on\" + sEv, function() &#123; if(false==fn.call(obj))&#123; return false; &#125; &#125;); //标准浏览器 &#125; else &#123; obj.addEventListener(sEv, function(ev) &#123; //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 if(false==fn.call(obj)) &#123; ev.preventDefault(); &#125; &#125;,false); &#125;&#125; 在标准浏览器下测试，没有问题，阻止了右键的弹出事件。 我们不仅要阻止默认事件，我们还要阻止冒泡事件的呀，这里还是得修改myAddEvent()函数，我们需要使用event.cancelBubble来阻止冒泡事件。 123456789101112131415161718192021222324252627282930function myAddEvent(obj, sEv, fn) &#123; //IE浏览器 if(obj.attachEvent) &#123; obj.attachEvent(\"on\" + sEv, function() &#123; if(false == fn.call(obj)) &#123; event.cancelBubble = true; return false; &#125; &#125;); //标准浏览器 &#125; else &#123; obj.addEventListener(sEv, function(ev) &#123; //false表示冒泡，true表示捕获，大多数情况下用冒泡不用捕获 if(false == fn.call(obj)) &#123; event.cancelBubble = true; ev.preventDefault(); &#125; &#125;, false); &#125;&#125;//封装on()函数Yquery.prototype.on = function(sEv, fn) &#123; //不同的选择器可能选择多个元素，给每个选中的元素都需要添加on()方法 var i = 0; //循环的给每个元素都绑定事件 for(i = 0; i &lt; this.elements.length; i++) &#123; //给每个元素绑定sEv事件，执行fn函数 myAddEvent(this.elements[i], sEv, fn); &#125;&#125; 我们来测试一个看看是不是能阻止冒泡呢 123456789101112131415&lt;body&gt;&lt;div style=\"background:red;\"&gt; &lt;div style=\"background:green;\"&gt; &lt;div style=\"background:#CCC;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;$(function ()&#123; $('div').click(function ()&#123; console.log(this.style.background); return false; &#125;);&#125;);&lt;/script&gt; 至此，我们已经封装好了on()函数，并且可以阻止冒泡和阻止默认事件。 20.插件机制插件机制：其实就是给Yquery原型上添加一个方法， 有两个参数，一个是方法的名称，另一个是方法的执行过程。 Yquery.js： 12345Yquery.prototype.extend = function(name, fn)&#123; Yquery.prototype[name] = fn;&#125;; 利用$().extend(function(){})方法动态添加插件/方法 12$().extend(\"name\",function()&#123;&#125;) 我们可以来测试下这样的方法到底可不可以动态的给Yquery添加方法。 举例： 添加size()方法，获取页面中的元素的个数。 123456789101112131415161718192021222324252627 &lt;style&gt; div &#123; width: 50px; height: 50px; background-color: red; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $().extend('size', function() &#123; return this.elements.length; &#125;) $(function()&#123; console.log($('div').size()); console.log($('div').find('span').size()); &#125;)&lt;/script&gt; 运行结果： 我们可以正确的得到页面中元素的个数，至此我们的Yquery.js就封装好了。 源代码见我的仓库地址：https://github.com/255255255255/Yquery 接下来，我们就可以封装各类的框架，使我们的Yquery.js更加强大。 21.animate()插件的封装：Yquery_animate.jsanimate()方法的参数其实只有一个，就是json字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465$().extend('animate', function (json)&#123; var i=0; //让被选择器选中的元素，也就是elements数组中的每个元素都添加动画效果 for(i=0;i&lt;this.elements.length;i++) &#123; startMove(this.elements[i], json); &#125; function getStyle(obj, attr) &#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125; &#125; function startMove(obj, json, fn) &#123; clearInterval(obj.timer); obj.timer=setInterval(function ()&#123; var bStop=true; //这一次运动就结束了——所有的值都到达了 for(var attr in json) &#123; //1.取当前的值 var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(obj, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(obj, attr)); &#125; //2.算速度 var iSpeed=(json[attr]-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); //3.检测停止 if(iCur!=json[attr]) &#123; bStop=false; &#125; if(attr=='opacity') &#123; obj.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; obj.style.opacity=(iCur+iSpeed)/100; &#125; else &#123; obj.style[attr]=iCur+iSpeed+'px'; &#125; &#125; if(bStop) &#123; clearInterval(obj.timer); if(fn) &#123; fn(); &#125; &#125; &#125;, 30) &#125;&#125;); 那我们来测试一下吧 需要把Yquery.js和Yquery_animate.js文件都引入，才会出现效果。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background: red; filter: alpha(opacity:30); opacity: 0.3; &#125; &lt;/style&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script src=&quot;../Yquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../Yquery_animate.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $(&apos;input&apos;).toggle(function() &#123; $(&apos;#div1&apos;).animate(&#123; width: 200, height: 200, opacity: 100 &#125;); &#125;, function() &#123; $(&apos;#div1&apos;).animate(&#123; width: 100, height: 100, opacity: 30 &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;运动&quot; /&gt; &lt;div id=&quot;div1&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如图所见，出现了我们想要的动画效果，太开心了。和jQuery库中的animate()方法可是一点都不差呢！！可以用animate()方法制作上下焦点图、左右焦点图等，参考我的另一篇博客：在这里就不废话了。https://yingy0.github.io/2018/06/07/jQuery%E5%AE%9E%E4%BE%8B/ 22.drag()插件的封装Yquery_drag.js12345678910111213141516171819202122232425262728$().extend('drag', function ()&#123; var i=0; //让被选择器选中的元素，也就是elements数组中的每个元素都添加拖拽效果 for(i=0;i&lt;this.elements.length;i++) &#123; drag(this.elements[i]); &#125; function drag(oDiv) &#123; oDiv.onmousedown=function (ev) &#123; var oEvent=ev||event; var disX=oEvent.clientX-oDiv.offsetLeft; var disY=oEvent.clientY-oDiv.offsetTop; document.onmousemove=function (ev) &#123; var oEvent=ev||event; oDiv.style.left=oEvent.clientX-disX+'px'; oDiv.style.top=oEvent.clientY-disY+'px'; &#125;; document.onmouseup=function () &#123; document.onmousemove=null; document.onmouseup=null; &#125;; &#125;; &#125;&#125;); 那我们来测试一下： 需要把Yquery.js和Yquery_drag.js文件都引入，才会出现效果。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 50px; background-color: #F47500; position: absolute; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../Yquery.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../Yquery_drag.js\" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $('div').drag(); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注意：一定要给被拖动的元素设置定位(相对定位、固定定位)，才会出现拖动的效果。 源代码见我的仓库地址：https://github.com/255255255255/Yquery 由于在Github中的图片有时不能完全加载，详细请看我的博客https://yingy0.github.io/2018/05/28/Yquery/。","categories":[],"tags":[{"name":"Yquery","slug":"Yquery","permalink":"http://yoursite.com/tags/Yquery/"}],"keywords":[]},{"title":"jQuery对象和DOM对象","slug":"jQuery对象和DOM对象","date":"2018-06-27T02:05:32.000Z","updated":"2018-10-12T14:46:54.009Z","comments":true,"path":"2018/06/27/jQuery对象和DOM对象/","link":"","permalink":"http://yoursite.com/2018/06/27/jQuery对象和DOM对象/","excerpt":"","text":"JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，是一门十分强大的语言，Jquery是一个基于JavaScript的框架，它们之间有着千丝万缕的关系，我们一起来了解下吧。 JavaScript VS JQuery12345678910111213141516171819202122 &lt;body&gt; &lt;input type=\"button\" id=\"demo\" value=\"我是按钮\" /&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; document.getElementById(\"demo\").onclick = function() &#123; // 要实现的效果： // 1.让div展示出来 // 2.给div一段文本内容 var divs = document.getElementsByTagName(\"div\"); //获取一个数组 for(var i = 0; i &lt; divs.length; i++) &#123; divs[i].style.display = \"block\"; divs[i].innerText = \"我是文本内容\"; &#125; &#125;; &#125;;&lt;/script&gt; 这是用JavaScript写的，功能是点击一个按钮，就会把隐藏的div显示出来，并且给每个div添加一段文本内容。但是这段用js写的代码存在一个很大的问题。 问题1： 123456789101112131415&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; console.log(1); &#125; window.onload = function() &#123; console.log(2); &#125; window.onload = function() &#123; console.log(3); &#125; window.onload = function() &#123; console.log(4); &#125;&lt;/script&gt; 如果页面存在很多个onload函数，会有什么后果呢？ 运行结果：4 所以说结果是弹出最后一个onload，window.onload存在事件覆盖的问题，也就是说第四个window.onload将前三个window.onload函数给覆盖了。 问题二: 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; document.getElementById(&quot;demo1&quot;).onclik = function() &#123; &#125;; document.getElementById(&quot;demo2&quot;).onclick= function()&#123; &#125;; &#125;;&lt;/script&gt; 若绑定的”demo1”的id值不存在，则打开浏览器的控制台会看到错误的消息，不再执行下去，所以会影响绑定的”demo2”中功能的执行，代码的容错率太低，对用户来说不希望是这样的。 问题三:各大主流浏览器的兼容性问题： innerText属性支持谷歌浏览器。不支持火狐浏览器，利用innerHtml属性存在着各种兼容性问题。 总结： window.onload事件只出现一次，如果出现多次，后面的事件会覆盖掉前面的事件 代码的容错行为，我们不希望看到错误 简单功能实现很繁琐，例如渐变的动画效果。 了解JQueryjQuery和JS库的联系与区别 jQuery其实是js的一个库（框架），它封装了我们开发中常用的一些功能，方便我们调用，提高了我们的开发效率，jQuery库：是别人帮我们封装好的js库 Js库，它把我们常用的功能放到单独一个文件中，用的时候直接拿到我们的页面中来就可以了。 123456789&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"#demo\").click(function()&#123; $(\"div\").show(1000).html(\"这是一段文本\"); &#125;); &#125;);&lt;/script&gt; 大家可以清晰地看到用jQuery实现同样的效果比用原生的javascript见得到的多了。并且不存在兼容性问题、不存在覆盖问题。这个大家不相信的话可以自己试一下。 12345678910111213141516 &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; console.log(1); &#125;);$(document).ready(function()&#123; console.log(2); &#125;); $(document).ready(function()&#123; console.log(3); &#125;); $(document).ready(function()&#123; console.log(4); &#125;); &lt;/script&gt; 输出结果： 大家这下相信相信不会存在覆盖问题了吧，应该也体会到了jQuery的强大了。 JQuery还有一个非常牛逼的地方就是即使你代码中某些部分写错了，真正的效果在浏览器执行不出来，但是在浏览器的控制台中你不会看到错误，如果控制台没有报错，我们调试的时候要怎么办呢，这就需要我们掌握一定的调试jQuery代码的技巧。 jquery的优势 jQuery核心理念 wirte less,do more 链式编程、隐式迭代。 jquery基本使用步骤: jquery特点： Lightweight Footprint：非常轻量级，其实压缩版源文件有80KB~90KB之间，但是官网上说的是30kb,这是什么原因呢？因为gzip,当浏览器真正加载的时候会经过http请求，这时候只要服务器开启gzip压缩，它的体积就能缩小到30KB，它同时支持AMD规范(模块化开发、按需加载)。 css3 Compliant：支持所有css3的选择器，降低了学习的难度。 Cross-Browser：跨浏览器兼容、IE6版本以上的浏览器都支持。 注意: $ === jQuery $代表了我们jQuery的对象，只要操作jQuery就可以用$开始。 jQuery占用了$和jQuery这两个变量，我们不要再去声明这两个变量，否则会报错。 Js命名规范：数字、字母、下划线. 如果自己用var声明一个$符号，那jQuery的函数将不起作用 JQuery入口函数12345678910111213141516171819202122//第一种写法：$(document).ready(function()&#123; &#125;);//第二种写法：一般不使用jQuery(document).ready(function()&#123; &#125;);//第三种写法$(function()&#123; &#125;);//第四种写法$(window).load(function()&#123; &#125;); jQuery的入口函数与JavaScript的入口函数区别 window.onload等到所有的外部资源加载完毕之后才执行，外部资源包括外部的图片文件、css文件、js文件、视频文件、音频文件等等…… 让一些不同的线程去加载那些外部的文件，jQuery是在主进程加载完之后就立即执行，也就是说jQuery不用等到所有的外部文件都加载完成才去执行，而那些外部文件就交给线程来执行。也这样理解，jQuery是使得一旦页面的文档对象模型（DOM树）变为安全的操纵，就立即运行JavaScript代码。 jquery中ready()函数的执行时机要比JavaScript中window.onload函数的时间要早。 jquery中这样的加载机制也存在着一定的问题，比如说你想要获取一张图片的高度时，可能就获取不到，因为可能这时候你想获取的图片的还没被加载进来，如果想要获取图片的高度，还必须放在window.onload中。 在JQuery和中JavaScript存在着这样的一个恒等式,所以如果在JQuery要获取图片的高度，必须要将获取图片宽度或者高度的代码放在这样的入口函数中。 $(window).load(function(){}) === window.onload jquery对象与DOM对象jquery对象与DOM对象之间的区别 12345678910111213&lt;input type=\"button\" value=\"我是按钮\" id=\"btn1\"/&gt; &lt;script type=\"text/javascript\"&gt; //javaScript方式获取按钮的id window.onload=function ()&#123; document.getElementById(\"btn1\").onclick=function()&#123; &#125; &#125; //jQuery方式获取按钮的id值 $(document).ready(function()&#123; $(\"#btn1\").click(function()&#123; &#125;) &#125;)&lt;/script&gt; 问题：为什么一个是JavaScript调用onclick()方法而jquery调用click()方法？ 因为jQuery中只有click方法，没有onclick方法，并且click方法和onclick方法功能相同，却更加简单。 JavaScript中既有onclick()方法又有click()方法，但是这两个方法有着稍微的区别。 12345678910111213&lt;input type=\"button\" value=\"我是按钮\" id=\"btn1\"/&gt;&lt;input type=\"button\" value=\"我是按钮\" id=\"btn2\"/&gt;//实现的功能：javaScript方式:用第二个按钮去触发第一个按钮的事件 window.onload = function() &#123; document.getElementById(\"btn1\").onclick = function ()&#123; console.log(\"我是第一个按钮\") &#125; document.getElementById(\"btn2\").onclick = function() &#123; document.getElementById(\"btn1\").click(); &#125; &#125;&lt;/script&gt; 用第二个按钮的事件去触发第一个按钮的事件，这就是javascript对象中click方法的作用。 注意：jQuery中所有的事件名称都不带”on”,原生的javaScript中既有带”on”的事件也有不带”on”的事件。 1234567891011&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; var $btn=$(\"#btn1\"); console.log($btn); &#125;); window.onload=function()&#123; var btn=document.getElementById(\"btn2\") console.log(btn); &#125; &lt;/script&gt; 运行结果： 大家根据运行结果应该能清晰地看出jquery和DOM对象的区别了吧。 jquery对象与DOM对象的互相转换 把jQuery对象转化为DOM对象的主要用途就是为了使用DOM对象中的某些方法。也就是说，当jquery对象转化成DOM对象之后，就可以调用带”on”的事件了，比如说onclick事件、onchange事件等。 12345678910111213$(document).ready(function()&#123; //jQuery对象转化为DOM对象 //第一种方式$(\"btn1\")[0].onclick=function() &#123; console.log(\"我是jQuery对象转化来的\");&#125; //第二种方式$(\"btn1\").get(0).onclick=function() &#123; console.log(\"我是jQuery对象转化来的\");&#125; &#125;);&lt;/script&gt; 问题1：为什么是这样形式的转换？ 原因：jQuery实际上把选取到的DOM对象转化成一个数组，放在自己的一个集合中，然后封装成了一个jQuery对象，把选择的第一个元素就放到了第一个位置，其实获取到的对象是一个类数组，并不是纯粹的数组。 问题2：那数组中取值为什么是0？ 因为通过id选择器获得只有唯一的一个，只需要转化一个，所以只取数组的第一个值就行了，下为标0。如下代码 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; $(&quot;btn1&quot;)[0].onclick=function()&#123;&#125;;//等价 //等价 var $btn=[document.getElementById(&quot;btn1&quot;)]; //类数组，下标从0开始 $btn[0].onclick=function()&#123; &#125;&#125;);&lt;/script&gt; 注意，因为不仅仅是存在着id选择器、还有标签选择器、还有类选择器，通过这类的选择器一次性可以获取多个，如下图，jquery内部实现机制并没有办法一次性将全部的jquery对象转化为DOM对象，jQuery实际上把选取到的某一个DOM对象转化成一个数组。 jQuery绑定事件123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt;//第一种写法：$(document).ready(function()&#123; 事件源.事件(function()&#123; 事件处理程序 &#125;); &#125;);//第二种写法：$(function()&#123; 事件源.事件(function()&#123; 事件处理程序 &#125;); &#125;);&lt;/script&gt; jQuery版本问题 jQuery 1.xxx和jQuery 2.xxx版本之间的区别： jQuery2版本的体积更小，并且不再支持IE6,7,8浏览器，从IE9浏览器以上开始支持。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery-color","slug":"jQuery-color","date":"2018-06-27T00:43:53.000Z","updated":"2018-10-12T13:49:00.205Z","comments":true,"path":"2018/06/27/jQuery-color/","link":"","permalink":"http://yoursite.com/2018/06/27/jQuery-color/","excerpt":"","text":"jQuery ColorUsing jQuery Color in ProductionWe release jQuery Color by itself, or in a bundle. The extended names can be included as a jQuery Color plugin, or you can download the version of jQuery Color that includes the names. Choose your build from the following list: Current version: 2.1.2 jQuery Color Compressed Uncompressed jQuery Color Extended Names Compressed Uncompressed jQuery Color &amp; Extended Names(previous two combined) Compressed Uncompressed How to build and test jQuery ColorFirst, get a copy of the git repo by running: 1git clone git://github.com/jquery/jquery-color.git Enter the directory and install the node dependencies: 1cd jquery-color &amp;&amp; npm install Make sure you have grunt installed by testing: 1grunt -version If not, run: 1npm install -g grunt To run tests locally, run grunt, and this will run the tests in PhantomJS. You can also run the tests in a browser by navigating to the test/ directory. Animated colorsThis plugins installs a cssHook which allows jQuery’s .animate() to animate between two colors. Supported propertiesbackgroundColor, borderBottomColor, borderLeftColor, borderRightColor, borderTopColor, color, columnRuleColor, outlineColor, textDecorationColor, textEmphasisColor Example use12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div &#123; background-color: #bada55; width: 100px; border: 1px solid green;&#125;&lt;/style&gt;&lt;script src=\"http://code.jquery.com/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.color.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"go\"&gt;Simple&lt;/button&gt;&lt;button id=\"sat\"&gt;Desaturate&lt;/button&gt;&lt;div id=\"block\"&gt;Hello!&lt;/div&gt;&lt;script&gt;jQuery(\"#go\").click(function()&#123; jQuery(\"#block\").animate(&#123; backgroundColor: \"#abcdef\" &#125;, 1500 );&#125;);jQuery(\"#sat\").click(function()&#123; jQuery(\"#block\").animate(&#123; backgroundColor: jQuery.Color(&#123; saturation: 0 &#125;) &#125;, 1500 );&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Supporting other propertiesThe jQuery.Color.hook() function can be called to support additional css properties as colors, and allow them to be animated. Example use12// we want to animate SVG fill and stroke propertiesjQuery.Color.hook( \"fill stroke\" ); The jQuery.Color FactoryThe jQuery.Color() function allows you to create and manipulate color objects that are accepted by jQuery’s .animate() and .css() functions. Returns a new Color object, similar to jQuery() or jQuery.Event Accepts many formats to create a new Color object with a jQuery.Color.fn prototype Example uses:123456789101112131415// Parsing String Colors:jQuery.Color( \"#abcdef\" );jQuery.Color( \"rgb(100,200,255)\" );jQuery.Color( \"rgba(100,200,255,0.5)\" );jQuery.Color( \"aqua\" );// Creating Color Objects in Code:// use null or undefined for values you wish to leave outjQuery.Color( red, green, blue, alpha );jQuery.Color([ red, green, blue, alpha ]);jQuery.Color(&#123; red: red, green: green, blue: blue, alpha: alpha &#125;);jQuery.Color(&#123; hue: hue, saturation: saturation, lightness: lightness, alpha: alpha &#125;);// Helper to get value from CSSjQuery.Color( element, cssProperty ); jQuery.Color.fn / prototype / the Color Object methodsGetters / Setters:123456789101112131415161718192021222324252627red() // returns the \"red\" component of the color ( Integer from 0 - 255 )red( val ) // returns a copy of the color object with the red set to valgreen() // returns the \"green\" component of the color from ( Integer from 0 - 255 )green( val ) // returns a copy of the color object with the green set to valblue() // returns the \"blue\" component of the color from ( Integer from 0 - 255 )blue( val ) // returns a copy of the color object with the blue set to valalpha() // returns the \"alpha\" component of the color from ( Float from 0.0 - 1.0 )alpha( val ) // returns a copy of the color object with the alpha set to valhue() // returns the \"hue\" component of the color ( Integer from 0 - 359 )hue( val ) // returns a copy of the color object with the hue set to valsaturation() // returns the \"saturation\" component of the color ( Float from 0.0 - 1.0 )saturation( val ) // returns a copy of the color object with the saturation set to vallightness() // returns the \"lightness\" component of the color ( Float from 0.0 - 1.0 )lightness( val ) // returns a copy of the color object with the lightness set to val// all of the above values can also take strings in the format of \"+=100\" or \"-=100\"rgba() // returns a rgba \"tuple\" [ red, green, blue, alpha ]// rgba() setters: returns a copy of the color with any defined values set to the new valuergba( red, green, blue, alpha )rgba(&#123; red: red, green: green, blue: blue, alpha: alpha &#125;)rgba([ red, green, blue, alpha ])hsla() // returns a HSL tuple [ hue, saturation, lightness, alpha ]// much like the rgb setter - returns a copy with any defined values sethsla( hue, saturation, lightness, alpha )hsla(&#123; hue: hue, saturation: saturation, lightness: lightness, alpha: alpha )hsla([ hue, saturation, lightness, alpha ]) String methods123toRgbaString() // returns a css string \"rgba(255, 255, 255, 0.4)\"toHslaString() // returns a css string \"hsla(330, 75%, 25%, 0.4)\"toHexString( includeAlpha ) // returns a css string \"#abcdef\", with \"includeAlpha\" uses \"#rrggbbaa\" (alpha *= 255) The toRgbaString and toHslaString methods will only include the alpha channel if it is not 1. They will return rgb(...) and hsl(...) strings if the alpha is set to 1. Working with other colors:123transition( othercolor, distance ) // the color distance ( 0.0 - 1.0 ) of the way between this color and othercolorblend( othercolor ) // Will apply this color on top of the other color using alpha blendingis( othercolor ) // Will determine if this color is equal to all defined properties of othercolor jQuery.Color propertiesInternals on The Color Object Internally, RGBA values are stored as color._rgba[0] = red, color._rgba[1] = green, color._rgba[2] = blue, color._rgba[3] = alpha. However, please remember there are nice convenient setters and getters for each of these properties. undefined/null values for colors indicate non-existence. This signals the transition() function to keep whatever value was set in the other end of the transition. For example, animating to jQuery.Color([ 255, null, null, 1 ]) would only animate the red and alpha values of the color. jQuery.Color.namesA list of named colors is stored on the jQuery.Color.names object. The value they contain should be parseable by jQuery.Color(). All names on this object should be lowercased. I.E. jQuery.Color(&quot;Red&quot;) is the same as doing jQuery.Color( jQuery.Color.names[&quot;red&quot;] ); There is also a named color &quot;_default&quot; which by default is white, this is used for situations where a color is unparseable. &quot;transparent&quot;A special note about the color &quot;transparent&quot; - It returns null for red green and blue unless you specify colors for these values. 1jQuery.Color(\"#abcdef\").transition(\"transparent\", 0.5) Animating to or from the value &quot;transparent&quot; will still use “#abcdef” for red green and blue. HSLA SupportIf a color is created using any of the HSLA functions or parsers, it will keep the _rgba array up to date as well as having a _hsla array. Once an RGBA operation is performed on HSLA, however, the _hsla cache is removed and all operations will continue based off of rgb (unless you go back into HSLA). The ._hsla array follows the same format as ._rbga, [hue, saturation, lightness, alpha ]. If you need to build an HSLA color from an HSLA array, jQuery.Color().hsla( array ) works for that purpose. Colors with 0 saturation, or 100%/0% lightness will be stored with a hue of 0 ExtensibilityIt is possible for you to add your own functions to the color object. For instance, this function will tell you if its better to use black or white on a given background color. 123456789// method taken from https://gist.github.com/960189jQuery.Color.fn.contrastColor = function() &#123; var r = this._rgba[0], g = this._rgba[1], b = this._rgba[2]; return (((r*299)+(g*587)+(b*144))/1000) &gt;= 131.5 ? \"black\" : \"white\";&#125;;// usage examples:jQuery.Color(\"#bada55\").contrastColor(); // \"black\"element.css( \"color\", jQuery.Color( element, \"backgroundColor\" ).contrastColor() );","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"jQuery之父-John Resig","slug":"John Resig","date":"2018-06-26T07:09:31.000Z","updated":"2018-10-12T13:48:53.156Z","comments":true,"path":"2018/06/26/John Resig/","link":"","permalink":"http://yoursite.com/2018/06/26/John Resig/","excerpt":"","text":"今天才在百度百科中看到有关John Resig(jQuery之父)的介绍，颇为佩服，有些可惜为什么没有早些看到，大神果真是大神，真的是大写加粗的酷，大神的高中和大学VS学渣本人的高中和大学，我真的是完败了，高中的我根本就没听说过JavaScript、我也是到了大二才知道了JavaScript，邓小平爷爷说得对,计算机要从娃娃抓起。 John Resig: JavaScript’s Chuck NorrisChuck Norris（查克·诺里斯，美国著名武术家，世界著名空手道巨星） 一篇有关John Resig有趣的文章Some of the regular irc.freenode..net #jquery guys have come to the conclusion thatJohn Resig, creator ofjQuery, is the JavaScript world’s equivalent of Chuck Norris, so we came up with some ideas and decided to pay homage to him in a blog post. （irc.freenode..net 的家伙们已经得到了一个结论：John Resig，这个jQuery的创造者，就是Javascript世界中的 Chuck Norris，所以让咱们发个帖儿来膜拜下这个大牛吧！）Note: he might actually beChuck Norris, we’re not entirely sure. John Resig has never made a carousel plugin.. when he goes to the carnival, ALL the rides support jQuery. （John Resig 从未做过旋转木马插件，因为当他去游乐场的时候，所有的木马都支持 jQuery） John Resig can kill you with two lines of code. Sure, he could do it with one, but the force of the explosion would cause the universe to collapse into a giant black hole. （John Resig 可以用两行代码干掉你！当然，他用一行就够了，但是爆炸的威力会让宇宙崩塌成一个巨大的黑洞） John Resig’s computer is custom-fitted with a titanium keyboard, because anything less substantial will melt. （John Resig的电脑特别定制了钛键盘，因为稍微脆弱一点的会熔化掉） $(“John Resig”).position(); returns “everywhere!”. （$(‘John Resig’).position(); 返回”无所不在！”） When John Resig types $.jump() the console prints “how high?” （当 John Resig 输入 $.jump()，控制台输出”多高？”） When John Resig types $.require(), it’s not a request, it’s a threat. （当 John Resig 输入$.require(), 记住，这不是一个请求，这是一个恐吓！） John Resig does not $.queue(). （哦！这家伙从来不排队！） John Resig scheduled a cron job to run “rm -rf /” sometime in 2012. How the heck did the Mayans know that? （John Resig 定义了一个计划任务，在 2012 年的某天运行”rm –rf/“，为什么玛雅人会知道？？） The last time John Resig used $.die(), they amended the Geneva Convention to expressly forbid it. （上一次 John Resig 用 $.die() 的时候，他们修订了日内瓦公约明确禁止这么做！- -） John Resig triggers onfocus ALL THE TIME. （John Resig 持续‘onfocus’ ） $(“John Resig”).length returns “14 inches”. （$(“John Resig”).length 返回~ 14 英寸！） John Resig doesn’t query the DOM, he just glances at it and gets all the elements he was expecting. （John Resig 从不查找 DOM，他只要扫一眼就会得到他想要的东西） When John Resig inspects an element, he sees the raw electrons. （John Resig 查看一个元素时，他看到的是原始的电子！） When John Resig edits his hosts file, he doesn’t need sudo. （当 John Resig 需要编辑 hosts 文件时，他不需要 sudo！） When John Resig runs scripts cross-domain, they just run. （当 John Resig 运行跨域脚本时，那就随便他运行吧~！！） John Resig doesn’t wait for the DOM to be ready, it waits for him to be ready. （John Resig 从不等待 DOM 变为 ready 状态，DOM 都在等他 ready） When John Resig tests isNaN(), it had better not be a number. （John Resig 检测 isNaN() 时，它最好不是一个数字） John Resig’s commits ignore all post-commit hooks, because John Resig always has the last word. （John Resig 提交新版本不需要写注释，因为 John Resig 也永远说不完） 源英文地址：http://benalman.com/news/2009/12/john-resig-javascripts-chuck-norris/ 关于John Resig的访谈(27岁的他)编程初体验《程序员》：你是如何开始编程的？ John Resig：第一次编程大概是在初中，14、15岁，当时有个朋友带来张软盘，里面有QBASIC。在DOS系统下他向我展示了他自己的程序，我觉得非常有意思。从那时起我就开始想编程了，先后借了很多相关的书。最初是学习编写HTML，之后又转向CGI。 《程序员》：你编写的第一个有意思的程序是什么，还有印象吗？ John Resig：高中时，有一阵我通过编写网站应用来挣钱。我还会做一些诸如网站设计的工作，当然没有专业人员做得那么好。记得曾编写了一个订早餐的网页应用，让那些熬夜无暇早起买早餐的人通过这个网页应用订餐。不过，这还算不上最有意思的程序。我的第一个最有趣的程序是在大学时编写的。那时我们要建立自己的时间表，以分配好上课时间，所以我编了一个选课的程序，它可以推荐出最优的选课结果，例如：如果你要选数学、计算机和除此之外的一门科学课程，程序可以推荐出可在一天内完成三门课程的时间表，这样你就有六天的空闲时间去做自己想做的事情。 《程序员》：学生时代的生活和以后的编程生涯，两者之间有没有内在的联系？ John Resig：这说不太清楚，我喜欢编程，它可以让我完全理解一个东西。选择Web编程是因为自己愿意做别人不乐意做的事情。比如很多人不愿意处理同样的网页在不同浏览器下表现各异的问题。但这很有挑战，也很有乐趣。 《程序员》：能不能谈谈你在大学生活中印象最深的事情？ John Resig：对我来说最重要的事情，是那些计算机科学课程。大学期间我并没做很多Web编程，而是做了很多和数据库相关的工作。这是我感兴趣的方面。我还喜欢研究社区，做数据挖掘研究，其中就包括判断社交网站怎样增长之类，那时我还发表了两篇关于数据挖掘的论文。离开大学后，我又回到Web编程，尽管数据挖掘很有意思，但我还是觉得Web编程的吸引力更大。 《程序员》：大学最喜欢的计算机课程有哪些？ John Resig：我喜欢有挑战性的课。例如XML，我本来以为课程很简单，可以轻松得个A。结果老师第一堂课就把我知道的东西都讲完了，从第二节课开始所讲内容我完全听不懂，很难学，结果我得了B。但我还是很自豪，因为学了很多东西。 jQuery 背后的故事《程序员》：向我们透露一些jQuery背后的故事吧。最开始您是怎样做的？ John Resig：做Web编程时，我非常讨厌浏览器的Bug，不同的浏览器有不同的Bug，而且数量非常多。于是我用JavaScript做了CSS选择引擎，之后还做了个动画引擎，都是自娱自乐。但与此同时我发现自己不能将制作的一些应用放到浏览器里。为了将应用放到Firefox浏览器中，我开始制作相关的API，以应用那个CSS选择引擎和动画引擎，这些最终成为了jQuery。几个月后，我将那些应用做进Firefox里，之后在IE里也可以运行。如今这仍是我的目标——让每个人都可以在网页里写点什么，并且写的东西能够在浏览器中顺利运行出来。 《程序员》：支撑jQuery的基本原理有哪些？ John Resig：原则很简单。作为一名程序员，我希望代码简洁，不希望在编程的时候不停地重复某些内容，设计jQuery的目标就是为了简化代码，使程序更高效。 《程序员》：jQuery是如何把简单和高效结合在一起的？ John Resig：很多人想直接做大项目，例如像Gmail、Yahoo!Mail之类。但实际上通过很简单的过程也可以解决大项目中一些很困难的关键点，化大为小，化繁为简，jQuery就是这样做的。 《程序员》：如果能重新再来一次，你会在哪些方面做出设计改变？ John Resig：我要改一些方法的名称。初期在命名上出现了一些失误，后来我花了很多时间才理解到jQuery应该是现在这样。有些事情如果一开始就做好，可能会少走很多弯路。 《程序员》：谈谈jQuery的研发过程吧。 John Resig：我们主要的资源是jQuery的Bug Tracker，有一个Team专门经营Bug Tracker。我负责修改这些Bug。最终我们有一个需要修改的Bug列表。然后有人改程序，提交给别人通过，并处理这些Bug。大多数时候都是我来改Bug，发布新版本。 《程序员》：中国的程序员该如何做才能参加到这个项目？ John Resig：直接加入就可以。所有人都可以看到内部的每次代码提交，然后更优秀的程序员会加入Bug Tracker。他们能看到我们发现问题和处理问题的整个过程，从而学会怎样发布补丁。我们的小组一共20个人，只有3个代码的贡献者，其余17人都在做各种各样其他事情。jQuery网站是世界排名前700位的网站，所以有很多工作需要处理。 《程序员》：在中国有没有正式的文档网站？ John Resig：有jQuery..org..cn，但这不是正式的，不过里面有jQuery文档的翻译资料。我们急需有人帮助翻译这些文档。 《程序员》：jQuery的未来怎样？ John Resig：我们基本不加入新功能，目前大多数工作都是优化，让jQuery变得更快、更强、更容易理解。未来的工作也是优化，使jQuery功能更清晰化。","categories":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}],"tags":[{"name":"大神","slug":"大神","permalink":"http://yoursite.com/tags/大神/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/categories/资源/"}]},{"title":"jQuery常用方法之事件对象","slug":"JQuery常用方法之事件对象","date":"2018-06-25T01:18:10.000Z","updated":"2018-10-12T14:47:02.214Z","comments":true,"path":"2018/06/25/JQuery常用方法之事件对象/","link":"","permalink":"http://yoursite.com/2018/06/25/JQuery常用方法之事件对象/","excerpt":"","text":"事件对象1. currentTarget和target如果用JQuery方式绑定的，那么e就是JQuery的事件对象，同理：如果用DOM方式绑定的，那么e就是DOM的事件对象。 我们都知道on()函数给元素绑定事件有几种不同的情况，我们可以来看下。 第一种情况：没有父元素,直接绑定 12345678910&lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"button\").on(\"click\",function(e)&#123; console.log(e); &#125;) &#125;)&lt;/script&gt; currentTarget和target都指向子元素。 第二种情况：有父元素，给子元素绑定 123456789101112&lt;body&gt;&lt;div&gt; &lt;button&gt;我是按钮&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $(&quot;div&quot;).on(&quot;click&quot;,&quot;button&quot;,function(e)&#123; console.log(e); &#125;) &#125;)&lt;/script&gt; currentTarget和target都指向子元素。 第三种情况：有父元素，给父元素绑定事件。 123456789101112&lt;body&gt;&lt;div&gt; &lt;button&gt;我是按钮&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"div\").on(\"click\",function(e)&#123; console.log(e); &#125;) &#125;)&lt;/script&gt; currentTarget指向父元素、target指向子元素。 总结： currentTarget的值等于this,给谁绑的事件就指向谁，也就是说永远指向的是事件绑定对象。 target:一直指向真正触发事件的对象(事件源)，通过冒泡的方式触发了父元素的单击事件. 2. preventDefault()：阻止默认事件行为的触发大家都知道提交按钮会改变浏览器的默认行为，&lt;a&gt;标签会有自动跳转到指定链接的默认行为，现在我们可以利用preventDefault()事件来阻止提交按钮的默认行为，阻止&lt;a&gt;链接跳转的默认行为。 举例： 1234567891011121314&lt;body&gt; &lt;input type=\"submit\" value=\"我是提交按钮\"&gt;&lt;/input&gt; &lt;a href=\"http://www.baidu.com\"&gt;&lt;/a&gt;&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"input\").on(\"click\",function(e) &#123; e.preventDefault(); &#125;) $(\"a\").on(\"click\",function(e) &#123; e.preventDefault(); &#125;) &#125;) &lt;/script&gt; 运行结果：&lt;a&gt;链接不跳转，提交按钮没有改变浏览器的默认行为。 3. stopPropagation()：阻止事件冒泡1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"div\").on(\"click\",\"button\", function(e) &#123; console.log(\"我是按钮\"); e.stopPropagation(); &#125;) $(\"div\").on(\"click\", function(e) &#123; console.log(\"我是div\"); &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;/body&gt;&lt;/html&gt; 没有阻止冒泡：删除e.stopPropagation() 因为给&lt;div&gt;绑定单击事件，有两层的div，两层的div下面都有&lt;button&gt;元素，所以总共是4次冒泡 如果换成这样的形式,给&lt;button&gt;绑定单击事件，就是三次冒泡。 123456789101112131415161718&lt;body&gt; &lt;div&gt; &lt;div&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"button\").on(\"click\",function(e) &#123; console.log(\"我是按钮\"); // e.stopPropagation(); &#125;) $(\"div\").on(\"click\", function(e) &#123; console.log(\"我是div\"); &#125;) &#125;) &lt;/script&gt; 阻止了冒泡：添加e.stopPropagation(); 1234567891011&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"div\").on(\"click\",\"button\", function(e) &#123; console.log(\"我是按钮\"); e.stopPropagation(); &#125;) $(\"div\").on(\"click\", function(e) &#123; console.log(\"我是div\"); &#125;) &#125;) &lt;/script&gt; 4.data：获取on()的第三个参数值,这个参数可以是数值型、对象性、字符串型、数组型等。注意：这里必须用on的方式绑定事件 举例： 123456789101112131415&lt;body&gt; &lt;div&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"div\").on(\"click\",\"button\",1111, function(e) &#123; console.log(e.data); &#125;) $(\"div\").on(\"click\",\"button\",&#123;\"a\":1111&#125;, function(e) &#123; console.log(e.data); &#125;) &#125;)&lt;/script&gt; 链式编程: return this;在javascript中的存在的原型链： 12345678910111213141516&lt;script&gt; function Person(name, age) &#123; this.name = name; this.age = age; this.setAge = function() &#123; //这里的this指的是新创建出来对象p this.age++; console.log(this.age) return this; //这里的this指的是调用的对象p &#125; this.show=function()&#123; return this; &#125; &#125; var p = new Person(&quot;张三&quot;,&quot;20&quot;); p.setAge().setAge().show().setAge();&lt;/script&gt; 只要函数中有return this，就可以组成原型链。 注意：在jQuery中，一旦出现获取操作，JQuery的链式就断掉了。因为获取属性的值一般返回的是一个字符串，而不是一个对象，没办法在加入到链中。也就是说获取属性操作是jQuery链接的终点。 在jQuery中，任意多个设置属性操作可以组成一个较长的链条 12345678&lt;script&gt;$(document).ready(function()&#123; $(\"div\") .css(\"background-color\",\"red\") //设置值 .css(\"font-size\",\"30px\")//设置值 .css(\"color\")//获取值 &#125;)&lt;/script&gt; 隐式迭代默认情况下，会自动迭代执行jQuery选择出来所有DOM元素的操作。 如果获取的是多元素的值，默认返回的是第一个元素的值。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之事件","slug":"JQuery常用方法之事件","date":"2018-06-22T07:09:31.000Z","updated":"2018-10-12T14:47:04.036Z","comments":true,"path":"2018/06/22/JQuery常用方法之事件/","link":"","permalink":"http://yoursite.com/2018/06/22/JQuery常用方法之事件/","excerpt":"","text":"事件-&gt;页面载入1.ready()：当DOM准备就绪时，指定一个函数来执行。描述： ready()方法提供了一种方法，使得一旦页面的文档对象模型（DOM）变为安全的操纵，就立即运行JavaScript代码。这往往是执行与页面的用户视图或交互之前需要任务的好时机。 浏览器还提供了window对象上的load事件。当这个事件触发时候，表明该网页上的所有资源已加载，包括图像。此事件可以使用jQuery的$( window ).on( &quot;load&quot;,function(){})监听。当代码依赖加载的资源情况下，（例如，必需知道图像的尺寸时），那么代码应放置在一个load事件的处理程序中。 ready() 方法通常用于一个匿名函数： 123456789//第一种方式$( document ).ready(function() &#123;&#125;);//第二种方式$(function() &#123;&#125;); 事件-&gt;事件处理2.bind()：为一个元素绑定一个事件处理程序3.0以上的版本已经废除了 12345678910&lt;script&gt;$(document).ready(function()&#123; //绑定一个事件 $(\"#btn\").bind(\"click\",function()&#123; &#125;) //绑定多个事件 $(\"#btn\").bind(\"click mouseenter\",function()&#123; &#125;)&#125;)&lt;/script&gt; 可以通过传递一个事件类型/处理函数的数据键值对映射来绑定多个事件处理程序 12345678$('#foo').bind(&#123; click: function() &#123; &#125;, mouseenter: function() &#123; &#125;&#125;); 举例： 2.1.为段落标签绑定单击和双击事件。 注意：坐标是相对于窗口的，在这个示例中是相对于iframe的。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; p &#123; background: yellow; font-weight: bold; cursor: pointer; padding: 5px; &#125; p.over &#123; background: #ccc; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Click or double click here.&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;script&gt; $(function() &#123; $(\"p\").bind(\"click\", function(event) &#123; var str = \"( \" + event.pageX + \", \" + event.pageY + \" )\"; $(\"span\").text(\"Click happened! \" + str); &#125;); $(\"p\").bind(\"dblclick\", function() &#123; $(\"span\").text(\"Double-click happened in \" + this.nodeName); &#125;); $(\"p\").bind(\"mouseenter mouseleave\", function(event) &#123; $(this).toggleClass(\"over\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2.点击段落时，显示其中的内容： 123$(\"p\").bind(\"click\", function()&#123;alert( $(this).text() );&#125;); 2.3.在事件处理之前，可以传入一些额外的数据： 1234function handler(event) &#123;alert(event.data.foo);&#125;$(\"p\").bind(\"click\", &#123;foo: \"bar\"&#125;, handler) 2.4.通过返回false的方式取消默认的动作，并防止它进行事件冒泡： 1$(\"form\").bind(\"submit\", function() &#123; return false; &#125;) 2.5.通过使用.preventDefault()方法，仅取消默认的动作。 123$(\"form\").bind(\"submit\", function(event) &#123;event.preventDefault();&#125;); 2.6.通过使用.stopPropagation()方法，防止事件冒泡，但是默认执行默认的动作。 123$(\"form\").bind(\"submit\", function(event) &#123; event.stopPropagation();&#125;); 2.7.同时绑定多个事件。 1234567891011$(\"div.test\").bind(&#123; click: function()&#123; $(this).addClass(\"active\"); &#125;, mouseenter: function()&#123; $(this).addClass(\"inside\"); &#125;, mouseleave: function()&#123; $(this).removeClass(\"inside\"); &#125;&#125;); 3.unbind()：从元素上删除一个以前附加事件处理程序123456789101112131415&lt;script&gt;$(document).ready(function()&#123; //解绑一个事件 $(\"#btn\").bind(\"click\",function()&#123; //解绑了选择到元素的click事件s $(\"#btn\").unbind(\"click\"); &#125;) //解绑多个事件 $(\"#btn\").bind(\"click mouseenter\",function()&#123; //解绑了选择到元素的click事件 $(\"#btn\").unbind(\"click\"); $(\"#btn\").unbind(\"mouseenter\"); &#125;)&#125;)&lt;/script&gt; 上面的代码绑定了几个事件就要写几次绑定比较的麻烦，如果绑定的时候给每个事件加上&quot;.namespace&quot;，那么解绑的时候，只需要写一次就好了。 123456789101112$(document).ready(function()&#123; //绑定一个事件 $(\"#btn\").bind(\"click.namespace\",function()&#123; &#125;) //绑定多个事件 $(\"#btn\").bind(\"mouseenter.namespace\",function()&#123; &#125;) $(\"#btn1\").bind(\"click\",function()&#123; $(\"#btn1\").unbind(\".namespace\"); &#125;)&#125;) 注意：bind()、click()事件都无法为动态创建的元素绑定事件===&gt;解决办法：用on()方法来绑定事件 4.on()：在选定的元素上绑定一个或多个事件处理函数和delegate方法类似，如果需要为子元素绑定事件，直接给父元素绑定即可，并且支持动态创建的元素的绑定 语法格式：$(selector).on( events [, selector ] [, data ], handler ) 参数介绍： 第一个参数：events，事件名 第二个参数：selector,类似delegate(子选择器) 第三个参数: 传递给事件响应方法的参数 第四个参数：handler，事件处理函数 举例： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; //动态给p元素添加子元素 $(\"input:eq(2)\").click(function()&#123; $(\"p\").append(\"&lt;h1&gt;我是动态创建的元素&lt;/h1&gt;\") &#125;) //使用on的方式给p元素的所有子元素绑定事件 $(\"p\").on('click','input',function()&#123; console.log($(this).val()); &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;input type=\"button\" value=\"绑定事件\"/&gt; &lt;input type=\"button\" value=\"解绑事件\"/&gt; &lt;input type=\"button\" value=\"动态创建元素\"/&gt; &lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; on()不仅可以给指定元素的子元素绑定事件，还可以给自身绑定事件,很简单，就不需要指定第二个参数即可。 1234//使用on的方式给p元素本身添加事件 $(\"p\").on('click',function()&#123; &#125;) 注意：如果省略selector或者是null，那么事件处理程序被称为直接事件或者直接绑定事件。每次选中的元素触发事件时，就会执行处理程序，不管它直接绑定在元素上，还是从后代（内部）元素冒泡到该元素的 说明： 当提供selector参数时，事件处理程序是指为委派事件。事件不会在直接绑定的元素上触发，但当selector参数选择器匹配到后代（内部元素）的时候，事件处理函数才会被触发。jQuery会从event target开始向上层元素(例如，由最内层元素到最外层元素)开始冒泡，并且在传播路径上所有绑定了相同事件的元素若满足匹配的选择器，那么这些元素上的事件也会被触发。 委托事件有一个极大的优势，他们能在后代元素添加到文档后，可以处理这些事件。在确保所选择的元素已经存在的情况下，进行事件绑定时，您可以使用委派的事件，以避免频繁的绑定事件及解除绑定事件。 例如，在一个表格的tbody中含有1,000行，下面这个示例会为这1,000元素绑定事件： 123$( \"#dataTable tbody tr\" ).on( \"click\", function() &#123; console.log( $( this ).text() );&#125;); 一个委派事件的方法只在一个元素上绑定一个事件处理程序，下面的代码是绑定在tbody元素上，并且事件只会向上冒泡一层（从被点击的tr 到 tbody ）: 123$( \"#dataTable tbody\" ).on( \"click\", \"tr\", function() &#123; console.log( $( this ).text() );&#125;); 举例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p&#123; width: 300px; height: 100px; background-color: aqua; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; //动态给p元素添加子元素 $(\"input:eq(2)\").click(function()&#123; $(\"p\").append(\"&lt;h1&gt;我是动态创建的元素&lt;/h1&gt;\") &#125;) //使用on的方式绑定事件 $(\"p\").on('click','input',function()&#123; console.log($(this).val()) &#125;) $(\"p\").on('click',function()&#123; console.log($(this).html()) &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;input type=\"button\" value=\"绑定事件\"/&gt; &lt;input type=\"button\" value=\"解绑事件\"/&gt; &lt;input type=\"button\" value=\"动态创建元素\"/&gt; &lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 调用event.stopPropagation()和 event.preventDefault()会从一个事件处理程序会自动返回false。也可以直接将false当作handler的参数，作为 function(){ return false; }的简写形式 实例： 4.1.当点击段落时，显示该段落中的文本： 123$(\"p\").on(\"click\", function()&#123;alert( $(this).text() );&#125;); 4.2.向事件处理函数中传入数据，并且在事件处理函数中通过名字来获取传入的数据： 1234function myHandler(event) &#123; alert(event.data.foo);&#125;$(\"p\").on(\"click\", &#123;foo: \"bar\"&#125;, myHandler) 4.3.取消表单的提交动作，并且通过返回 false 的方法来防止事件冒泡： 1$(\"form\").on(\"submit\", false) 4.4.通过使用preventDefault()，仅取消默认的动作。 123$(\"form\").on(\"submit\", function(event) &#123; event.preventDefault();&#125;); 4.5.通过使用.stopPropagation()，防止提交事件的冒泡行为，但是并不禁止提交行为。 123$(\"form\").on(\"submit\", function(event) &#123; event.stopPropagation();&#125;); 4.6.传递一个data数据给.trigger()的事件处理程序，作为第二个参数。 1234$( \"div\" ).on( \"click\", function( event, person ) &#123; alert( \"Hello, \" + person.name );&#125;);$( \"div\" ).trigger( \"click\", &#123; name: \"Jim\" &#125; ); 4.7.传递一个数组给.trigger()的事件处理程序，作为第二个参数。 1234$( \"div\" ).on( \"click\", function( event, salutation, name ) &#123; alert( salutation + \", \" + name );&#125;);$( \"div\" ).trigger( \"click\", [ \"Goodbye\", \"Jim\" ] ); 5.off()：解绑事件关于事件的解绑，有两种比较重要的方式，大家一定要知道的。 第一种形式: $(&quot;p&quot;).off() 举例： 123456789101112131415161718192021222324252627&lt;body&gt; &lt;p&gt; &lt;input type=\"button\" value=\"绑定事件\"/&gt; &lt;input type=\"button\" value=\"解绑事件\"/&gt; &lt;input type=\"button\" value=\"动态创建元素\"/&gt; &lt;input type=\"button\" value=\"on事件的解绑\"/&gt; &lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; //动态给p元素添加子元素 $(\"input:eq(2)\").click(function()&#123; $(\"p\").append(\"&lt;h1&gt;我是动态创建的元素&lt;/h1&gt;\") &#125;) //使用on的方式绑定事件 $(\"p\").on('click','input',function()&#123; console.log($(this).val()) &#125;) $(\"p\").on('click',function()&#123; console.log($(this).html()) &#125;) $(\"input:eq(3)\").on('click',function()&#123; $(\"p\").off('click'); &#125;) &#125;) &lt;/script&gt; 注意：利用$(&#39;p&#39;).off(&#39;click&#39;);的方式移除了所有on()触发的事件，因为动态创建这个元素的click事件并不是由on()事件触发的，而是由click()事件触发的，所以利用off()的方式解绑不了。 第二种形式:$( &quot;p&quot;).off( &quot;click&quot;, &quot;**&quot; ); 从图中可以看出,通过这样的方式,解除了除给自身绑定事件之外的其他事件.,例如通过父元素给子元素绑定事件，父元素的绑定的事件没有解除，但是子元素绑定的事件解除了，也就是取消掉了冒泡。 6.one()：为元素的事件添加处理函数。处理函数在每个元素上每种事件类型最多执行一次，处理程序在第一次触发事件后会被立即解除绑定。最常用的场景：一般提交表单的时候只允许提交一次，并不允许多次提交。 语法：one( events [, data ], handler() ) 参数说明： 第一个参数：events，事件名 第二个参数：selector，选择器 第三个参数：handler，事件处理方法 举例： 1234567&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").one('click',function()&#123; console.log(\"只能点击一次呦\"); &#125;) &#125;) &lt;/script&gt; 哈哈，只能触发一次，你点在多次也没有用。 那点击一次和点击多次在浏览器中有什么区别呢？ 1234567&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;button&quot;).on(&apos;click&apos;,function()&#123; console.log(&quot;可以点击多次&quot;); &#125;) &#125;) &lt;/script&gt; 对比上面两张大家肯定可以区别点击一次和点击多次的区别了 on()不能实现one()的功能，只能模拟。 12345678910$( \"#foo\" ).one( \"click\", function() &#123; alert( \"This will be displayed only once.\" );&#125;);//在代码执行后，点击id为foo的元素将显示警报。之后再在该元素上点击时，就不会再触发该事件。此代码是等效于：$( \"#foo\" ).on( \"click\", function( event ) &#123; alert( \"This will be displayed only once.\" ); $( this ).off( event );&#125;); 7.trigger()：根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为。既触发事件，又触发浏览器的默认行为。 12345678910111213body&gt; &lt;button&gt;我是按钮&lt;/button&gt;&lt;form&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").click(function()&#123; $(\"input\").trigger(\"click\"); &#125;) &#125;) &lt;/script&gt; 提交按钮会改变浏览器的默认操作，如上图，给访问地址加上&quot;?&quot;问号,如果给指定元素绑定了trigger事件，那么这个元素也会改变浏览器的默认操作。 举例： 7.1.点击button#2时，同时触发button#1的点击事件。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; button &#123; margin: 10px; &#125; div &#123; color: blue; font-weight: bold; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Button #1&lt;/button&gt; &lt;button&gt;Button #2&lt;/button&gt; &lt;div&gt;&lt;span&gt;0&lt;/span&gt; button #1 clicks.&lt;/div&gt; &lt;div&gt;&lt;span&gt;0&lt;/span&gt; button #2 clicks.&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"button:first\").click(function() &#123; update($(\"span:first\")); &#125;); $(\"button:last\").click(function() &#123; $(\"button:first\").trigger('click'); update($(\"span:last\")); &#125;); function update(j) &#123; var n = parseInt(j.text(), 10); j.text(n + 1); &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.2.若要提交第一个表单但又不想使用 submit()函数 1234var event = jQuery.Event(\"submit\");$(\"form:first\").trigger(event);if ( event.isDefaultPrevented() ) &#123;&#125; 7.3.向事件中传入任意的数据： 12$(\"p\").click( function (event, a, b) &#123;&#125; ).trigger(\"click\", [\"foo\", \"bar\"]); 7.4.通过event对象，向事件中传入任意的数据：(两种方式) 12345678910111213//第一种方式var event = jQuery.Event(\"logged\");event.user = \"foo\";event.pass = \"bar\";$(\"body\").trigger(event);//第二种方式$(\"body\").trigger(&#123;type:\"logged\",user:\"foo\",pass:\"bar\"&#125;); 8.triggerHandler()：为一个事件执行附加到元素的所有处理程序描述： trigger()会影响所有与jQuery对象相匹配的元素，而triggerHandler()仅影响第一个匹配到的元素。 使用triggerHandler()触发的事件，并不会在DOM树中向上冒泡，如果它们不是由目标元素直接触发的，那么它就不会进行任何处理。 只触发事件，不会触发浏览器的默认行为。 举例： 8.1.如果使用triggerHandler()触发focus事件，那么它只会触发绑定了该事件的处理函数，而浏览器的默认focus动作是不会被触发的。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"old\"&gt;.trigger(\"focus\")&lt;/button&gt; &lt;button id=\"new\"&gt;.triggerHandler(\"focus\")&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type=\"text\" value=\"To Be Focused\" /&gt; &lt;script&gt; $(function() &#123; $(\"#old\").click(function() &#123; $(\"input\").trigger(\"focus\"); &#125;); $(\"#new\").click(function() &#123; $(\"input\").triggerHandler(\"focus\"); &#125;); $(\"input\").focus(function() &#123; $(\"&lt;span&gt;Focused!&lt;/span&gt;\").appendTo(\"body\").fadeOut(1000); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件委派9.delegate()：为所有匹配选择器（selector参数）的元素绑定一个或多个事件处理函数，基于一个指定的根元素的子集，匹配的元素包括那些目前已经匹配到的元素，也包括那些今后可能匹配到的元素。简单的说，如果需要为子元素绑定事件，直接给父元素绑定即可。语法格式：$(selector).delegate( selector, eventType, handler ) 参数： 第一个参数: selector， 子选择器。 第二个参数：事件类型 第三个参数：事件响应方法 123$(\".parentBox\").delegate(\"p\", \"click\", function()&#123; //为 .parentBox下面的所有的p标签绑定事件 &#125;); 描述： 可支持动态创建元素的绑定 举例： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; //动态给p元素添加子元素 $(\"input:eq(2)\").click(function()&#123; $(\"p\").append(\"&lt;h1&gt;我是动态创建的元素&lt;/h1&gt;\") &#125;) //使用on的方式绑定事件 $(\"p\").delegate('input','click',function()&#123; console.log($(this).val()); &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;input type=\"button\" value=\"绑定事件\"/&gt; &lt;input type=\"button\" value=\"解绑事件\"/&gt; &lt;input type=\"button\" value=\"动态创建元素\"/&gt; &lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; delegate()和on()绑定的效果是相同的，都支持绑定动态创建的元素，但是delegate()已经废除了 事件-&gt;事件切换10.hover()：将两个事件函数绑定到匹配元素上，分别当鼠标指针进入和离开元素时被执行。可以有一个参数,也可以有两个参数,参数也可以是回调函数。 hover(mouseenter,mouseleave)：鼠标移入，移出。 动态下拉菜单的另一种实现 123456789 &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").slideDown(); &#125;,function()&#123; $(this).children(\"ul\").slideUp(); &#125;) &#125;)&lt;/script&gt; 又一种实现 1234567 &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").slideToggle(); &#125;) &#125;)&lt;/script&gt; 举例： 10.1.当鼠标在表格单元格中来回滑动的时候添加特殊的样式 12345678$(\"td\").hover( function () &#123; $(this).addClass(\"hover\"); &#125;, function () &#123; $(this).removeClass(\"hover\"); &#125;); 事件-&gt;事件11.scroll():事件触发或者绑定滚动事件当用户在元素内执行了滚动操作，就会在这个元素上触发scroll事件，它适用于window对象。 123$(selector).scroll(function()&#123; //当选择的元素发生滚动的时候触发 &#125;); 举例： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; color: blue; &#125; p &#123; color: green; &#125; span &#123; color: red; display: none; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Try scrolling the iframe.&lt;/div&gt; &lt;p&gt;Paragraph - &lt;span&gt;Scroll happened!&lt;/span&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").clone().appendTo(document.body); $(\"p\").clone().appendTo(document.body); $(\"p\").clone().appendTo(document.body); $(window).scroll(function() &#123; $(\"span\").css(\"display\", \"inline\").fadeOut(\"slow\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之属性","slug":"JQuery常用方法之属性","date":"2018-06-19T07:09:31.000Z","updated":"2018-10-12T14:46:59.644Z","comments":true,"path":"2018/06/19/JQuery常用方法之属性/","link":"","permalink":"http://yoursite.com/2018/06/19/JQuery常用方法之属性/","excerpt":"","text":"属性-&gt;属性1.attr()：获取指定的元素集合中的第一个元素的属性的值(attribute)。描述: 和属性相关的操作(在DOM对象中是：setattribute()方法、getAttribute() 方法) 如果传参数就是设置属性值，如果不传参数就是获取属性值。 12345678//设置属性值$('a').attr('title', '百度一下');$('a').attr('href', 'http://www,baidu.com');//获取属性值$('a').attr('title');$('a').attr('href'); 举例： 当它发生变化时，显示复选框的属性和属性。 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;attr demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 20px 0 0; &#125; b &#123; color: blue; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;check1&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; &lt;label for=&quot;check1&quot;&gt;Check me&lt;/label&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;input&quot;) .change(function() &#123; var $input = $(this); $(&quot;p&quot;).html(&quot;.attr( &apos;checked&apos; ): &lt;b&gt;&quot; + $input.attr(&quot;checked&quot;) + &quot;&lt;/b&gt;&lt;br&gt;&quot; + &quot;.prop( &apos;checked&apos; ): &lt;b&gt;&quot; + $input.prop(&quot;checked&quot;) + &quot;&lt;/b&gt;&lt;br&gt;&quot; + &quot;.is( &apos;:checked&apos; ): &lt;b&gt;&quot; + $input.is(&quot;:checked&quot;) + &quot;&lt;/b&gt;&quot;); &#125;) .change(); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在页面的第一个&lt;em&gt;中找到title属性。 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;attr demo&lt;/title&gt; &lt;style&gt; em &#123; color: blue; font-weight: bold; &#125; div &#123; color: red; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Once there was a &lt;em title=&quot;huge, gigantic&quot;&gt;large&lt;/em&gt; dinosaur...&lt;/p&gt; The title of the emphasis is: &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var title = $(&quot;em&quot;).attr(&quot;title&quot;); $(&quot;div&quot;).text(title); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为页面中全部的&lt;img&gt;设置一些属性。 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;attr demo&lt;/title&gt; &lt;style&gt; img &#123; padding: 10px; &#125; div &#123; color: red; font-size: 24px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img /&gt; &lt;img /&gt; &lt;img /&gt; &lt;div&gt;&lt;b&gt;显示图片的属性&lt;/b&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(&quot;img&quot;).attr(&#123; src: &quot;/resources/hat.gif&quot;, title: &quot;jQuery&quot;, alt: &quot;jQuery Logo&quot; &#125;); $(&quot;div&quot;).text($(&quot;img&quot;).attr(&quot;alt&quot;)); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使第二个后面的按钮disabled 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;attr demo&lt;/title&gt; &lt;style&gt; div &#123; color: blue; &#125; span &#123; color: red; &#125; b &#123; font-weight: bolder; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;Zero-th &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;First &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;Second &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123;$( &quot;div&quot; ) .attr( &quot;id&quot;, function( arr ) &#123; return &quot;div-id&quot; + arr; &#125;) .each(function() &#123; $( &quot;span&quot;, this ).html( &quot;(id = &apos;&lt;b&gt;&quot; + this.id + &quot;&lt;/b&gt;&apos;)&quot; ); &#125;);&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过图片的title属性设置src属性 12345678910111213141516171819&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;attr demo&lt;/title&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img title=&quot;hat.gif&quot;&gt; &lt;script&gt; $(function() &#123; $(&quot;img&quot;).attr(&quot;src&quot;, function() &#123; return &quot;/resources/&quot; + this.title; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.removeattr()：为指定的元素集合中的每个元素中移除一个属性举例：点击按钮，添加或删除按钮后面input元素的title属性。 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;removeAttr demo&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Change title&lt;/button&gt; &lt;input type=\"text\" title=\"hello there\"&gt; &lt;div id=\"log\"&gt;&lt;/div&gt; &lt;script&gt; (function() &#123; var inputTitle = $(\"input\").attr(\"title\"); $(\"button\").click(function() &#123; var input = $(this).next(); if(input.attr(\"title\") === inputTitle) &#123; input.removeAttr(\"title\") &#125; else &#123; input.attr(\"title\", inputTitle); &#125; $(\"#log\").html(\"input title is now \" + input.attr(\"title\")); &#125;); &#125;)(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.prop():获取匹配的元素集中第一个元素的属性(property)值举例: Checked属性显示一个复选框，因为它的变化和属性。 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;prop demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 20px 0 0; &#125; b &#123; color: blue; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;check1&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; &lt;label for=&quot;check1&quot;&gt;Check me&lt;/label&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;input&quot;).change(function() &#123; var $input = $(this); $(&quot;p&quot;).html( &quot;.attr( \\&quot;checked\\&quot; ): &lt;b&gt;&quot; + $input.attr(&quot;checked&quot;) + &quot;&lt;/b&gt;&lt;br&gt;&quot; + &quot;.prop( \\&quot;checked\\&quot; ): &lt;b&gt;&quot; + $input.prop(&quot;checked&quot;) + &quot;&lt;/b&gt;&lt;br&gt;&quot; + &quot;.is( \\&quot;:checked\\&quot; ): &lt;b&gt;&quot; + $input.is(&quot;:checked&quot;) + &quot;&lt;/b&gt;&quot;); &#125;).change(); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 禁用页面上的所有复选框。 123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;prop demo&lt;/title&gt; &lt;style&gt; img &#123; padding: 10px; &#125; div &#123; color: red; font-size: 24px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; &lt;script&gt; $(function() &#123; $(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&#123; disabled: true &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意：attr()函数和prop()函数的区别: 属性：attribute 特性：property 关于 checked attribute要记住的最重要的概念是，它不同于checked property attribute,事实上等同于defaultCheckproperty,并且应该只能用来设置checkbox的初始值。 ckecked attribute值不用用来改变checkbox的状态，但是checked property可以。因此，跨浏览器的途径来确定一个chexkbox是否被选中要使用property. 下面的三种方式都可以判断复选框是不被选中了，第一种方法是js方式，第二种方式是JQuery方式利用prpo()方法，第三种方式利用JQuery方式的is()方法来进行判断 属性-&gt;CSS类addClass()：为每个匹配的元素添加指定的样式类名 举例：将一个函数传递给.addClass()，将&quot;绿色&quot;类添加到已有“红色”类的div中。 12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;addClass demo&lt;/title&gt; &lt;style&gt; div &#123; background: white; &#125; .red &#123; background: red; &#125; .red.green &#123; background: green; &#125; &lt;/style&gt; &lt;script src=\"https://code.jquery.com/jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;This div should be white&lt;/div&gt; &lt;div class=\"red\"&gt;This div will be green because it now has the \"green\" and \"red\" classes. It would be red if the addClass function failed.&lt;/div&gt; &lt;div&gt;This div should be white&lt;/div&gt; &lt;p&gt;There are zero green divs&lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"div\").addClass(function(index, currentClass) &#123; var addedClass; if(currentClass === \"red\") &#123; addedClass = \"green\"; $(\"p\").text(\"There is one green div\"); &#125; return addedClass; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; removeClass()移除集合中每个匹配元素上一个，多个或全部样式。 举例:添加类样式和删除类样式： 12345678910111213141516171819202122&lt;style type=\"text/css\"&gt; .div1&#123; background-color: darksalmon; width: 100px; height: 100px; margin: 100px auto; &#125; .div2&#123; background-color: #008000; width: 500px; height: 500px; margin: 100px auto; &#125; &lt;/style&gt; &lt;div&gt;Hello World&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('div').addClass('div1'); $('div').addClass('div1').addClass(\"div2\"); //可以添加一个或者多个类，但是相同的属性会覆盖 $(\"div\").removeClass(\"div2\"); &#125;); toggleClass()：为匹配的元素集合中的每个元素上添加或删除一个或多个样式类（class）,取决于这个样式类（class）是否存在或state参数的值。 切换类的效果： 第一种方法：使用toggleClass()方法： 第二种方法：首先判断有没有该类，如果有的话就删除，如果没有的话就添加该类，其实就是一个删除与添加的过程 12345678910111213141516171819202122232425262728293031323334353637383940414243//第二种方法&lt;style type=\"text/css\"&gt; .div1&#123; background-color: darksalmon; width: 100px; height: 100px; margin: 100px auto; &#125; &lt;/style&gt; &lt;div&gt;Hello World&lt;/div&gt; &lt;input type=\"button\" value=\"切换\" id=\"btn\"&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"#btn\").click(function()&#123; if($(\"div\").hasClass(\"div1\"))&#123; $(\"div\").removeClass(\"div1\"); &#125;else&#123; $(\"div\").addClass(\"div1\"); &#125; &#125;) &#125;) &lt;/script&gt;//第一种方法：&lt;style type=\"text/css\"&gt; .div1&#123; background-color: darksalmon; width: 100px; height: 100px; margin: 100px auto; &#125; &lt;/style&gt; &lt;div&gt;Hello World&lt;/div&gt; &lt;input type=\"button\" value=\"切换\" id=\"btn\"&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"#btn\").click(function()&#123; $(\"div\").toggleClass(\"div1\"); &#125;) &#125;) &lt;/script&gt; 举例：每当第三次点击段落的时候添加 “highlight” 样式类, 第一次和第二次点击的时候移除 “highlight” 样式类 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;toggleClass demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 4px; font-size: 16px; font-weight: bolder; cursor: pointer; &#125; .blue &#123; color: blue; &#125; .highlight &#123; background: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../../js/jquery-1.11.1.min.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"blue\"&gt;Click to toggle (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt; &lt;p class=\"blue highlight\"&gt;highlight (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt; &lt;p class=\"blue\"&gt;on these (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt; &lt;p class=\"blue\"&gt;paragraphs (&lt;span&gt;clicks: 0&lt;/span&gt;)&lt;/p&gt; &lt;script&gt; $(function() &#123; var count = 0; $(\"p\").each(function() &#123; var $thisParagraph = $(this); var count = 0; $thisParagraph.click(function() &#123; count++; $thisParagraph.find(\"span\").text(\"clicks: \" + count); $thisParagraph.toggleClass(\"highlight\", count % 3 === 0); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意： 添加的样式一定必须是类样式”.div{} “，而不能标签样式”div{}”，或者ID样式”#div{}”. 操作类样式的时候，所有的类名，都不带点（”.”） Javascript中有很多方法可以操作DOM对象，Jquery也有很多方法可以操作DOM对象，可是它们之间实现的过程可是差距很大的，通过下面的种种案例我们不难看出使用jQuery的方式来操作DOM更加的简介。 对比JS操作DOM和jQuery操作DOM javascript只能用className()这样一个方法来判断存不存在样式、添加样式、删除样式、切换样式。 12345678910111213141516171819202122232425262728293031window.onload=function()&#123;//判断有没有样式function hasClass(obj,cls)&#123; return obj.className.match(new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'));&#125;//添加样式function addClass(obj,cls)&#123; if(!hasClass(obj,cls))&#123; obj.className+=\" \"+cls &#125;&#125;//删除样式function removeClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; var reg=new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'); obj.className=obj.className.replace(reg,' '); &#125;&#125;//切换样式function toggleClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; removeClass(obj,cls); &#125;else&#123; addClass(obj,cls); &#125; &#125;&#125; jQuery方式操作对象就简单太多了: 12345678910111213141516$(document).ready(function()&#123;//判断有没有指定样式$(\"#demo\").hasClass(\"newClass\");//添加样式$(\"#demo\").addClass(\"newClass\");//删除样式$(\"#demo\").removeClass(\"newClass\");//切换样式$(\"#demo\").toggleClass(\"newClass\");&#125;) 动态创建元素对比javascript方式： 12345678910111213141516window.onload=function()&#123; //获取div节点 var demo=document.getElementById(\"demo\"); //创建a元素 var aLink=document.createElement(\"a\"); //创建文本节点 var aTxt=document.createTextNode(\"Web前端\"); //把文本节点添加给创建的a元素 aLink.appendChild(aTxt); //给a元素设置属性 aLink.setAttribute(\"href\",\"http://www.baidu.com\"); //把动态创建的a元素，添加到获取的div元素中 demo.appendChild(aLink);&#125; jQuery方式：创建文本 123456$(document).ready(function()&#123; //创建a元素，同时创建属性和文本节点 var aLink=$(\"&lt;a href=\"http://www.baidu.com\"&gt;Web前端&lt;/a&gt;\"); //把动态创建的a元素，添加到获取的div元素中 $(\"#demo\").append(aLink);&#125;); 有关DOM对象和Jquery对象的区别于联系请看我另一篇博客 属性：HTML代码/文本/值val()：获取匹配的元素集合中第一个元素的当前值 获取值的时候，只返回选择到的所有元素的第一个 val()函数中如果传参数就是设置文本框中的值，如果不传参数就是获取文本框中的值。 123456789101112131415161718&lt;body&gt;&lt;input type=\"button\" value=\"设置val值\"/&gt;&lt;input type=\"button\" value=\"获取val值\"/&gt;&lt;input type=\"text\"/&gt;&lt;/body&gt;&lt;script&gt;$(document).ready(function()&#123; //设置文本框的值 $(\"input:eq(0)\").click(function()&#123; $(\"input:eq(2)\").val(\"我是文本框\"); &#125;); //获取文本框中的值 $(\"input:eq(1)\").click(function()&#123; var value=$(\"input:eq(2)\").val(); alert(value); &#125;); &#125;)&lt;/script&gt; 举例： 从单一列表框和复选列表中取值，并显示选中的值。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;val demo&lt;/title&gt; &lt;style&gt; p &#123; color: red; margin: 4px; &#125; b &#123; color: blue; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;select id=&quot;single&quot;&gt; &lt;option&gt;Single&lt;/option&gt; &lt;option&gt;Single2&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;Multiple&lt;/option&gt; &lt;option&gt;Multiple2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;Multiple3&lt;/option&gt; &lt;/select&gt; &lt;script&gt; $(function()&#123; function displayVals() &#123; var singleValues = $(&quot;#single&quot;).val(); var multipleValues = $(&quot;#multiple&quot;).val() || []; // When using jQuery 3: // var multipleValues = $( &quot;#multiple&quot; ).val(); $(&quot;p&quot;).html(&quot;&lt;b&gt;Single:&lt;/b&gt; &quot; + singleValues + &quot; &lt;b&gt;Multiple:&lt;/b&gt; &quot; + multipleValues.join(&quot;, &quot;)); &#125; $(&quot;select&quot;).change(displayVals); displayVals(); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 取得文本框的值。12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;val demo&lt;/title&gt; &lt;style&gt; p &#123; color: blue; margin: 8px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;some text&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;input&quot;) .keyup(function() &#123; var value = $(this).val(); $(&quot;p&quot;).text(value); &#125;) .keyup(); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 设置单一列表框，复选列表，复选框和单选按钮的值。12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;val demo&lt;/title&gt; &lt;style&gt; body &#123; color: blue; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id=&quot;single&quot;&gt; &lt;option&gt;Single&lt;/option&gt; &lt;option&gt;Single2&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;Multiple&lt;/option&gt; &lt;option&gt;Multiple2&lt;/option&gt; &lt;option selected=&quot;selected&quot;&gt;Multiple3&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check1&quot;&gt; check1 &lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check2&quot;&gt; check2 &lt;input type=&quot;radio&quot; name=&quot;r&quot; value=&quot;radio1&quot;&gt; radio1 &lt;input type=&quot;radio&quot; name=&quot;r&quot; value=&quot;radio2&quot;&gt; radio2 &lt;script&gt; $(function() &#123; $(&quot;#single&quot;).val(&quot;Single2&quot;); $(&quot;#multiple&quot;).val([&quot;Multiple2&quot;, &quot;Multiple3&quot;]); $(&quot;input&quot;).val([&quot;check1&quot;, &quot;check2&quot;, &quot;radio1&quot;]); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 将函数作为参数设置文本框的值123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;val demo&lt;/title&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Type something and then click or tab out of the input.&lt;/p&gt; &lt;input type=&quot;text&quot; value=&quot;type something&quot;&gt; &lt;script&gt; $(function() &#123; $(&quot;input&quot;).on(&quot;blur&quot;, function() &#123; $(this).val(function(i, val) &#123; return val.toUpperCase(); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; html():获取集合中第一个匹配元素的HTML内容 如果传参数就是设置html中的值，如果不传参数就是获取html中的值,如果传了参数，但是参数为空，就相当于删除了这个节点，相当于remove()的效果。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;我是p元素&lt;/p&gt;&lt;/div&gt;&lt;input type=\"button\" value=\"设置html值\"/&gt;&lt;input type=\"button\" value=\"获取html值\"/&gt;&lt;/body&gt;&lt;script src=\"../js/jquery-1.11.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"input:eq(0)\").click(function()&#123; //设置html内容 //$(\"div\").html(\"我是html内容\"); //将原来的div中的标签元素获取到，然后在加上新的标签元素，不会造成覆盖的效果,类似于append的效果，这是最常用的形式。 var html=$(\"div\").html(); $(\"div\").html(html+\"&lt;h1&gt;我是标题&lt;/h1&gt;\") &#125;); //获取html内容 $(\"input:eq(1)\").click(function()&#123; var html=$(\"div\").html(); alert(html); &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 注意：使用html()来创建dom的方式效率比较高，远大于document.createElement();和append(); 举例： 点击段落将HTML转化为文本 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;html demo&lt;/title&gt; &lt;style&gt; p &#123; margin: 8px; font-size: 20px; color: blue; cursor: pointer; &#125; b &#123; text-decoration: underline; &#125; button &#123; cursor: pointer; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;b&gt;Click&lt;/b&gt; to change the &lt;span id=\"tag\"&gt;html&lt;/span&gt; &lt;/p&gt; &lt;p&gt; to a &lt;span id=\"text\"&gt;text&lt;/span&gt; node. &lt;/p&gt; &lt;p&gt; This &lt;button name=\"nada\"&gt;button&lt;/button&gt; does nothing. &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").click(function() &#123; var htmlString = $(this).html(); $(this).text(htmlString); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 为每个div设置一些内容 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;html demo&lt;/title&gt; &lt;style&gt; .red &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"div\").html(\"&lt;span class='red'&gt;Hello &lt;b&gt;Again&lt;/b&gt;&lt;/span&gt;\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 添加了一些html到每个div，然后立刻做进一步的操作来插入的HTML。123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;html demo&lt;/title&gt; &lt;style&gt; div &#123; color: blue; font-size: 18px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"div\").html(\"&lt;b&gt;Wow!&lt;/b&gt; Such excitement...\"); $(\"div b\") .append(document.createTextNode(\"!!!\")) .css(\"color\", \"red\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; text():得到匹配元素集合中每个元素的合并文本，包括他们的后代，也就是说，获取文本内容，获取标签元素的内容，但不包含标签。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;我是p元素&lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;设置text值&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;获取text值&quot; /&gt; &lt;/body&gt; &lt;script src=&quot;../js/jquery-1.11.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; $(&quot;input:eq(0)&quot;).click(function() &#123; //设置text内容 //$(&quot;div&quot;).text(&quot;我是标题&quot;); $(&quot;div&quot;).text(&quot;&lt;h1&gt;我是标题&lt;/h1&gt;&quot;); &#125;); //获取text内容 $(&quot;input:eq(1)&quot;).click(function() &#123; var text = $(&quot;div&quot;).text(); alert(text); &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 举例： 在第一段中找到文本（去掉html），然后设置最后一段的html以显示它只是文本（&lt;b&gt;标签地作用已经消失） 123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;text demo&lt;/title&gt; &lt;style&gt; p &#123; color: blue; margin: 8px; &#125; b &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;b&gt;Test&lt;/b&gt; Paragraph.&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; var str = $(\"p:first\").text(); $(\"p:last\").html(str); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在段落中添加文本。这个&lt;b&gt;标签将从HTML中脱离出来，也就是说现在的&lt;b&gt;标签被当做字符串原样输出了。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;text demo&lt;/title&gt; &lt;style&gt; p &#123; color: blue; margin: 8px; &#125; &lt;/style&gt; &lt;script src=\" ../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Test Paragraph.&lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").text(\"&lt;b&gt;Some&lt;/b&gt; new text.\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之效果","slug":"JQuery常用方法之效果","date":"2018-06-16T06:00:31.000Z","updated":"2018-10-12T14:46:55.743Z","comments":true,"path":"2018/06/16/JQuery常用方法之效果/","link":"","permalink":"http://yoursite.com/2018/06/16/JQuery常用方法之效果/","excerpt":"","text":"效果-&gt;基本1.show()：显示隐藏的指定的元素注意：关于动画的API都有一个共同点，就是如果提供回调函数参数，回调函数会在动画完成的时候调用。也就是说，如果该方法的参数中有函数,那么这个函数会等到动画执行完之后才执行。 举例： 1.1.缓慢地显示所有隐藏的段落，600毫秒内完成的动画。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Show it&lt;/button&gt; &lt;p style=\"display: none\"&gt;Hello 2&lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"p\").show(\"slow\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.2.依次显示 div，每个用时200毫秒。一个动画完成后立即开始下一个。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background: #def3ca; margin: 3px; width: 80px; display: none; float: left; text-align: center; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"showr\"&gt;Show&lt;/button&gt; &lt;button id=\"hidr\"&gt;Hide&lt;/button&gt; &lt;div&gt;Hello 3,&lt;/div&gt; &lt;div&gt;how&lt;/div&gt; &lt;div&gt;are&lt;/div&gt; &lt;div&gt;you?&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"#showr\").click(function() &#123; $(\"div\").first().show(\"fast\", function showNext() &#123; $(this).next(\"div\").show(\"fast\", showNext); &#125;); &#125;); $(\"#hidr\").click(function() &#123; $(\"div\").hide(1000); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.3.动画显示所有span和input元素。在文本框中输入yes并按回车,会显示一些内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; span &#123; display: none; &#125; div &#123; display: none; &#125; p &#123; font-weight: bold; background-color: #fcd; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;Do it!&lt;/button&gt; &lt;span&gt;Are you sure? (type 'yes' if you are) &lt;/span&gt; &lt;div&gt; &lt;form&gt; &lt;input type=\"text\" value=\"\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;p style=\"display:none;\"&gt;I'm hidden...&lt;/p&gt; &lt;script&gt; $(function() &#123; function doIt() &#123; $(\"span,div\").show(\"slow\"); &#125; $(\"button\").click(doIt); $(\"form\").submit(function() &#123; if($(\"input\").val() == \"yes\") &#123; $(\"p\").show(4000, function() &#123; $(this).text(\"Ok, DONE! (now showing)\"); &#125;); &#125; $(\"span,div\").hide(\"fast\"); return false; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.hide()：隐藏指定的元素举例： 2.1.点击链接隐藏所有段落。 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hide demo&lt;/title&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;a href=&quot;#&quot;&gt;Click to hide me too&lt;/a&gt; &lt;p&gt;Here is another paragraph&lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;p&quot;).hide(); $(&quot;a&quot;).click(function(event) &#123; event.preventDefault(); $(this).hide(); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2.缓慢的隐藏所有显示的段落，600毫秒内完成的动画。 1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hide demo&lt;/title&gt; &lt;style&gt; p &#123; background: #dad; font-weight: bold; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;p&gt;我是P元素&lt;/p&gt; &lt;p&gt;我也是p元素&lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).click(function() &#123; $(&quot;p&quot;).hide(&quot;slow&quot;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.3.快速隐藏所有的span元素，用时200毫秒。一个结束后立即开始下一个。 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;hide demo&lt;/title&gt; &lt;style&gt; span &#123; background: #def3ca; padding: 3px; float: left; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"hidr\"&gt;Hide&lt;/button&gt; &lt;button id=\"showr\"&gt;Show&lt;/button&gt; &lt;div&gt; &lt;span&gt;Once&lt;/span&gt; &lt;span&gt;upon&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;time&lt;/span&gt; &lt;span&gt;there&lt;/span&gt; &lt;span&gt;were&lt;/span&gt; &lt;span&gt;three&lt;/span&gt; &lt;span&gt;programmers...&lt;/span&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"#hidr\").click(function() &#123; $(\"span:last-child\").hide(\"fast\", function() &#123; $(this).prev().hide(\"fast\", arguments.callee); &#125;); &#125;); $(\"#showr\").click(function() &#123; $(\"span\").show(2000); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.4.当点击div之后用2秒时间隐藏这个div。当它完全隐藏后将其移除。 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;hide demo&lt;/title&gt; &lt;style&gt; div &#123; background: #ece023; width: 30px; height: 40px; margin: 2px; float: left; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; for(var i = 0; i &lt; 5; i++) &#123; $(\"&lt;div&gt;\").appendTo(document.body); &#125; $(\"div\").click(function() &#123; $(this).hide(2000, function() &#123; $(this).remove(); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果-&gt;淡入淡出3.fadeIn()：通过淡入的方式显示指定元素举例： 3.1.淡出所有段落，在600毫秒内完成这些动画。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; span &#123; color: red; cursor: pointer; &#125; div &#123; margin: 3px; width: 80px; display: none; height: 80px; float: left; &#125; div#one &#123; background: #f00; &#125; div#two &#123; background: #0f0; &#125; div#three &#123; background: #00f; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;Click here...&lt;/span&gt; &lt;div id=\"one\"&gt;&lt;/div&gt; &lt;div id=\"two\"&gt;&lt;/div&gt; &lt;div id=\"three\"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(document.body).click(function() &#123; $(\"div:hidden:first\").fadeIn(\"slow\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.2.在文本上淡入一个红色的div。一旦动画完成，被div遮盖的文本内容消失。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; position: relative; width: 400px; height: 90px; &#125; div &#123; position: absolute; width: 400px; height: 65px; font-size: 36px; text-align: center; color: yellow; background: red; padding-top: 25px; top: 0; left: 0; display: none; &#125; span &#123; display: none; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Let it be known that the party of the first part and the party of the second part are henceforth and hereto directed to assess the allegations for factual correctness... ( &lt;a href=&quot;#&quot;&gt;click!&lt;/a&gt;) &lt;div&gt;&lt;span&gt;CENSORED!&lt;/span&gt;&lt;/div&gt; &lt;/p&gt; &lt;script&gt; $(function() &#123; $(&quot;a&quot;).click(function() &#123; $(&quot;div&quot;).fadeIn(3000, function() &#123; $(&quot;span&quot;).fadeIn(100); &#125;); return false; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.fadeOut()：通过淡出的方式显示指定元素举例： 4.1.让所有段落渐渐消失，用时 600 毫秒。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; font-size: 150%; cursor: pointer; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; If you click on this paragraph you'll see it just fade away. &lt;/p&gt; &lt;script&gt; $(\"p\").click(function() &#123; $(\"p\").fadeOut(\"slow\"); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2.将你点击的 span 淡出隐藏。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;style&gt; span &#123; cursor: pointer; &#125; span.hilite &#123; background: yellow; &#125; div &#123; display: inline; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;寻找被隐藏的span元素&lt;div&gt;&lt;/div&gt;&lt;/h3&gt; &lt;p&gt; If you &lt;span&gt;really&lt;/span&gt; want to go outside &lt;span&gt;in the cold&lt;/span&gt; then make sure to wear your &lt;span&gt;warm&lt;/span&gt; jacket given to you by your &lt;span&gt;favorite&lt;/span&gt; teacher. &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"span\").click(function() &#123; $(this).fadeOut(1000, function() &#123; $(\"div\").text(\"'\" + $(this).text() + \"' has faded!\"); $(this).remove(); &#125;); &#125;); $(\"span\").hover(function() &#123; $(this).addClass(\"hilite\"); &#125;, function() &#123; $(this).removeClass(\"hilite\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.fadeTo()：淡入到某个指定的不透明度值举例： 5.1.把第一个段落的透明度渐变成 0.33 (33%，大约三分之一透明度), 用时 600 毫秒。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Click this paragraph to see it fade. &lt;/p&gt; &lt;p&gt; Compare to this one that won't fade. &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p:first\").click(function() &#123; $(this).fadeTo(\"slow\", 0.33); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.2.每次点击后把 div 渐变成随机透明度，用时200毫秒。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; width: 80px; margin: 0; padding: 5px; &#125; div &#123; width: 40px; height: 40px; position: absolute; &#125; div#one &#123; top: 0; left: 0; background: #f00; &#125; div#two &#123; top: 20px; left: 20px; background: #0f0; &#125; div#three &#123; top: 40px; left: 40px; background: #00f; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;div id=\"one\"&gt;&lt;/div&gt; &lt;div id=\"two\"&gt;&lt;/div&gt; &lt;div id=\"three\"&gt;&lt;/div&gt; &lt;script&gt; $(\"div\").click(function() &#123; $(this).fadeTo(\"fast\", Math.random()); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.3.找到正确答案！渐变耗时250毫秒，并且在完成后改变字体样式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div, p &#123; width: 80px; height: 40px; top: 0; margin: 100px; position: absolute; padding-top: 20px; &#125; p &#123; background: #fcc; text-align: center; &#125; div &#123; background: blue; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Wrong&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;Wrong&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;Right!&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; var getPos = function(n) &#123; return(Math.floor(n) * 90) + \"px\"; &#125;; $(\"p\").each(function(n) &#123; var r = Math.floor(Math.random() * 3); var tmp = $(this).text(); $(this).text($(\"p:eq(\" + r + \")\").text()); $(\"p:eq(\" + r + \")\").text(tmp); $(this).css(\"left\", getPos(n)); &#125;); $(\"div\").each(function(n) &#123; $(this).css(\"left\", getPos(n)); &#125;) .css(\"cursor\", \"pointer\") .click(function() &#123; $(this).fadeTo(250, 0.25, function() &#123; $(this).css(\"cursor\", \"\") .prev().css(&#123; \"font-weight\": \"bolder\", \"font-style\": \"italic\" &#125;); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.fadetoggle()：显示或隐藏指定元素的动画举例： 6.1.第一段落渐隐或渐显，用时600毫秒，并且是线性缓冲效果。而最后一个段落渐隐渐显用时200毫秒, 并且在每次动画完成后插入一个”finished”。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;fadeToggle p1&lt;/button&gt; &lt;button&gt;fadeToggle p2&lt;/button&gt; &lt;p&gt;This paragraph has a slow, linear fade.&lt;/p&gt; &lt;p&gt;This paragraph has a fast animation.&lt;/p&gt; &lt;div id=\"log\"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"button:first\").click(function() &#123; $(\"p:first\").fadeToggle(\"slow\", \"linear\"); &#125;); $(\"button:last\").click(function() &#123; $(\"p:last\").fadeToggle(\"fast\", function() &#123; $(\"#log\").append(\"&lt;div&gt;finished&lt;/div&gt;\"); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 小剧场问题：为什么toggleClass()和fadetoggle()中toggle的位置一个在前一个在后？ 因为动词总是跟在名词后面，Class是名词，fade是动词。toggle既可以当做名词又可以当做动词，这个问题其实一点也不重要。 效果-&gt;滑动7.slidedown()：卷帘门的效果显示指定的元素注意：slidedown()方法一定是展示出来的意思，如果”图片”的位置不同，那么展示的效果也会不同，比如说如果图片的位置在右下角，那就是从下往上面展示，如果图片在左上角，那么就是从上往下展示。 举例： 7.1.用600毫秒让所有的div下滑显示出来。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background: #de9a44; margin: 3px; width: 80px; height: 40px; display: none; float: left; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Click me! &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(document.body).click(function() &#123; if($(\"div:first\").is(\":hidden\")) &#123; $(\"div\").slideDown(\"slow\"); &#125; else &#123; $(\"div\").hide(); &#125; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.2.用1000毫秒让所有文本框组件下滑显示出来。动画完成后改变这些文本框的外观，并让中间的文本框获得输入焦点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background: #cfd; margin: 3px; width: 50px; text-align: center; float: left; cursor: pointer; border: 2px outset black; font-weight: bolder; &#125; input &#123; display: none; width: 120px; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Push!&lt;/div&gt; &lt;input type=\"text\" /&gt; &lt;input type=\"text\" class=\"middle\" /&gt; &lt;input type=\"text\" /&gt; &lt;script&gt; $(function() &#123; $(\"div\").click(function() &#123; $(this).css(&#123; borderStyle: \"inset\", cursor: \"wait\" &#125;); $(\"input\").slideDown(1000, function() &#123; $(this).css(\"border\", \"2px red inset\") .filter(\".middle\") .css(\"background\", \"yellow\") .focus(); $(\"div\").css(\"visibility\", \"hidden\"); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.slideup()：卷帘门的效果隐藏指定的元素举例： 8.1.让所有的div向上滑，用时400毫秒。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background: #3d9a44; margin: 3px; width: 80px; height: 40px; float: left; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; Click me! &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(document.body).click(function() &#123; if($(\"div:first\").is(\":hidden\")) &#123; $(\"div\").show(\"slow\"); &#125; else &#123; $(\"div\").slideUp(); &#125; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.2.用200毫秒让父元素滑动收起。动画完成后，显示一个提示信息。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; margin: 2px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button&gt;Hide One&lt;/button&gt; &lt;input type=\"text\" value=\"One\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;Hide Two&lt;/button&gt; &lt;input type=\"text\" value=\"Two\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;Hide Three&lt;/button&gt; &lt;input type=\"text\" value=\"Three\" /&gt; &lt;/div&gt; &lt;div id=\"msg\"&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(this).parent().slideUp(\"slow\", function() &#123; $(\"#msg\").text($(\"button\", this).text() + \" has completed.\"); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 9.slidetoggle()：卷帘门的效果显示或者隐藏指定元素举例： 9.1.让所有的段落滑上或滑下，用时600毫秒。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; width: 400px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;button&gt;Toggle&lt;/button&gt; &lt;p&gt;This is the paragraph to end all paragraphs. You should feel &lt;em&gt;lucky&lt;/em&gt;to have seen such a paragraph in your life. Congratulations! &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"p\").slideToggle(\"slow\"); &#125; ); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 9.2.让隔开的div交替出现或消失。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background: #b977d1; margin: 3px; width: 60px; height: 60px; float: left; &#125; div.still &#123; background: #345; width: 5px; &#125; div.hider &#123; display: none; &#125; span &#123; color: red; &#125; p &#123; clear: left; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div class=\"still\"&gt;&lt;/div&gt; &lt;div style=\"display:none;\"&gt; &lt;/div&gt; &lt;div class=\"still\"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div class=\"still\"&gt;&lt;/div&gt; &lt;div class=\"hider\"&gt;&lt;/div&gt; &lt;div class=\"still\"&gt;&lt;/div&gt; &lt;div class=\"hider\"&gt;&lt;/div&gt; &lt;div class=\"still\"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;button id=\"aa\"&gt;Toggle&lt;/button&gt; There have been &lt;span&gt;0&lt;/span&gt; toggled divs.&lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"#aa\").click(function() &#123; $(\"div:not(.still)\").slideToggle(\"slow\", function() &#123; var n = parseInt($(\"span\").text(), 10); $(\"span\").text(n + 1); &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果-&gt;自定义动画10.animate():自定义动画描述： 在该方法中可以传CSS的属性值，但必须是键值对的形式， 所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。（例如，width, height或者left可以执行动画，但是background-color不能，除非使用jQuery.Color插件。属性值的单位像素（px）,除非另有说明。单位em 和%需要指定使用。 动画属性也可以是一个相对值如果提供一个以+=或-=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html &gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type=\"text/css\"&gt; .block &#123; position: relative; background-color: Red; width: 48px; height: 48px; float: left; margin: 5px; &#125; .result&#123; width: 50px; height: 50px; font-size: 10px; background-color: #E9967A; border-width: medium; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=\"result\"&gt;animate &lt;/div&gt; &lt;button class=\"btn1\"&gt; Click 1&lt;/button&gt; &lt;button class=\"btn2\"&gt; Click 2&lt;/button&gt; &lt;button class=\"btn3\"&gt; Click 3&lt;/button&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('.btn1').click(function() &#123; $('.result').animate(&#123; width: \"100%\", height: \"100%\", fontSize: \"10em\", borderWidth: 10 &#125;, 1000); &#125;); $('.btn2').click(function() &#123; $('.result').animate(&#123; width: \"+=30px\", height: \"-=30px\" &#125;, 1000); &#125;); $('.btn3').click(function() &#123; $('.block:first').animate(&#123; left: 100 &#125;, &#123; duration: 1000, step: function(now, fx) &#123; $('.block:gt(0)').css('left', now); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 注意：如果animate()方法后面有function()，那么内部就一定要写function的代码，而不能只写表达式的代码。如下所示。 12345678&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"input\").click(function()&#123; $(\"div\").animate(function()&#123; &#125;) &#125;) &#125;) &lt;/script&gt; 如果animate()方法后面没有跟着function()，那么内部既可以写function的代码，也可以写表达式的代码。如下所示。 12345678&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"input\").click(function()&#123; $(\"div\").animate(&#123; &#125;) &#125;) &#125;) &lt;/script&gt; 举例： 10.1点击按钮，根据指定的一系列属性，在div上应用动画。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background-color: #bca; width: 100px; border: 1px solid green; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;go&quot;&gt;&amp;raquo; Run&lt;/button&gt; &lt;div id=&quot;block&quot;&gt;Hello!&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;#go&quot;).click(function() &#123; $(&quot;#block&quot;).animate(&#123; width: &quot;70%&quot;, opacity: 0.4, marginLeft: &quot;0.6in&quot;, fontSize: &quot;3em&quot;, borderWidth: &quot;10px&quot; &#125;, 1500); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 10.2.对div应用动画，在left属性上使用相对值。执行动画多次，查看相对值的累加效果。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; position: absolute; background-color: #abc; left: 50px; width: 90px; height: 90px; margin: 5px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;left&quot;&gt;&amp;laquo;&lt;/button&gt; &lt;button id=&quot;right&quot;&gt;&amp;raquo;&lt;/button&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;#right&quot;).click(function() &#123; $(&quot;.block&quot;).animate(&#123; &quot;left&quot;: &quot;+=50px&quot; &#125;, &quot;slow&quot;); &#125;); $(&quot;#left&quot;).click(function() &#123; $(&quot;.block&quot;).animate(&#123; &quot;left&quot;: &quot;-=50px&quot; &#125;, &quot;slow&quot;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 10.3.第一个按钮要执行的动画中，使用了queue: false选项，该动画使元素的宽度扩大到了总宽 90%,并且文字大小也变大了。一旦字体大小改变完了，边框的动画就会开始。 第二个按钮要执行的动画中，包含了一系列动画，当前一个动画完成时，后一个动画就会开始。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; background-color: #bca; width: 200px; height: 1.1em; text-align: center; border: 2px solid green; margin: 3px; font-size: 14px; &#125; button &#123; font-size: 14px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;go1&quot;&gt;&amp;raquo; Animate Block1&lt;/button&gt; &lt;button id=&quot;go2&quot;&gt;&amp;raquo; Animate Block2&lt;/button&gt; &lt;button id=&quot;go3&quot;&gt;&amp;raquo; Animate Both&lt;/button&gt; &lt;button id=&quot;go4&quot;&gt;&amp;raquo; Reset&lt;/button&gt; &lt;div id=&quot;block1&quot;&gt;Block1&lt;/div&gt; &lt;div id=&quot;block2&quot;&gt;Block2&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;#go1&quot;).click(function() &#123; $(&quot;#block1&quot;).animate(&#123; width: &quot;90%&quot; &#125;, &#123; queue: false, duration: 3000 &#125;) .animate(&#123; fontSize: &quot;24px&quot; &#125;, 1500) .animate(&#123; borderRightWidth: &quot;15px&quot; &#125;, 1500); &#125;); $(&quot;#go2&quot;).click(function() &#123; $(&quot;#block2&quot;).animate(&#123; width: &quot;90%&quot; &#125;, 1000) .animate(&#123; fontSize: &quot;24px&quot; &#125;, 1000) .animate(&#123; borderLeftWidth: &quot;15px&quot; &#125;, 1000); &#125;); $(&quot;#go3&quot;).click(function() &#123; $(&quot;#go1&quot;).add(&quot;#go2&quot;).click(); &#125;); $(&quot;#go4&quot;).click(function() &#123; $(&quot;div&quot;).css(&#123; width: &quot;&quot;, fontSize: &quot;&quot;, borderWidth: &quot;&quot; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 10.4.对第一个div的left属性应用动画，在动画执行的过程中，在step函数中改变其余div的left属性。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; position: relative; background-color: #abc; width: 40px; height: 40px; float: left; margin: 5px; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;button id=&quot;go&quot;&gt;Run »&lt;/button&gt;&lt;/p&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;div class=&quot;block&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;#go&quot;).click(function() &#123; $(&quot;.block:first&quot;).animate(&#123; left: 100 &#125;, &#123; duration: 1000, step: function(now, fx) &#123; $(&quot;.block:gt(0)&quot;).css(&quot;left&quot;, now); &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 11.stop()：停止指定元素的动画效果。slideToggle()动画的效果是切换卷帘门，当鼠标进入或者离开的时候会触发切换效果，该动画默认有一定的执行时间，只有当时间间隔到达时才会停止动画，并不是说鼠标离开就会停止动画，利用stop()方法可以立即停止动画，没有时间间隔，这样的效果更贴近现实情况一些。 1234567 &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\".wrap &gt; ul &gt; li\").hover(function()&#123; $(this).children(\"ul\").stop().slideToggle(); &#125;) &#125;)&lt;/script&gt; 我们都知道队列的特点是先进先出，stop()函数中也存在着队列的特点。 1234567891011121314//参数一：是否清空动画队列//参数二：是否立即执行完当前动画，没有时间间隔。$(\"div\").stop(false,true); //$(\"div\")表示要停止动画的元素用法及解释：stop(true,true)：清空队列，并且当前动画不在缓慢执行而是直接完成。stop(false,true):不清空队列，并且当前元素不再缓慢执行而是直接完成。stop(true)：清空队列，停止当前动画stop():不清空队列，停止当前动画，继续执行下一个动画 举例：队列的特点：先进先出,也就是说先进来的执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; div &#123; width: 50px; height: 50px; background-color: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $(\"input:eq(0)\").click(function() &#123; $(\"div\").animate(&#123; width: \"100%\" &#125;, 3000); $(\"div\").animate(&#123; height: \"300px\" &#125;, 3000); $(\"div\").animate(&#123; width: \"60%\" &#125;, 3000); $(\"div\").animate(&#123; height: \"50px\" &#125;, 3000); &#125;) $(\"input:eq(1)\").click(function() &#123; $(\"div\").stop(); &#125;) $(\"input:eq(2)\").click(function() &#123; $(\"div\").stop(true,false); &#125;) $(\"input:eq(3)\").click(function() &#123; $(\"div\").stop(true, true); //不仅清空队列，而且立即执行完成 &#125;) $(\"input:eq(4)\").click(function() &#123; $(\"div\").stop(false, true); &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"按钮\" /&gt; &lt;input type=\"button\" value=\"stop1\" /&gt; &lt;input type=\"button\" value=\"stop2\" /&gt; &lt;input type=\"button\" value=\"stop3\" /&gt; &lt;input type=\"button\" value=\"stop4\" /&gt; &lt;/body&gt;&lt;/html&gt; 大家看下这个例子，自己可以每个试一下，就能很清晰的明白了这些参数之间的区别。 jQuery动画总结：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之文档处理","slug":"jQuery常用方法之文档处理","date":"2018-06-14T07:09:31.000Z","updated":"2018-10-12T14:46:57.799Z","comments":true,"path":"2018/06/14/jQuery常用方法之文档处理/","link":"","permalink":"http://yoursite.com/2018/06/14/jQuery常用方法之文档处理/","excerpt":"","text":"文档处理-&gt;内部插入1.append():追加元素，往指定元素添加新创建的元素，添加到所有子元素的最后边。 参数可以为jQuery对象 参数可以为html标签 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p &#123; width: 100%; height: 50px; background-color: red; &#125; &lt;/style&gt; &lt;script src=\"../js/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('button').on('click', function() &#123; $('div').append('&lt;p&gt;我是追加进去的&lt;/p&gt;'); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 举例： 1.1.在所有的段落内的尾部，追加一些HTML。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"p\").append(\"&lt;strong&gt;Hello&lt;/strong&gt;\");&#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.2.在所有的段落内的尾部，追加一个元素。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").append(document.createTextNode(\"Hello\")); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.3.在所有的段落内的尾部，追加一个jQuery对象 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;strong&gt;Hello world!!!&lt;/strong&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").append($(\"strong\")); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.appendTo():把新创建的元素添加到指定元素，也是添加到所有子元素的最后边。12345678910&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('button').on('click', function() &#123; $('&lt;p&gt;我是添加进去的&lt;/p&gt;').appendTo(\"div\"); &#125;); &#125;); &lt;/script&gt; append()方法和appendTo()方法只是写的格式不同，其实现的效果是相同的。 举例： 2.1.将所有的span插入到ID为&quot;foo&quot;的元素内的末尾。 12345678910111213141516171819202122&lt;!Doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;appendTo demo&lt;/title&gt; &lt;style&gt; #foo &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;I have nothing more to say... &lt;/span&gt; &lt;div id=\"foo\"&gt;FOO! &lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"span\").appendTo(\"#foo\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 文档处理-&gt;外部插入3.after()：在同级的后面添加元素12345678&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('button').on('click', function() &#123; $('span').after('&lt;p&gt;我是在后面加进去的&lt;/p&gt;'); &#125;); &#125;); &lt;/script&gt; after()允许我们传入一个函数，该函数返回要被插入的元素。 123$('p').after(function() &#123; return '&lt;div&gt;' + this.className + '&lt;/div&gt;';&#125;); 实例： 3.1.在所有的段落后插入一些HTML 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").after(\"&lt;b&gt;Hello&lt;/b&gt;\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.2.在所有的段落后插入一个DOM元素 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"p\").after(document.createTextNode(\"Hello\")); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3.在所有段落后插入一个jQuery对象 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;b&gt;Hello&lt;/b&gt; &lt;p&gt;I would like to say: &lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"p\").after($(\"b\"));&#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.before()：在同级的前面添加元素1234567&lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('button').on('click', function() &#123; $('span').before('&lt;p&gt;我是在前面加进去的&lt;/p&gt;'); &#125;); &#125;); &lt;/script&gt; 举例： 4.1.在所有的段落前插入一些HTML 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; is what I said...&lt;/p&gt; &lt;script&gt; $(function()&#123; $(\"p\").before(\"&lt;b&gt;Hello&lt;/b&gt;\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2.在所有的段落前插入一个DOM元素 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; is what I said...&lt;/p&gt; &lt;script&gt; $(function() &#123; $(\"p\").before(document.createTextNode(\"Hello\")); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.3.在所有段落前插入一个jQuery对象 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;b&gt;Hello&lt;/b&gt; &lt;p&gt; is what I said...&lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt; &lt;script&gt; $(function()&#123; $(\"p\").before($(\"b\"));&#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 文本处理-&gt;删除5.empty()方法：清空指定元素中的所有后代节点举例： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;style&gt; p &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello, &lt;span&gt;Person&lt;/span&gt; &lt;a href=&quot;javascript:;&quot;&gt;and person&lt;/a&gt; &lt;/p&gt; &lt;button&gt;清空empty()&lt;/button&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).click(function() &#123; $(&quot;p&quot;).empty(); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.remove()方法：删除所有的节点，包括自己本身当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以再以后继续使用这些元素。 1234567891011&lt;ul&gt;&lt;li&gt;d苹果&lt;li/&gt;&lt;li&gt;橘子&lt;li/&gt;&lt;li&gt;菠萝&lt;li/&gt;&lt;/ul&gt;&lt;script&gt;var $li=$(\"ul li:eq(1)\").remove();$(\"ul\").append(\"$li\"); //把刚才删除的节点又重新添加到&lt;ul&gt;中&lt;script/&gt; 举例： 6.1.从DOM中移除所有含有&quot;Hello&quot;的段落 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; p &#123; background: yellow; margin: 6px 0; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"hello\"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt; &lt;button&gt;删除节点remove()&lt;/button&gt; &lt;script&gt; $(function() &#123; $(\"button\").click(function() &#123; $(\"p\").remove(\":contains('Hello')\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之核心","slug":"jQuery常用方法之核心","date":"2018-06-12T01:18:10.000Z","updated":"2018-10-12T14:47:08.765Z","comments":true,"path":"2018/06/12/jQuery常用方法之核心/","link":"","permalink":"http://yoursite.com/2018/06/12/jQuery常用方法之核心/","excerpt":"","text":"核心-&gt;jQuery对象访问：1.each():遍历一个jQuery对象，为每个匹配元素执行一个函数。123456//全局对象的形式array=[];$.each(array,function(index,object)&#123;&#125;)//实例对象的形式$(\"li\").each(function(index,element)&#123;&#125;) 这两种形式的参数的顺序是相同的 描述： .each()：它会迭代jQuery对象中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)。函数是在当前DOM元素为上下文的语境中触发的，因此关键字this总是指向这个元素。 each()方法没有返回值,与each()方法功能相似的map()方法的返回值是一个数组。 jQuery的方法中有一个很大的特点就是隐式迭代，所以很多情况下都用不到each()方法来显式的迭代，只有在某些特殊的情况下，才会需要来显式的迭代。 1234$( &quot;li&quot; ).each(function() &#123; $(this).addClass( &quot;foo&quot; );&#125;); $( &quot;li&quot; ).addClass( &quot;bar&quot; ); 举例： 1.1.循环遍历给所有的&lt;li&gt;元素设置索引号， 12345678910111213141516171819&lt;body&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script&gt; $(function()&#123; $(\"li\").each(function(index,element)&#123; console.log(index); $(element).html(\"我是li\"+index); &#125;) &#125;) &lt;/script&gt; 1.2.遍历三个div并设置它们的color属性 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; color: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").click(function() &#123; $(\"div\").each(function(index) &#123; if(this.style.color != \"blue\") &#123; this.style.color = \"blue\"; &#125; else &#123; this.style.color = \"\"; &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 1.3.如果你不想要普通的DOM元素，而想获得的是jQuery对象的话，使用$(this)函数。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; ul &#123; font-size: 18px; margin: 0; &#125; span &#123; color: blue; text-decoration: underline; cursor: pointer; &#125; .example &#123; font-style: italic; &#125; &lt;/style&gt; &lt;script src=\"../../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; To do list: &lt;span&gt;(click here to change)&lt;/span&gt; &lt;ul&gt; &lt;li&gt;写作业&lt;/li&gt; &lt;li&gt;睡觉&lt;/li&gt; &lt;li&gt;吃饭&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; $(\"span\").click(function() &#123; $(\"li\").each(function() &#123; console.log($(this).toggleClass(\"example\")); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.4.如果想要提前结束each()循环,可以使用return false. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; width: 40px; height: 40px; margin: 5px; float: left; border: 2px blue solid; text-align: center; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;span&gt;&lt;/span&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div id=\"stop\"&gt;Stop&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"button\").click(function() &#123; $(\"div\").each(function(index, document) &#123; $(document).css(\"backgroundColor\", \"yellow\"); if($(this).is(\"#stop\")) &#123; $(\"span\").text(\"显式循环在此停止\" + index); return false; &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.index()方法：从匹配的元素中搜索指定元素的索引值，从0开始计数。返回值： 如果不传递任何参数给index()方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置。 如果在一组元素上调用index(),并且参数是一个DOM元素或jQuery对象.index()返回值就是传入的元素相对于原先集合的位置。 如果参数是一个选择器，index返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则.index()返回-1. 举例： 2.1.点击后，返回那个div在页面上的索引值(从0开始计数)。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; div &#123; background: yellow; margin: 5px; &#125; span &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;点我&lt;/span&gt; &lt;div&gt;我是div1&lt;/div&gt; &lt;div&gt;我是div2&lt;/div&gt; &lt;div&gt;我是div3&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"div\").click(function() &#123; var index = $(\"div\").index(this); $(\"span\").text(\"点击的DIV的索引是：\" + index); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2.返回某个指定ID的元素的索引位置 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; div &#123; font-weight: bold; color: #090; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"li1\"&gt;我是第一个li&lt;/li&gt; &lt;li id=\"li2\"&gt;我是第二个li&lt;/li&gt; &lt;li id=\"li3\"&gt;我是第三个li&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; var listItem = $('#li3'); $('div').html('Index: ' + $('li').index(listItem)); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.3.返回jQuery集合中第一项的索引值。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; div &#123; font-weight: bold; color: #090; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"li1\"&gt;我是第一个li&lt;/li&gt; &lt;li id=\"li2\"&gt;我是第二个li&lt;/li&gt; &lt;li id=\"li3\"&gt;我是第三个li&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; var listItems = $('li:gt(0)'); $('div').html( 'Index: ' + $('li').index(listItems) ); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.4.返回某个指定ID的元素相对于所有&lt;li&gt;元素的索引值。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; div &#123; font-weight: bold; color: #090; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"li1\"&gt;我是第一个li&lt;/li&gt; &lt;li id=\"li2\"&gt;我是第二个li&lt;/li&gt; &lt;li id=\"li3\"&gt;我是第三个li&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $('div').html('Index: ' + $('li2').index('li') ); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 核心-&gt;数据缓存3.data(): 数据缓存描述： 获取data值: 1234567891011121314&lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; //必须有\"data-\"前缀，这里的值可以是任何类型的值,获取值的时候不是可以获取所有类型的值，分情况。 &lt;div data-index= \"&#123;a:11&#125;\"|\"string\"|1234&gt;&lt;/div&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").click(function()&#123; //没有\"data-\"前缀，直接写名称就好,获取值的时候分为简单数据类型和复杂数据类型。 var data=$(\"div\").data(\"index\"); console.log(data); &#125;) &#125;) &lt;/script&gt; 如果是简单的类型获取的是它本身的类型的值，如果是复杂的对象获取的是字符串类型的值。 1234567&lt;div data-role=\"page\" data-last-value=\"43\" data-hidden=\"true\" data-options='&#123;\"name\":\"John\"&#125;'&gt;&lt;/div&gt;//获取值$(\"div\").data(\"role\") === \"page\";$(\"div\").data(\"lastValue\") === 43;$(\"div\").data(\"hidden\") === true;$(\"div\").data(\"options\").name === \"John\"; 设置data值：不管设置的是什么类型的值，获取到的就是相对应类型的值， 12345678910111213&lt;body&gt;&lt;button&gt;我是按钮&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"button\").click(function()&#123; $(\"div\").data(\"name\",\"张三\"|&#123;\"xiaoming\",\"18\"&#125;|\"deiji\"); var name=$(\"div\").data(\"name\"); console.log(name); &#125;) &#125;) &lt;/script&gt; 当页面先进来的时候，JQuery对象本身会收集你所有的&quot;data-&quot;属性，然后放在JQuery内部维护的对象，相当于放到内存中去了，下次去操作的时候，直接操作内存，比操作DOM的效率更快。 举例： 3.1.当鼠标放在li上面的时候，获取一下data-isLoad这个属性。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../jquery.min.js\" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"li\").mouseenter(function()&#123; var data=$(this).data(\"isload\"); if(data===0)&#123; $(this).append(\"&lt;p&gt;我是动态获取的P元素&lt;/P&gt;\"); $(this).data(\"isload\",\"1\"); //如果不设置\"isload\"的值等于\"1\"的话，mouseenter的事件就会一直触发，当执行一次了之后，\"isload\"的值等于1，不满足条件，事件就不会触发了。 &#125; &#125;) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li data-isLoad = \"0\"&gt;菜单一&lt;/li&gt; &lt;li data-isLoad = \"0\"&gt;菜单二&lt;/li&gt; &lt;li data-isLoad = \"0\"&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 核心：多库共存大家应该都知道jQuery占用了$和jQuery这两个变量,Jquery也提供了释放这两个变量的机制,释放了之后大家就可以把$和jQuery当做普通变量来使用了。 4.noConflict()：释放”$”变量,也就是说放弃jQuery控制$变量。语法格式：jQuery.noConflict( [removeAll ] ) 参数：removeAll：一个布尔值，判断是否从全局作用域中内去除所有jQuery变量(包括jQuery本身). 形式: 123var $ = &#123; name : “itecast” &#125;;$.noConflict();//释放\"$\"变量，但是此时可以使用jQuery（如果jQuery没有被占用）var my_jQ = $.noConflict();//让jQuery释放$,让$回归到jQuery之前的对象定义上去。此时,可以使用my_jQ来代替$,可以达到一样的效果。 举例： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var $=\"&#123; name : 'itecast' &#125;\"; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery.min.js\" &gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; var my_jQ = $.noConflict(); //现在已经释放了$,可以使用my_jQ来代替$,可以实现一样的效果 my_jQ(\"button\").click(function()&#123; console.log(\"我是自定义的内容\"); &#125;) console.log($); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 描述： 如果我们需要同时使用jQuery和其他javascript库，我们可以使用$.noConflict()把$的控制权交给其他库。旧引用的$被保存在jQuery的初始化; 如果由于某种原因，加载两个版本的jQuery（这是不推荐）， 第二个版本中调用$.noConflict(true)将返回全局的jQuery变量给第一个版本。 12345&lt;script type=\"text/javascript\" src=\"other_lib.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $.noConflict(); &lt;/script&gt; ready()方法可以给jQuery对象取个别名,这样就能够在传给.ready()的回调函数的内部继续使用$而不用担心冲突 123456789&lt;script type=\"text/javascript\" src=\"other_lib.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $.noConflict(); jQuery(document).ready(function($) &#123; //$符号在内部还是可以继续使用的 &#125;); //$符号在ready()函数外部不能使用了，Jquery对$控制权已经交给别人了。 &lt;/script&gt; 原因：ready()是一个闭包，ready()函数的作用域是私有类型的作用域","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之筛选","slug":"jQuery常用方法之筛选","date":"2018-06-09T00:18:10.000Z","updated":"2018-10-12T14:47:05.771Z","comments":true,"path":"2018/06/09/jQuery常用方法之筛选/","link":"","permalink":"http://yoursite.com/2018/06/09/jQuery常用方法之筛选/","excerpt":"","text":"筛选-&gt;查找1.find():，得到当前匹配的元素集合中每个元素的后代，也就是说，既要查找子元素，还要查找其后代元素。举例： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $('ul&gt;.item-ii').find('li').css('background-color', 'red'); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"level-1\"&gt; &lt;li class=\"item-i\"&gt;I&lt;/li&gt; &lt;li class=\"item-ii\"&gt;II &lt;ul class=\"level-2\"&gt; &lt;li class=\"item-a\"&gt;A&lt;/li&gt; &lt;li class=\"item-b\"&gt;B &lt;ul class=\"level-3\"&gt; &lt;li class=\"item-1\"&gt;1&lt;/li&gt; &lt;li class=\"item-2\"&gt;2&lt;/li&gt; &lt;li class=\"item-3\"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"item-c\"&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"item-iii\"&gt;III&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 实例： 1.1.为每个单词添加span标签，并为span标签添加hover事件，并且将含有t的单词变为斜体。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; font-size: 20px; width: 200px; cursor: default; color: blue; font-weight: bold; margin: 0 10px; &#125; .hilite &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; When the day is short find that which matters to you or stop believing &lt;/p&gt; &lt;script&gt; $(function() &#123; var newText = $(\"p\").text().split(\" \").join(\"&lt;/span&gt; &lt;span&gt;\"); newText = \"&lt;span&gt;\" + newText + \"&lt;/span&gt;\"; $(\"p\").html(newText) .find('span') .hover(function() &#123; $(this).addClass(\"hilite\"); &#125;, function() &#123; $(this).removeClass(\"hilite\"); &#125;) .end() .find(\":contains('t')\") .css(&#123; \"font-style\": \"italic\", \"font-weight\": \"bolder\" &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.children():获得匹配元素集合中每个元素的子元素，也就是说只选择直接子元素举例： 123456&lt;script&gt; $(function() &#123; $('.level-2').children().css('background-color', 'red'); &#125;)&lt;/script&gt; 实例： 2.1.查找被点击的元素的所有子元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; font-size: 16px; font-weight: bolder; &#125; div &#123; width: 130px; height: 82px; margin: 10px; float: left; border: 1px solid blue; padding: 4px; &#125; #container &#123; width: auto; height: 105px; margin: 0; float: none; border: none; &#125; .hilite &#123; border-color: red; &#125; #results &#123; display: block; color: red; &#125; p &#123; margin: 10px; border: 1px solid transparent; &#125; span &#123; color: blue; border: 1px solid transparent; &#125; input &#123; width: 100px; &#125; em &#123; border: 1px solid transparent; &#125; a &#123; border: 1px solid transparent; &#125; b &#123; border: 1px solid transparent; &#125; button &#123; border: 1px solid transparent; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;div&gt; &lt;p&gt;This &lt;span&gt;is the &lt;em&gt;way&lt;/em&gt; we&lt;/span&gt; write &lt;em&gt;the&lt;/em&gt; demo,&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=\"#\"&gt;&lt;b&gt;w&lt;/b&gt;rit&lt;b&gt;e&lt;/b&gt;&lt;/a&gt; the &lt;span&gt;demo,&lt;/span&gt; &lt;button&gt;write the&lt;/button&gt; demo, &lt;/div&gt; &lt;div&gt; This &lt;span&gt;the way we &lt;em&gt;write&lt;/em&gt; the &lt;em&gt;demo&lt;/em&gt; so&lt;/span&gt; &lt;input type=\"text\" value=\"early\" /&gt; in &lt;/div&gt; &lt;p&gt; &lt;span&gt;t&lt;/span&gt;he &lt;span&gt;m&lt;/span&gt;orning. &lt;span id=\"results\"&gt;Found &lt;span&gt;0&lt;/span&gt; children in &lt;span&gt;TAG&lt;/span&gt;.&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"#container\").click(function(e) &#123; $(\"*\").removeClass(\"hilite\"); var $kids = $(e.target).children(); var len = $kids.addClass(\"hilite\").length; $(\"#results span:first\").text(len); $(\"#results span:last\").text(e.target.tagName); e.preventDefault(); return false; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.parent():取得匹配元素集合中，直接的父元素，子元素会继承父元素的属性。举例： 12345&lt;script&gt; $(function() &#123; $('.item-a').parent().css('background-color', 'red'); &#125;)&lt;/script&gt; 实例： 3.1.显示页面中每个元素的父元素,可以查看 raw html 的源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div, p &#123; margin: 10px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div, &lt;span&gt;span, &lt;/span&gt; &lt;b&gt;b &lt;/b&gt; &lt;/div&gt; &lt;p&gt;p, &lt;span&gt;span, &lt;em&gt;em &lt;/em&gt; &lt;/span&gt; &lt;/p&gt; &lt;div&gt;div, &lt;strong&gt;strong, &lt;span&gt;span, &lt;/span&gt; &lt;em&gt;em, &lt;b&gt;b, &lt;/b&gt; &lt;/em&gt; &lt;/strong&gt; &lt;b&gt;b &lt;/b&gt; &lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"*\", document.body).each(function() &#123; var parentTag = $(this).parent().get(0).tagName; $(this).prepend(document.createTextNode(parentTag + \" &gt; \")); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.parents():获得指定祖先元素，也就是说不仅是父元素，还有父元素的祖先元素。举例： 1234&lt;script&gt; $('.item-a').parents().css('background-color', 'red'); &#125;) &lt;/script&gt; 子元素会继承父元素的属性 实例： 4.1.查找每个b标签的所有父元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; b, span, p, html body &#123; padding: .5em; border: 1px solid; &#125; b &#123; color: blue; &#125; strong &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt; &lt;b&gt;My parents are: &lt;/b&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; var parentEls = $(\"b\").parents() .map(function() &#123; return this.tagName; &#125;) .get().join(\", \"); $(\"b\").append(\"&lt;strong&gt;\" + parentEls + \"&lt;/strong&gt;\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2.点击元素，查找每个span标签的所有独一无二的div父元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p, div, span &#123; margin: 2px; padding: 1px; &#125; div &#123; border: 2px white solid; &#125; span &#123; cursor: pointer; font-size: 12px; &#125; .selected &#123; color: blue; &#125; b &#123; color: red; display: block; font-size: 14px; &#125; &lt;/style&gt; &lt;script src=\"../../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt; &lt;span&gt;Hello Again&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;And Hello Again&lt;/span&gt; &lt;/div&gt; &lt;/p&gt; &lt;b&gt;Click Hellos to toggle their parents.&lt;/b&gt; &lt;script&gt; $(function()&#123; function showParents() &#123; $(\"div\").css(\"border-color\", \"white\"); var len = $(\"span.selected\") .parents(\"div\") .css(\"border\", \"2px red solid\") .length; $(\"b\").text(\"Unique div parents: \" + len); &#125; $(\"span\").click(function() &#123; $(this).toggleClass(\"selected\"); showParents(); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.siblings()：获得匹配元素集合中每个元素的兄弟元素举例： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('.third-item').siblings().css('background-color', 'red'); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class=\"third-item\"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 实例： 5.1.查找3个列表中，所有黄色li元素的独一无二的的兄弟元素 (如果条件适当的话，还包括其它黄色 li 元素)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; ul &#123; float: left; margin: 5px; font-size: 16px; font-weight: bold; &#125; p &#123; color: blue; margin: 10px 20px; font-size: 16px; padding: 5px; font-weight: bolder; &#125; .hilite &#123; background: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li class=\"hilite\"&gt;Three&lt;/li&gt; &lt;li&gt;Four&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Five&lt;/li&gt; &lt;li&gt;Six&lt;/li&gt; &lt;li&gt;Seven&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Eight&lt;/li&gt; &lt;li class=\"hilite\"&gt;Nine&lt;/li&gt; &lt;li&gt;Ten&lt;/li&gt; &lt;li class=\"hilite\"&gt;Eleven&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Unique siblings: &lt;b&gt;&lt;/b&gt;&lt;/p&gt; &lt;script&gt; $(function() &#123; var len = $(\".hilite\").siblings() .css(\"color\", \"red\") .length; $(\"b\").text(len); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.prev():获取集合中每个匹配元素紧邻的前一个兄弟元素12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('.third-item').prev().css('background-color', 'red'); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class=\"third-item\"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 举例： 6.1.找到每个div紧邻的前一个兄弟元素。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; div &#123; width:40px; height:40px; margin:10px; float:left; border:2px blue solid; padding:2px; &#125; span &#123; font-size:14px; &#125; p &#123; clear:left; margin:10px; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;has child&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div id=\"start\"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;button&gt;Go to Prev&lt;/button&gt;&lt;/p&gt;&lt;script&gt; $(function()&#123; var $curr = $(\"#start\"); $curr.css(\"background\", \"#f99\"); $(\"button\").click(function () &#123; $curr = $curr.prev(); $(\"div\").css(\"background\", \"\"); $curr.css(\"background\", \"#f99\"); &#125;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.prevall()：获得集合中每个匹配元素的所有前面的兄弟元素12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('li.third-item').prevAll().css('background-color', 'red'); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class=\"third-item\"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 举例： 7.1.找到上一个div之前的所有div并给添加一个类。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; width: 70px; height: 70px; background: #abc; border: 2px solid black; margin: 10px; float: left; &#125; div.before &#123; border-color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(\"div:last\").prevAll().addClass(\"before\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.next():取得匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合12345&lt;script type=\"text/javascript\"&gt; $(function() &#123; $('li.third-item').next().css('background-color', 'red'); &#125;)&lt;/script&gt; 9.nextall()：取得匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合12345&lt;script type=\"text/javascript\"&gt; $(function() &#123; $('li.third-item').nextAll().css('background-color', 'red'); &#125;)&lt;/script&gt; next()、nextall()和prev()、prevall()使用方法都是相同的，只是表现的结果是不同的。 筛选-&gt;过滤10.eq():在匹配的集合中选择索引值为index的元素。实例： 10.1.将一个类添加到列表2，第2项，目标是第二个到最后一个 1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;eq demo&lt;/title&gt; &lt;style&gt; .foo &#123; color: blue; background-color: yellow; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;List 1, item 1&lt;/li&gt; &lt;li&gt;List 1, item 2&lt;/li&gt; &lt;li&gt;List 1, item 3&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;List 2, item 1&lt;/li&gt; &lt;li&gt;List 2, item 2&lt;/li&gt; &lt;li&gt;List 2, item 3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; $(\"li:eq(-2)\").addClass(\"foo\"); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 10.2. 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;eq demo&lt;/title&gt; &lt;script src=\"../../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;List 1, item 1&lt;/li&gt; &lt;li&gt;List 1, item 2&lt;/li&gt; &lt;li&gt;List 1, item 3&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;List 2, item 1&lt;/li&gt; &lt;li&gt;List 2, item 2&lt;/li&gt; &lt;li&gt;List 2, item 3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; $(\"ul.nav li:eq(1)\").css(\"backgroundColor\", \"#ff0\"); $(\"ul.nav\").each(function(index) &#123; $(this).find(\"li:eq(1)\").css(\"fontStyle\", \"italic\"); &#125;); $(\"ul.nav li:nth-child(2)\").css(\"color\", \"red\"); &#125;) &lt;/script&gt; &lt;/body&gt; 11.hasClass():确定指定的元素是否有给定的类如果匹配元素上有指定的样式，那么.hasClass()方法将返回true ，即使元素上可能还有其他样式。 123456789&lt;div id=&quot;mydiv&quot; class=&quot;class1 class2&quot;&gt;&lt;/div&gt;$(&apos;#mydiv&apos;).hasClass(&apos;class1&apos;) //true$(&apos;#mydiv&apos;).hasClass(&apos;class2&apos;) //true$(&apos;#mydiv&apos;).hasClass(&apos;class3&apos;) //true 举例：在匹配的元素上寻找 &#39;selected&#39; 样式 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; margin: 8px; font-size: 16px; &#125; .selected &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This paragraph is black and is the first paragraph.&lt;/p&gt; &lt;p class=\"selected\"&gt;This paragraph is red and is the second paragraph.&lt;/p&gt; &lt;div id=\"result1\"&gt;First paragraph has selected class: &lt;/div&gt; &lt;div id=\"result2\"&gt;Second paragraph has selected class: &lt;/div&gt; &lt;div id=\"result3\"&gt;At least one paragraph has selected class: &lt;/div&gt; &lt;script&gt; $(\"div#result1\").append($(\"p:first\").hasClass(\"selected\").toString()); $(\"div#result2\").append($(\"p:last\").hasClass(\"selected\").toString()); $(\"div#result3\").append($(\"p\").hasClass(\"selected\").toString()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12.map()：通过一个函数匹配当前集合中的每个元素,产生一个包含新的jQuery对象。注意：map()方法有返回值，会产生一个新的集合，而each()方法没有返回值。 map()方法的使用形式： 1234567891011第一种形式的用法：var array=[];$.map(array,function(object,index)&#123;&#125;)==&gt;全局对象的方法//参数的顺序不同，需要注意下第二种形式的用法：获取li的内部结点：var array=$(\"li\").map(function(index,element)&#123;&#125;)==实例对象的方法 举例： 12.1.第一种形式，操作数组，存在一个遍历的过程。(显式迭代) 123456789101112&lt;script&gt; $(function()&#123; var array=[\"a\",\"b\",\"c\"]; var arr=$.map(array,function(obj,index)&#123; console.log(index);//数组的索引值 return obj+\"-obj\"; &#125;) for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125; &#125;)&lt;/script&gt; 12.2.举例第二种形式：存在一个遍历的过程，(显示迭代) 12345678910111213141516171819&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; $(function()&#123; $(&quot;li&quot;).map(function(index,element)&#123; console.log(index);//数组的索引值 $(element).css(&quot;background-color&quot;,&quot;#878080&quot;); &#125;) &#125;) &lt;/script&gt; 注意这两种形式的写法的数的顺序有些不同，但是index都是表示的索引值。 实例： 12.3.获取元素集合的值 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; var string=$(':checkbox').map(function() &#123; return this.id; &#125;).get().join(); console.log(string); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"\"&gt; &lt;fieldset&gt; &lt;div&gt; &lt;label for=\"two\"&gt;2&lt;/label&gt; &lt;input type=\"checkbox\" value=\"2\" id=\"two\" name=\"number[]\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"four\"&gt;4&lt;/label&gt; &lt;input type=\"checkbox\" value=\"4\" id=\"four\" name=\"number[]\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"six\"&gt;6&lt;/label&gt; &lt;input type=\"checkbox\" value=\"6\" id=\"six\" name=\"number[]\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"eight\"&gt;8&lt;/label&gt; &lt;input type=\"checkbox\" value=\"8\" id=\"eight\" name=\"number[]\"&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12.4.获取表单中所有表单元素的值。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; p &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;b&gt;Values: &lt;/b&gt;&lt;/p&gt; &lt;form&gt; &lt;input type=\"text\" name=\"name\" value=\"张三\" /&gt; &lt;input type=\"text\" name=\"password\" value=\"123\" /&gt; &lt;input type=\"text\" name=\"url\" value=\"https://yingyo.github.io\" /&gt; &lt;/form&gt; &lt;script&gt; $(\"p\").append($(\"input\").map(function() &#123; return $(this).val(); &#125;).get().join(\", \")); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 筛选-&gt;串联Jquery的又一大特点：链式编程 13.end()：返回到作用域链被破坏的前一个状态终止在当前链的最新过滤操作，并返回匹配的元素的前一个状态 1234567891011121314151617&lt;body&gt;&lt;div&gt; &lt;p&gt;我是div内部的p元素 &lt;span&gt;我是div内部的p元素的内部的span元素&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(document).ready(function()&#123; $(\"div\") .children(\"p\") .children(\"span\") .css(\"background-color\",\"red\") .end() .css(\"background-color\",\"pink\") &#125;) &lt;/script&gt; 实例： 13.1.选择所有的段落，在其中查找span元素，之后再恢复到选择段落的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p, div &#123; margin: 1px; padding: 1px; font-weight: bold; font-size: 16px; &#125; div &#123; color: blue; &#125; b &#123; color: red; &#125; &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hi there &lt;span&gt;how&lt;/span&gt; are you &lt;span&gt;doing&lt;/span&gt;? &lt;/p&gt; &lt;p&gt; This &lt;span&gt;span&lt;/span&gt; is one of several &lt;span&gt;spans&lt;/span&gt; in this &lt;span&gt;sentence&lt;/span&gt;. &lt;/p&gt; &lt;div&gt; Tags in jQuery object initially: &lt;b&gt;&lt;/b&gt; &lt;/div&gt; &lt;div&gt; Tags in jQuery object after find: &lt;b&gt;&lt;/b&gt; &lt;/div&gt; &lt;div&gt; Tags in jQuery object after end: &lt;b&gt;&lt;/b&gt; &lt;/div&gt; &lt;script&gt; jQuery.fn.showTags = function(n) &#123; var tags = this.map(function() &#123; return this.tagName; &#125;) .get().join(\", \"); $(\"b:eq(\" + n + \")\").text(tags); return this; &#125;; $(\"p\").showTags(0) .find(\"span\") .showTags(1) .css(\"background\", \"yellow\") .end() .showTags(2) .css(\"font-style\", \"italic\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之AJAX","slug":"JQuery常用方法之AJAX","date":"2018-06-06T12:55:22.000Z","updated":"2018-10-12T14:47:13.745Z","comments":true,"path":"2018/06/06/JQuery常用方法之AJAX/","link":"","permalink":"http://yoursite.com/2018/06/06/JQuery常用方法之AJAX/","excerpt":"","text":"我们不得不承认一点我们自己封装的ajax()函数有各种各样的Bug，那我们可以看下封装JQuery的大牛封装的ajax()方法是有多么的厉害，站在巨人的肩膀上总会看的更远。 JQuery版的表单事件提交 jQuery.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; .ajax &#123; width: 400px; text-align: center; margin: 50px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"ajax\"&gt; &lt;input type=\"text\" id=\"text\" /&gt; &lt;input type=\"submit\" value=\"发送\" id=\"sub\" /&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $('#sub').on('click', function () &#123; var val = $('#text').val(); $.ajax(&#123; url: 'jquery.php', type: 'post', data: &#123;text: val&#125;, success: function (data) &#123; console.log(data); $('#result').html(data); &#125;, error: function () &#123; console.log('错误啦'); &#125;, &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery.php 123&lt;?phpecho &apos;&lt;strong&gt;&apos;.$_POST[&apos;text&apos;].&apos;&lt;/strong&gt;&apos;;?&gt; 我们明显的可以看到JQuery的方式比利用原生的JavaScript要方便的多。 首先看一下JQuery中关于ajax都封装了哪些方法， 看到这么多的方法是不是都要发怵了，不过我们只需要掌握常用的方法就好了。 ajax-&gt;请求 $.ajax(url,[settings]) load(url,[data],[callback]) $.get(url,[data],[fn],[type]) $.getJSON(url,[data],[fn]) $.getScript(url,[callback]) $.post(url,[data],[fn],[type]) $.ajaxSetup([options]) serialize()：简单的来说就是把表单的数据转化成键值对key:value的形式。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; .ajax &#123; width: 400px; text-align: center; margin: 50px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"ajax\"&gt; &lt;input type=\"text\" id=\"text\" /&gt; &lt;input type=\"submit\" value=\"发送\" id=\"sub\" /&gt; &lt;p id=\"result\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $('#sub').on('click', function () &#123; var val = $('#text').val(); $.ajax(&#123; url: 'jquery.php', type: 'post', // 约束服务器返回的数据格式 dataType: 'json', // 设置超时 timeout: 5000, data: &#123;text: val&#125;, beforeSend: function () &#123; // 通常用来做验证工作、Loading console.log('提前发送'); &#125;, success: function (data) &#123; console.log(data); $('#result').html(data); console.log(1); &#125;, error: function () &#123; console.log('错误啦'); &#125;, // 响应完成时调用，执行顺序晚于success 或者 error complete: function () &#123; console.log(2); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解释一：beforesend:function(){}：发送之前执行的函数使用场景： 比如说在提交表单数据之前，总是希望验证一下。 还有就是loading加载状态。 解释二：dataType:约束服务器返回的数据格式 dataType: &#39;json&#39;：程序继续往下执行 dataType: &#39;xml&#39;：数据的格式不正确，执行错误函数。(因为请求的是JSON类型的数据) 123 error: function () &#123; console.log('错误啦');&#125; 解释三：timeout:3000设置超时处理，当超过3秒钟后，就中断请求，不在等待了。 解释四：complete: function(){}完成响应之后指定的函数，也就是说不管是完成成功的响应，还是完成失败的响应，反正就是最后需要执行的函数。 解释五：serialize()简单的来说就是把表单的数据转化成键值对key:value的形式 解释六：$.ajaxSetup()：用来全局设置的，类似于全局变量的效果(全局===局部)关于JQuery封装的ajax()方法配置的回调函数还有很多，我们就了解一下平常能用到的就可以了。 举例：表单注册 index.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;body&gt; &lt;div class=\"register\"&gt; &lt;form id=\"ajaxForm\"&gt; &lt;ul&gt; &lt;li&gt; &lt;label for=\"\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" class=\"name\"&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"\"&gt;请设置密码&lt;/label&gt; &lt;input type=\"password\" name=\"pass\" class=\"pass\"&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"\"&gt;请确认密码&lt;/label&gt; &lt;input type=\"password\" name=\"repass\" class=\"repass\"&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"\"&gt;验证手机&lt;/label&gt; &lt;input type=\"text\" name=\"mobile\" class=\"mobile\"&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"\"&gt;短信验证码&lt;/label&gt; &lt;input type=\"text\" name=\"code\" class=\"code\"&gt; &lt;input type=\"button\" value=\"获取验证码\" class=\"verify\"&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"\"&gt;&lt;/label&gt; &lt;input type=\"button\" class=\"submit\" value=\"立即注册\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"tips\"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; //点击提交表单 $('.submit').on('click',function()&#123; var that=$(this); if(that.is('.disabled')) return; //获取表单文本框的值，可以用到serialize()方法， //把表单的数据转化成键值对key:value的形式，这种格式的数据正是我们所需要的。 var value=$(\"#ajaxForm\").serialize(); $.ajax(&#123; url:\"register.php\", type:\"post\", dataType:\"json\", data: value, beforeSend:function()&#123; if($('.name').val()=='')&#123; $('.tips p').text('用户名不能为空').show().delay(1500).fadeOut(); //终止请求 return false; &#125; //添加禁止项 that.addClass(\"disabled\"); that.val(\"正在提交\"); &#125;, success:function(data)&#123; //在接口中约定了注册成功的code为10001，注册失败的code为10002 if(data.code!=10000)&#123; alert('注册失败'); that.val('注册失败请重试'); return false; &#125;else&#123;//注册成功 location.href=\"https://yingy0.github.io/\"; &#125; &#125;, error:function()&#123; &#125;, complete:function()&#123; that.removeClass(\"disabled\"); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; register.php 123456789101112131415161718192021&lt;?php if($_POST[&apos;name&apos;]) &#123; //只要name这个表单项填写了内容，即认为注册成功, //不去复杂的判断密码的格式、用户名的格式，减轻服务端的压力 //但是如果填name这个表单项，则认为注册失败 $arr = array( &apos;code&apos;=&gt;10000, &apos;msg&apos;=&gt;&apos;注册成功&apos;, &apos;result&apos;=&gt;array(&apos;name&apos;=&gt;&apos;yangying&apos;, &apos;age&apos;=&gt;18) //具体返回的结果可能又是一个数组 ); &#125; else &#123; $arr = array( &apos;code&apos;=&gt;10002, &apos;msg&apos;=&gt;&apos;注册失败&apos;, &apos;result&apos;=&gt;&apos;一些信息&apos; ); &#125; echo json_encode($arr); sleep(3);?&gt; 解释一：获取表单文本框的值：一般情况下我们用的是val()方法获取文本框的值，但是每次只能获取一个表单文本框的值，如果我们需要所有的表单文本框的数据，那我们就得写好多个重复的代码，这样是很繁琐的。 举例 1234567891011121314151617181920 &lt;label for=&quot;&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;name&quot;&gt;&lt;/li&gt;&lt;li&gt; &lt;label for=&quot;&quot;&gt;请设置密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; class=&quot;pass&quot;&gt;&lt;/li&gt;&lt;li&gt; &lt;label for=&quot;&quot;&gt;请确认密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;repass&quot; class=&quot;repass&quot;&gt;&lt;/li&gt;&lt;li&gt; &lt;label for=&quot;&quot;&gt;验证手机&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;mobile&quot; class=&quot;mobile&quot;&gt;&lt;/li&gt;//获取用户名文本框的数据var name=$(&apos;.name&apos;).val();var pass=$(&apos;.pass&apos;).val()var repass=$(&apos;.repass&apos;).val()var mobile=$(&apos;.mobile&apos;).val() 好在JQuery的ajax方法中我们可以使用serialize()方法一次性的获取所有的表单数据并且把数据转化成键值对的形式,让我们方便了太多。 12var value=$(\"#ajaxForm\").serialize();console.log(value); 解释二：接口化开发：前后端会事先约定传递的参数格式，以及返回的数据格式。后面的开发都按照着这样约定的格式。举例： 12345678910111213&#123; $arr = array( &apos;code&apos;=&gt;10001, &apos;msg&apos;=&gt;&apos;注册成功&apos;, &apos;result&apos;=&gt;array(&apos;name&apos;=&gt;&apos;yangying&apos;, &apos;age&apos;=&gt;18) ); &#125; else &#123; $arr = array( &apos;code&apos;=&gt;10002, &apos;msg&apos;=&gt;&apos;注册失败&apos;, &apos;result&apos;=&gt;&apos;一些信息&apos; ); &#125; 采用接口化开发时，当注册成功时，会发送一些事先约定好的数据，当注册失败时，也会发送一些事先约定好的数据。 解释三：什么叫做接口在该例子中的接口是&#39;regisiter.php&#39;;其实URL地址说得高级一点就是接口。 解释四：register.phpif($_POST[&#39;name&#39;]) {} //只要name这个表单项填写了内容，即认为注册成功, //不去复杂的判断密码的格式、用户名的格式，减轻服务端的压力 //但是如果没有填name这个表单项，则认为注册失败。 success:function(data){console.log(data);} 当注册成功时，服务器发送一些成功的信息，当注册失败时，服务器发送一些失败的信息。 解释五： 当我们没有填写用户名时，服务器就会发送失败的信息，我们都知道通过表单验证很容易就知道我们到底有没有填用户名，相当于发送了这个请求是无用的，如果我们发送过多这样的无用的请求，服务器就承受了太大的压力，所以我们必须在发送请求之前拦截一些信息，减轻服务端的压力。 1234567beforeSend:function()&#123; if($('.name').val()=='')&#123; $('.tips p').text('用户名不能为空').show().delay(1500).fadeOut(); //终止请求 return false; &#125; &#125;, 大家可以从图中看到即使用户名为空，也没有发送post请求，请求register.php，在发送之前已经被拦截了下来，这就是beforeSend函数的作用。 但是如果我们去掉return false呢，我们可以看下会有什么样的结果？ 大家会看到还是发送了post请求，相当于根本就没有拦截成功，所以一定要加上return false。 解释六：注册成功时跳转到一个页面。123456789success:function(data)&#123; //在接口中约定了注册成功的code为10001，注册失败的code为10002 if(data.code!=10001)&#123; alert(&apos;注册失败&apos;); return false; &#125;else&#123;//注册成功 location.href=&quot;https://yingy0.github.io/&quot;; &#125;&#125;, 解释七：禁止🚫重复提交我们还需要完成一个功能，就是禁止重复提交，当完成了所有的数据验证之后，只允许提交一次就好了，就等待服务器的响应就行了，不然用户老是狂点，也就意味着不断地发起请求，这给服务器会造成很大的压力。也就是说提交按钮只提交一次后就变成禁止状态。 123456789101112131415161718var that=$(this); //保存当前this指针的引用if(that.is('.disabled')) return;beforeSend:function()&#123; if($('.name').val()=='')&#123; $('.tips p').text('用户名不能为空').show().delay(1500).fadeOut(); &#125; //终止请求 return false; &#125;that.addClass(\"disabled\");that.val(\"正在提交\");&#125;,complete:function()&#123; that.removeClass(\"disabled\"); that.val(\"注册失败请重试\");&#125; 我们应该把disabled类写在beforeSend函数中，原因：假如在发送前数据验证都通过了以后，这个表单就可以提交了，提交了表单之后这个提交按钮就立马要被禁用了，换句话说，在请求的这一瞬间表单就得立马被禁用，不然用户如果狂点的话，请求就还是会被发送。 但是对于没有注册成功的用户，是需要多次可以注册的，可以多次点击的，也是需要点击多次的，所以就得释放这个禁止的功能，这个要写在complete函数中，因为该函数最后都得执行。 当点击提交的时候，按钮的内容编程变为正在提交，注册成功时跳到新的页面，当提交失败时按钮的内容变为提交失败请重试。 注册失败： 注册成功： 现在该实现发送验证码功能了，其实获取验证码和注册其逻辑是类似的，我就不具体的说了。 怎么实现倒计时的功能，大家首先需要知道的是这个功能也应该写在beforeSend函数中的。 index.html 123456789101112131415161718192021222324252627282930313233//发送验证码功能 $(&apos;.verify&apos;).on(&apos;click&apos;,function()&#123; var that=$(this); if(that.is(&apos;.disabled&apos;)) return; var val=$(&apos;.mobile&apos;).val(); $.ajax(&#123; url:&apos;getCode.php&apos;, type:&apos;post&apos;, dataType:&apos;json&apos;, data:&apos;mobile:val&apos;, beforeSend:function()&#123; //在发送请求前需要验证 if(val==&apos;&apos;)&#123; $(&apos;.tips p&apos;).text(&apos;请填写手机号&apos;).show().delay(1500).fadeOut(); //终止请求 return false; &#125; that.addClass(&quot;disabled&quot;); var secondes=60; var t=setInterval(function()&#123; that.val(--secondes+&apos;秒后再次获取&apos;); if(secondes&lt;=0)&#123; clearInterval(t); that.removeClass(&quot;disabled&quot;); &#125; &#125;,1000) &#125;, success:function(data)&#123;&#125;, error:function()&#123;&#125;, complete:function()&#123; &#125; &#125;) &#125;) getCode.php 12345&lt;?php $arr = array(341232, 564512, 876567, 321653); echo $arr[array_rand($arr)]; sleep(4);?&gt; 源代码见我的github仓库：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery常用方法之css","slug":"JQuery常用方法之CSS","date":"2018-06-04T07:09:31.000Z","updated":"2018-10-12T14:47:10.521Z","comments":true,"path":"2018/06/04/JQuery常用方法之CSS/","link":"","permalink":"http://yoursite.com/2018/06/04/JQuery常用方法之CSS/","excerpt":"","text":"css-&gt;css1.CSS()：获取匹配元素集合中的第一个元素的样式属性的计算值 设置单个样式属性: $(&#39;.test&#39;).css(&#39;background-Color&#39;, &#39;purple&#39;); 设置多个样式属性: 1234$(\"#test\").css(&#123; 'background-color': '#ffe', 'border-left': '5px solid #ccc'&#125;) 获取css样式，一次只能获取一个css样式值，如果想要获取多个值，可以利用each()方法循环遍历。 123$('.test').css('background-Color');$('.test').css('border-left'); 注意: 在css属性中，如果有&#39;-&#39;连接的属性一定要带单引号或者双引号，没有用特殊字符连接的属性可以不用带引号。总而言之，引号还是带着比较好。 获取速写的CSS属性(例如： margin, background, border) 是不支持的，虽然有些浏览器有这个功能，但是不能保证。 如果你想获取已经渲染的border-width，可以使用$( elem ).css( &quot;borderTopWidth&quot; ),$( elem ).css( &quot;borderBottomWidth&quot; )，其他的也是如此，依此类推。 举例： 1.1.点击div，得到它的背景颜色 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; width: 60px; height: 60px; margin: 5px; float: left; &#125; &lt;/style&gt; &lt;script src=&quot;../jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=&quot;result&quot;&gt;&amp;nbsp;&lt;/span&gt; &lt;div style=&quot;background-color:blue;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color:rgb(15,99,30);&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color:#123456;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color:#f11;&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $(&quot;div&quot;).click(function() &#123; var color = $(this).css(&quot;background-color&quot;); $(&quot;#result&quot;).html(&quot;That div is &lt;span style=&apos;color:&quot; + color + &quot;;&apos;&gt;&quot; + color + &quot;&lt;/span&gt;.&quot;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.2.点击div，得到宽度，高度，文本颜色，背景颜色。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; height: 50px; margin: 5px; padding: 5px; float: left; &#125; #box1 &#123; width: 50px; color: yellow; background-color: blue; &#125; #box2 &#123; width: 80px; color: rgb(255, 255, 255); background-color: rgb(15, 99, 30); &#125; #box3 &#123; width: 40px; color: #fcc; background-color: #123456; &#125; #box4 &#123; width: 70px; background-color: #f11; &#125; &lt;/style&gt; &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;result&quot;&gt;&amp;nbsp;&lt;/p&gt; &lt;div id=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;div id=&quot;box3&quot;&gt;3&lt;/div&gt; &lt;div id=&quot;box4&quot;&gt;4&lt;/div&gt; &lt;script&gt; $(&quot;div&quot;).click(function() &#123; var html = [&quot;The clicked div has the following styles:&quot;]; var styleProps = $(this).css([&quot;width&quot;, &quot;height&quot;, &quot;color&quot;, &quot;background-color&quot;]); $.each(styleProps, function(prop, value) &#123; html.push(prop + &quot;: &quot; + value); &#125;); $(&quot;#result&quot;).html(html.join(&quot;&lt;br&gt;&quot;)); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.3.当你点击一个div的时候递增他的尺寸 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div &#123; width: 20px; height: 15px; background-color: #f33; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;click&lt;/div&gt; &lt;div&gt;click&lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"div\").click(function() &#123; $(this).css(&#123; width: function(index, value) &#123; return parseFloat(value) * 1.2; &#125;, height: function(index, value) &#123; return parseFloat(value) * 1.2; &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; css-&gt;位置2.offset():获取/设置指定元素的左上角的位置如果传参数就是设置offset(top，left)的值，如果不传参数就是获取offset(top,left)中的值。如果没有设置top和left的值，就获取的是原来有的值，如果设置了新的top和left的值，新的值就会覆盖原来的值，利用offset(top，left)获取到的自然是新的top和left的值。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; width:200px; height:200px; background-color: #0099CC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"../js/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"div\").offset(&#123; top:10, left:10 &#125;) var obj=$(\"div\").offset(); console.log(\"left:\"+obj.left+\",top:\"+obj.top); &#125;);&lt;/script&gt;&lt;/html&gt; 注意： 在设置left和top值的时候，只能传数值类型，不能传字符串。 12345678910(\"div\").offset(&#123; top:10; left:10; &#125;)//写成下面的形式是错的(\"div\").offset(&#123; top:\"10px\"; left:\"10px\"; &#125;) 如果没有设置position定位，那么position的默认值为static，也就是 position=static，如果设置了offset()方法之后，position的值就变成了relative，也就是position=relative。 如果你自己设置了position，并且不是static，那么position的值就是你自己设置的定位，就算设置了offset()方法之后，position的值也不会变成relative，position的值依旧是你设置的那个值。 jQuery不支持获取隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的border, margin,或 padding 信息。 若元素的属性设置的是 visibility:hidden，那么我们依然可以取得它的坐标。但是若设置的属性是 display:none，由于在绘制 DOM 树时根本就不绘制该元素，所以它的位置属性值是 undefined。 举例： 2.1.点击查看位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; p &#123; margin-left: 10px; color: blue; width: 200px; cursor: pointer; &#125; span &#123; color: red; cursor: pointer; &#125; div.abs &#123; width: 50px; height: 50px; position: absolute; left: 220px; top: 35px; background-color: green; cursor: pointer; &#125; &lt;/style&gt; &lt;script src=\"../jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"result\"&gt;Click an element.&lt;/div&gt; &lt;p&gt; This is the best way to &lt;span&gt;find&lt;/span&gt; an offset. &lt;/p&gt; &lt;div class=\"abs\"&gt; &lt;/div&gt; &lt;script&gt; $(function()&#123; $(\"*\", document.body).click(function(e) &#123; var offset = $(this).offset(); e.stopPropagation(); $(\"#result\").text(this.tagName + \" coords ( \" + offset.left + \", \" + offset.top + \" )\"); &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.position：获取匹配元素中第一个元素的当前坐标,相对于最近的那个具有定位的父元素。返回一个object，包含left和top属性 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; p&#123; position: absolute; top:100px; left: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是p元素&lt;/p&gt;&lt;/body&gt;&lt;script src=\"../js/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; console.log($(\"p\").position()); &#125;);&lt;/script&gt;&lt;/html&gt; 注意：因为position()方法不接受任何参数的值，索引position()方法只能获取已经存在的值，而不能设置值。 4.scrollTop()：获取或者设置窗口垂直方向的滚动的位置浏览器和scrollTop值存在着某种比例关系，这是由浏览器内部决定的。 如果传参数就是设置scrollTop()的值，如果不传参数就是获取scrollTop()中的值。 scrollTop的值为可滚动区域在可视区域的上方被隐藏区域的高度。 如果没有设置scrollTop()的值，而是直接获取scrollTop()值的话，获取到的值是0，如果设置了scrollTop()的值，那么获取到的值就是设置的值。 如果在页面中没有滚动条的话，设置不了值，也获取不了值。都白搭，可以设置值和获取值的前提是一定要有滚动条。(右滚动条和下滚动条) 5.scrollLeft()：获取或者设置元素水平方向滚动的位置如果传参数就是设置scrollLeft()的值，如果不传参数就是获取scrollLeft()中的值。 如果没有设置scrollLeft()的值，而是直接获取scrollLeft()值的话，获取到的值是0，如果设置了scrollLeft()的值，那么获取到的值就是设置的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; div&#123; width: 300px; height: 300px; background-color:#FF0000; overflow: scroll; &#125; p&#123; width: 1500px; height: 1500px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; //设置scrollTop值 $(\"input:eq(0)\").click(function()&#123; $(\"div\").scrollTop(\"100\"); &#125;) //获取scrollTop值 $(\"input:eq(1)\").click(function()&#123; console.log($(\"div\").scrollTop()); &#125;) //设置scrollLeft值 $(\"input:eq(2)\").click(function()&#123; $(\"div\").scrollLeft(\"200\"); //获取scrollLeft值 &#125;) $(\"input:eq(3)\").click(function()&#123; console.log($(\"div\").scrollLeft()); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"设置scrollTop值\" /&gt;&lt;input type=\"button\" value=\"获取scrollTop值\" /&gt;&lt;input type=\"button\" value=\"设置scrollLeft值\" /&gt;&lt;input type=\"button\" value=\"获取scrollLeft值\" /&gt;&lt;div&gt;&lt;p&gt;我是p元素&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置scrollTop的值伪100，设置scrollLeft的值为100 没有设置scrollTop值，直接获取，和设置了scrollTop值，获取 没有设置scrollLeft值，直接获取，和设置了scrollLeft值，获取 举例：5.1.固定导航栏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .main &#123; width: 865px; margin: 0 auto; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(window).load(function() &#123; var topHeight = $(\".top\").height(); var navHeight = $(\".nav\").height(); $(window).scroll(function () &#123; var docSccrollTop = $(document).scrollTop(); //如果scrollTop的值大于顶部图片的高度 if(docSccrollTop &gt; topHeight)&#123; $(\".nav\").css(&#123; \"position\":\"fixed\",\"top\":0 &#125;); // 此时 nav的位置固定，如果不设置 main部分的margin-top的话，将有一部分内容被挡住 nav的高度 $(\".main\").css(\"margin-top\", navHeight); &#125;else&#123; $(\".nav\").css(&#123;\"position\":\"static\"&#125;); /*静态定位*/ $(\".main\").css(\"margin-top\",0); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"top\"&gt; &lt;img src=\"imgs/top.png\" /&gt; &lt;/div&gt; &lt;div class=\"nav\"&gt; &lt;img src=\"imgs/nav.png\" /&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;img src=\"imgs/main.png\" /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注意： 顶部头图片的高度只需要获取一次就好了，所有不用绑定在scroll()函数中， scroll()表示每次滚动都会触发的事件。 css-&gt;尺寸6.height()：获取匹配元素集合中的第一个元素的当前计算高度值如果传参数就是设置height的值，如果不传参数就是获取height中的值。 7.width()：获取匹配元素集合中的第一个元素的当前计算宽度值如果传参数就是设置width中的值，如果不传参数就是获取width中的值。 关于JQuery获取图片的高度和宽度时存在着一些问题。 问题总结： 当获取图片的高度和宽度时候，有可能能获取到，但是一刷新图片的高度和宽度就变成0了。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //此时JQuery在入口函数中获取不到图片的高度，因为jQuery的执行时机，在DOM树加载之后就开始执行，图片这时候还没有加载进来。 $(document).ready(function()&#123; var height=$(\"img\").height(); var width=$(\"img\").width(); console.log(height); console.log(width); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"imgs/001.jpg\"/&gt; &lt;/body&gt;&lt;/html&gt; 可能能获取到的原因是浏览器觉得你可能需要获取到这张图片的宽度和高度，所以浏览器就告诉你了，所以一刷新图片的高度和宽度又变成0了。 css()获取高度和height获取高度的区别？ 如何动态的设置图片的高度？ 如果传参数就是设置height的值，如果不传参数就是获取height中的值。 解决办法： 在JavaScript的入口函数中可以混用JQuery的代码，在JQuery的入口函数中可以混用JavaScript的代码，同样可以获取到图片的高度。 123456789&lt;script type=\"text/javascript\"&gt;//在javaScript的入口函数，会等到所有的外部文件加载完才开始，索引肯定能获取到图片的高度和宽度 window.onload=function()&#123; var height=$(\"img\").height(); var width=$(\"img\").width(); console.log(height); console.log(width); &#125;&lt;/script&gt; 不仅可以使用onload()函数，还可以使用load()函数，在javascript中，”onload()”和”load()”的功能是一样的。 123456789&lt;script type=\"text/javascript\"&gt; window.load=function()&#123; var height=$(\"img\").height(); var width=$(\"img\").width(); console.log(height); console.log(width); &#125;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"jQuery选择器详解","slug":"jQuery选择器","date":"2018-06-02T11:20:42.000Z","updated":"2018-10-12T14:46:48.639Z","comments":true,"path":"2018/06/02/jQuery选择器/","link":"","permalink":"http://yoursite.com/2018/06/02/jQuery选择器/","excerpt":"","text":"在学习JQuery时，各类选择器是不是已经让你晕头转向，那你就来对地方了，相信大家看了这篇文章之后，一定会对JQuery的各类选择权有较为清晰的认识。 JQuery的选择器可谓是五花八门，让人们傻傻的分不清，这篇文章就来捋一捋吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; div, span &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"one\" id=\"one\"&gt; id为one,class为one的div &lt;div class=\"mini\"&gt; class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display: none;\" class=\"none\"&gt; style的display为\"none\"的div &lt;/div&gt; &lt;div class=\"hide\"&gt;class为hide的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div &lt;input type=\"hidden\" size=\"8\" /&gt; &lt;/div&gt; &lt;span&gt;span标签&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码运行的结果如下图所示，把该图看做是没有任何选择器的默认状态。 Basics：基本选择器 element：元素选择器：根据给定的元素名匹配元素 12345//选择元素名是div的所有元素$(document).ready(function()&#123;$(\"div\").css(\"background-color\",\"chartreuse\");&#125;) #id：ID选择器：根据给定的ID匹配一个元素 12345//选择id为one的元素$(document).ready(function()&#123; $(\"#one\").css(\"background-color\",\"chartreuse\"); &#125;) .class：类选择器：根据给定的类名匹配元素 12345//选择class为mini的所有元素$(document).ready(function()&#123; $(\".mini\").css(\"background-color\",\"chartreuse\"); &#125;) *：通配符选择器：根据给定的元素名匹配元素 12345//选择所有的元素$(document).ready(function()&#123; $(\"*\").css(\"background-color\",\"chartreuse\"); &#125;) selector1,selector2,selectorN：并集选择器：将每一个选择器匹配到的元素合并后一起返回 12345//选择所有的span元素和id为two的div元素$(document).ready(function()&#123; $(\"span,#two\").css(\"background-color\",\"chartreuse\"); &#125;) selector1 selector2：交集选择器：将每一个选择器匹配到的元素相交后一起返回 12345//选择父元素的id为one，子元素的class为mini的元素$(document).ready(function()&#123; $(\"#one, .mini\").css(\"background-color\",\"chartreuse\"); &#125;) Hierarchy：层次选择器 ancestor descendant：后代选择器，会选中标签名是div的下面的元素，不仅可以是一层，也可以是多层。 12345678//改变body内的所有div的背景色$(document).ready(function()&#123; $(\"body div\").css(\"background-color\",\"chartreuse\")；&#125;) parent &gt; child：子元素选择器，选中的必须是子元素，中间不能隔多层。 12345//改变body内子div元素的背景色$(document).ready(function()&#123; $(\"body&gt;div\").css(\"background-color\",\"chartreuse\");&#125;) prev + next：选取紧接在prev元素后的next元素 123456//改变class为one的下一个div的背景色$(document).ready(function()&#123; $(\".one+div\").css(\"background-color\",\"chartreuse\"); &#125;) prev ~ siblings：选取prev元素之后的索引siblings元素 1234567&lt;script type=\"text/javascript\"&gt;//改变id为two的元素后面的所有div同辈元素的背景色.$(document).ready(function()&#123; $(\"#two~div\").css(\"background-color\",\"chartreuse\"); &#125;)&lt;/script&gt; Basic Filters：基本过滤筛选器 ：first：选择第一个div元素. 12345//改变第一个&lt;div&gt;元素的背景色$(document).ready(function()&#123; $(\"div:first\").css(\"background-color\",\"chartreuse\"); &#125;) ：last：选择最后一个div元素. 12345//改变最后一个&lt;div&gt;元素的背景色$(document).ready(function()&#123; $(\"div:last\").css(\"background-color\",\"chartreuse\"); &#125;) :not(selector)：去除所有与给定选择器匹配的元素 12345//选择class不为one的所有div元素.$(document).ready(function()&#123; $(\"div:not(.one)\").css(\"background-color\",\"chartreuse\"); &#125;) :even：选取索引值是偶数的所有元素，索引值从0开始 123456//偶数（序号，从零开始）//选择索引值为偶数 的div元素。$(document).ready(function()&#123; $(\"div:even\").css(\"background-color\",\"chartreuse\"); &#125;) :odd：选取索引值是基数的所有元素，索引值从0开始 1234567/奇数（序号，从零开始）//选择 索引值为奇数 的div元素$(document).ready(function()&#123; $(\"div:odd\").css(\"background-color\",\"chartreuse\"); &#125;) :eq(index)：选取索引值等于index的元素 123456//等于（序号，从零开始）//选择索引等于 3 的元素 $(document).ready(function()&#123; $(\"div:eq(3)\").css(\"background-color\",\"chartreuse\"); &#125;) ：gt(index)：选取索引值大于index的元素 123456//大于（序号，从零开始）//选择 索引大于 3 的元素$(document).ready(function()&#123; $(\"div:gt(3)\").css(\"background-color\",\"chartreuse\"); &#125;) :lt(index)：选取索引值小于index的元素 1234567//小于（序号，从零开始）//选择索引小于 3 的元素$(document).ready(function()&#123; $(\"div:lt(3)\").css(\"background-color\",\"chartreuse\");&#125;) :header：选取所有的标题元素 123456//选择所有的标题元素.比如h1, h2, h3等等...$(document).ready(function()&#123; $(\":header\").css(\"background-color\",\"chartreuse\");&#125;) ：animated：选取当前正在执行动画的所有元素 12345//改变当前正在执行动画的元素的背景色. $(document).ready(function()&#123; $(\":animated\").css(\"background-color\",\"chartreuse\"); &#125;) ：focus：选取当前获取焦点的元素 12345//改变当前获取焦点的元素的背景色$(document).ready(function()&#123; $(\":focus\").css(\"background-color\",\"chartreuse\"); &#125;) Content Filters ：内容过滤选择器 ：contains(text)：选择含有文本内容为”text”的元素。 12345//选取含有文本\"di\"的div元素. $(document).ready(function()&#123; $(\"div:contains(di)\").css(\"background-color\",\"chartreuse\"); &#125;) ：empty：选择不包含子元素或者文本的空元素 123456 //改变不包含子元素(或者文本元素)的div空元素的背景色. $(document).ready(function()&#123; $(\":empty\").css(\"background-color\",\"chartreuse\"); &#125;) ：has(selector)：选取含有选择器所匹配的元素的元素 12345 //改变含有class为mini元素 的div元素的背景色.$(document).ready(function()&#123; $(\"div:has(.mini)\").css(\"background-color\",\"chartreuse\"); &#125;) ：parent：选取含有子元素或者文本的元素 12345 //改变含有子元素(或者文本元素)的div元素的背景色.$(document).ready(function()&#123; $(\"div:parent\").css(\"background-color\",\"chartreuse\");&#125;) Visibility Filters：可见性过滤选择器 ：hidden：选取所有不可见的元素包括&lt;input type=&quot;hidden&quot;/&gt;. 12345 //显示隐藏的元素并且改变背景色$(document).ready(function()&#123; $(\"div:hidden\").show(3000).css(\"background-color\",\"chartreuse\"); &#125;) ：visible：选取所有可见的元素. 123456//改变所有可见的&lt;div&gt;元素的背景色$(document).ready(function()&#123; $(\"div:visible\").css(\"background-color\",\"chartreuse\");&#125;) Attribute Filters ：属性过滤选择器 [attribute]：选取拥有此属性的元素 12345//选取拥有属性id的div元素$(document).ready(function()&#123; $(\"div[id]\").css(\"background-color\",\"chartreuse\"); &#125;) [attribute=value]：选取属性值为value的元素 1234//选取属性title为\"test\"的div元素$(document).ready(function()&#123; $(\"div[title=test]\").css(\"background-color\",\"chartreuse\"); &#125;) [attribute!=value]：选取属性值不等于value的元素 123456//选取属性title不等于\"test\"的div元素$(document).ready(function()&#123; $(\"div[title!=test]\").css(\"background-color\",\"chartreuse\"); &#125;)//注意：没有div的元素也会被选取 下面用一个更详细的例子来说下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div title=\"en\"&gt;title为en的div元素&lt;/div&gt; &lt;div title=\"en-UK\"&gt;title为en-UK的div元素&lt;/div&gt; &lt;div title=\"english\"&gt;title为english的div元素&lt;/div&gt; &lt;div title=\"en uk\"&gt;title为en uk的div元素&lt;/div&gt; &lt;div title=\"uken\"&gt;title为uken的div元素&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; [attribute^=value]：选取属性值以value开头的元素 123456//选取属性title值以en开始div元素. $(document).ready(function()&#123; $(\"div[title^=en]\").css(\"background-color\",\"chartreuse\"); &#125;); [attribute$=value]：选取属性值以value结束的元素 12345//选取 属性title值 以en为结尾的div元素. $(document).ready(function()&#123; $(\"div[title$=en]\").css(\"background-color\",\"chartreuse\") &#125;); [attribute*=value]：选取属性值含有value的元素 123456//任意对个，包含的关系//选取 属性title值 含有 en 的div元素. $(document).ready(function()&#123; $(\"div[title*=en]\").css(\"background-color\",\"chartreuse\") &#125;); [attribute|=value]：选取属性值等于给定字符串或以该字符串为前缀的元素 12345//选取属性title等于en或以en为前缀（该字符串后跟一个连字符'-'）的元素 $(document).ready(function()&#123; $(\"div[title|=en]\").css(\"background-color\",\"chartreuse\") &#125;); [attribute~=value]：选取属性用空格分隔的值中包含一个给定的元素 12345//选取属性title用空格分隔的值中包含字符uk的元素. $(document).ready(function()&#123; $('div[title~=uk]').css(\"background-color\",\"chartreuse\") &#125;); [attrSel1][attrSel2][attrSelN]：用属性选择器合并成一个复合属性选择器，满足多个条件，每次选择一次，缩小一次范围，既满足第一个，又满足第二个，又满足第三个…. 12345 //选取拥有属性id,并且属性title以\"test\"结束的&lt;div&gt;元素 $(document).ready(function()&#123; $('div[id][title=test]').css(\"background-color\",\"chartreuse\")&#125;); Child Filter ：子元素过滤选择器（索引从1开始） :first-child：选取每个父元素下的第一个子元素 12345//改变class为one的&lt;div&gt;父元素下的第一个子元素的背景色 $(document).ready(function()&#123; $('.one :first-child').css(\"background-color\",\"chartreuse\"); &#125;); :last-child：选取每个父元素下的最后一个子元素 12345 //改变class为one的&lt;div&gt;父元素下的最后一个子元素的背景色$(document).ready(function()&#123; $('.one :last-child').css(\"background-color\",\"chartreuse\"); &#125;); ：nth-child：表示的是第几。子元素中的第几个元素 ：nth-child(even)：偶数 ：nth-child(odd)：奇数 ：nth-child(2)：第二个 12345//改变每个class为one的&lt;div&gt;父元素下的第二个子元素的背景色 $(document).ready(function()&#123; $('.one :nth-child(2)').css(\"background-color\",\"chartreuse\")&#125;); ：nth-child(2n)：偶数倍 ：nth-child(2n+1)：基数倍 ：only-child：只选中是单独子元素的元素，如果父元素下的仅仅只有一个子元素，那么选中这个子元素 12345 //如果class为one的&lt;div&gt;父元素下只有一个子元素，那么则改变这个子元素的背景色 $(document).ready(function()&#123; $('.one :only-child').css(\"background-color\",\"chartreuse\")&#125;); Forms：表单选择器$(‘:input’)：选取所有的&lt;input&gt;元素、&lt;textarea&gt;元素、&lt;select&gt;元素、和&lt;button&gt;元素 $(‘:text’)：选取所有的单行文本框 $(‘:password’)：选取所有的密码框 $(‘:radio’)：选取所有的单选框 $(‘:checkbox’)：选取所有的多选框 $(‘:submit’)：选取所有的提交按钮 $(‘:image’)：选取所有的图像按钮 $(‘:reset’)：选取所有的重置按钮 $(‘:button’)：选取所有的按钮 $(‘:file’)：选取所有的上传域 $(‘:hidden)：选取所有不可见元素 Form Filters：表单对象属性过滤选择器$(‘:enabled’)：选取所有可用元素 $(‘:disabled’)：选取所有不可用元素 $(‘:checked’)：选取所有被选中的元素（单选框、复选框） $(‘:selected’)：选取所有被选中的选项元素（下拉列表）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript框架","slug":"JavaScript框架","permalink":"http://yoursite.com/tags/JavaScript框架/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"闭包的作用","slug":"闭包的作用","date":"2018-05-20T15:20:20.000Z","updated":"2018-10-12T14:46:13.828Z","comments":true,"path":"2018/05/20/闭包的作用/","link":"","permalink":"http://yoursite.com/2018/05/20/闭包的作用/","excerpt":"","text":"闭包的作用1.封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成&quot;私有变量&quot; 举例：我们有一个可以计算乘积的函数 12345678function mult()&#123; var s=1; for(var i=0;i&lt;arguments.length;i++)&#123; s=s*arguments[i]; &#125; return s;&#125;mult(2,3,4); //24 mult函数接受一些number类型的参数，并返回这些参数的乘积。但是对于有些函数的调用是相同参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高函数的性能。 123456789101112131415var cache=[];function mult()&#123; var args=Array.prototype.join.call(arguments,&apos;,&apos;); if(cache[args])&#123; return cache[args];&#125; var s=1; for(var i=0;i&lt;arguments.length;i++)&#123; s=s*arguments[i]; &#125; return cache[args]=s;&#125;console.log(mult(2,3,4)); //24console.log(mult(2,3,4)) //24 变量cache仅在mutl函数内部被使用，与其让cache变量与mult函数一起平行地暴露在全局作用域下，还不如把变量cache封装在mult函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。 123456789101112131415(function mult()&#123;var cache=[];return function()&#123; var args=Array.prototype.join.call(arguments,&apos;,&apos;); if(args in cache)&#123; return cache[args];&#125; var s=1; for(var i=0;i&lt;arguments.length;i++)&#123; s=s*arguments[i]; &#125; return cache[args]=s; &#125;&#125;)() 我们应该尽量让每一个函数中只有一个功能，尽量保证单一职责原则。 123456789101112131415(function mult()&#123; var cache=[]; function calc=function()&#123; var s=1; for(var i=0;i&lt;arguments.length;i++)&#123; s=s*arguments[i]; &#125; return s;&#125;return function()&#123; var args=Array.prototype.join.call(arguments,&apos;,&apos;); if(args in cache)&#123; return cache[args]=calc.apply(null,arguments); &#125;&#125;)() 2.延续局部变量的寿命img对象常常用于进行数据上报 12345function report(scr)&#123; var img=new Image(); img.src=src;&#125;;report(&quot;http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_15.png&quot;); 通过查询后台的记录我们可以发现，一些低版本浏览器的实现存在Bug，在这些低版本浏览器下使用report函数进行数据上报会丢失30%左右的数据，这也就意味着，report函数并不是每一次都成功发起了HTTP请求。 丢失数据的原因是img是report函数中的局部变量，当report函数的调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出HTTP请求，所以请求就会丢失掉。 我们可以利用闭包将img变量的作用域一直保存在内存中。 1234567891011121314(function report(scr)&#123; var img=new Image(); img.src=src;&#125;;report(&quot;http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_15.png&quot;);(function()&#123; var imgs=[]; return function(src)&#123; var img=new Image(); imgs.push(img); img.src=src; &#125;&#125;)()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"闭包","slug":"闭包","date":"2018-05-18T10:08:20.000Z","updated":"2018-10-12T14:46:15.746Z","comments":true,"path":"2018/05/18/闭包/","link":"","permalink":"http://yoursite.com/2018/05/18/闭包/","excerpt":"","text":"闭包的形成与变量的作用域以及变量的生存周期密切相关 1.变量的作用域变量的作用域指变量的有效范围，一般说的变量的作用域就是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量，这是一种容易造成命名冲突的做法。 用var关键词在函数中声明的变量是全局变量，只有该函数内部才能访问到这个变量，在函数外部是访问不到的。 123456function func()&#123; var a=1; console.log(a); //1&#125;func();console.log(a);//报错：a is not defined 在javascript中，函数可以用来创造函数作用域，此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的作用域。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。 123456789101112131415161718var a=1;function func1()&#123; var b=2; function func2()&#123; var c=3; console.log(a);//1 console.log(b);//2 console.log(c);//3 &#125; func2(); console.log(c);//报错c is not defined console.log(b);//2 console.log(a);//1&#125;func1();console.log(a);//1console.log(b);//报错b is not definedconsole.log(c);//报错c is not defined 注意：函数中变量的搜索是从内到外搜索的。 2.变量的生存周期对于全局变量来说，全局变量的生存期是永久的，除非我们主动销毁这个全局变量 对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。 123456789101112131415161718192021function func()&#123; var a=1; //退出函数后局部变量a将被销毁 console.log(a); //1&#125;func();我们可以看一下闭包形成的变量的作用域：function func()&#123; var a=1; return function()&#123; a++ console.log(a); &#125;&#125;var f=func();f();//2f();//3f();//4f();//5f();//6 在闭包结构中，从上述代码我们可以看出，局部变量a并没有消失，而是似乎在某个地方一直存活着。这是因为当执行var f=fun();，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处于在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。 关于闭包有一个典型的应用 假设页面上有5个div节点，我们通过循环来给每个div绑定onclick事件，按照索引顺序，点击第1个div时弹出0，点击第2个时弹出1，以此类推。 123456789101112131415&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div=document.getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;div.length;i++)&#123; div[i].onclick=function()&#123; console.log(i); &#125; &#125;&lt;/script&gt; 在浏览器运行一下，你可能会发现无论点击哪个div，最后弹出的结果都是5。这是因为div节点的onclick事件是被异步触发的，当事件被触发的时候，for循环早已结束，此时变量i的值已经是5，所以在div节点的onclick事件函数中顺着作用域链从内到外查找变量i时，查找到的值总是5。 解决方法： 利用闭包，把每次循环的i值都封闭起来，当在事件函数中顺着作用域链中从内到外查找变量i时，会先找到被封闭在闭包环境中的i,如果有5个div，i的值就分别是0,1,2,3,4。 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt;&lt;/body&gt;&lt;script&gt;var div=document.getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;div.length;i++)&#123; (function(i)&#123; div[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i)&#125;&lt;/script&gt;或&lt;script&gt;var div=document.getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;div.length;i++)&#123; div[i].onclick=(function(i)&#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;&lt;/script&gt; 总结：闭包的作用 1、将局部变量的生存期保存下来，即使在退出函数时，变量的作用域也不会被销毁，会一直存在，除非主动释放。 2、封装变量的值(div点击事件) 3、将某个变量作用域只在某个函数下存在。(缓存机制) 4、延续局部变量的寿命","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"call和apply的用途","slug":"call和apply的用途","date":"2018-05-16T11:00:20.000Z","updated":"2018-10-12T14:47:34.662Z","comments":true,"path":"2018/05/16/call和apply的用途/","link":"","permalink":"http://yoursite.com/2018/05/16/call和apply的用途/","excerpt":"","text":"call和apply的用途1.改变this指向call和apply最常见的用途是改变函数内部的this指向 123456789101112131415var obj1=&#123; name: &quot;张三&quot;&#125;var obj2=&#123; name: &quot;李四&quot;&#125;window.name=&quot;window&quot;;function showname()&#123; console.log(this.name);&#125;showname() //window(this指向window)showname.call(obj1); //张三(this指向obj1)showname.apply(obj2); //李四(this指向obj2) 当执行showname.call(obj1);时，showname函数体内的this就指向obj1对象， 123456function showname()&#123; console.log(this.name);&#125;相当于function showname()&#123; console.log(obj1.name);&#125; 我们经常会遇到this指向被不经意改变的场景： 比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的 123document.getElementById(&quot;div&quot;).onclick=function()&#123; console.log(this.id); //div&#125; 假如该事件函数中有一个内部函数func，在事件内部调用func函数时，func函数内部的this这时指向了window，而不是我们期望的div. 123456789window.id=&quot;window&quot;;document.getElementById(&quot;div&quot;).onclick=function()&#123; console.log(this.id); //div function func()&#123; console.log(this.id); //window console.log(this==window); //true &#125; func();&#125; 我们可以用call来修正func函数内的this，使其指向this。 12345678document.getElementById(&quot;div&quot;).onclick=function()&#123; console.log(this.id); //div function func()&#123; console.log(this.id); //div console.log(this==div); //true &#125; func.call(this);&#125; 2.Function.prototype.bind()bind()方法的主要作用就是将函数绑定至某个对象，bind方法()会创建一个函数，函数体内this对象的值会被绑定到传入bind()函数的值。 主流的浏览器都实现了内置的Function.prototype.bind()，用来指定函数内部的this指向。 我们可以自己模拟一个bind()方法。 1234567891011121314Function.prototype.bind=function(context)&#123; var that=this; //保存原函数 return function()&#123; //返回一个新的函数 return that.apply(context,arguments); //执行新的函数的时候，会把之前传入的context当做新函数体内的this。 &#125;&#125;var obj=&#123; name:&quot;张三&quot;&#125;var func=function()&#123; console.log(this.name);//张三&#125;.bind(obj);func(); 通过Function.prototype.bind包装func函数，并且传入一个对象context当做参数，这个context对象就是我们想修正的this对象。 在Function.prototype.bind的内部实现中，我们先把func函数的引用保存下来，然后返回一个新的函数。当我们将来在执行func函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，that.apply(context,arguments)这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。 我们可以封装一个更复杂的bind()方法，可以往func含糊是中预先填入一些参数。 123456789101112131415161718Function.prototype.bind=function()&#123; var that=this; //保存原函数 context=[].shift.call(arguments); //取得外部传入的构造器(arguments=&gt;obj) args=[].slice.call(arguments);//剩下的参数转换成数组 return function()&#123; //返回一个新的函数 return that.apply(context,[].concat.call(args,[].slice.call(arguments))); //执行新的函数的时候，会把之前传入的context当做新函数体内的this。 //并且组合两次分别传入的context当做新函数体内的this &#125;&#125;;var obj=&#123; name:&quot;张三&quot;&#125;var func=function(a,b,c,d)&#123; console.log(this.name);//张三 console.log([a,b,c,d]); //[1, 2, 3,4]&#125;.bind(obj,1,2);func(3,4); 3.借用其他对象的方法3.1.借用构造函数基于混合的对象冒充和原型方式实现继承 123456789101112131415function A(name)&#123; this.name=name;&#125;A.prototype.showname=function()&#123; console.log(this.name);&#125;function B(name)&#123; //一定要带参数 A.call(this,name);&#125;B.prototype=new A();var b=new B(&quot;李四&quot;);console.log(b.showname()); //李四console.log(b.__proto__==B.prototype) //trueconsole.log(B.prototype.__proto__==A.prototype) //true 通过借用构造函数，我们可以实现继承的效果。 函数的参数列表arguments是一个类数组，虽然它也有”下标”，但它并非真正的数组，所以不能像数组一样，进行排序操作或者往集合里添加一个新的元素,这时我们通常会借用Array.prototype对象上的方法。 举例： 往arguments中添加一个新的元素，通常会借用Array.prototype.push. 1234(function()&#123; Array.prototype.push.call(arguments,3); console.log(arguments); //[1,2,3]&#125;)(1,2); 想要整理arguments中的元素，通常会借用Array.prototype.sort 1234(function()&#123; Array.prototype.sort.call(arguments); console.log(arguments); //[1,2,3]&#125;)(5,2,6,1); //[1, 2, 5, 6] 3.2.关于Array.prototype.push方法Google-V8引擎源码中关于push方法的封装 123456789function ArrayPush() &#123; var n = TO_UINT32(this.length); // 被push的对象的length var m = %_ArgumentsLength(); // push 的参数个数 for (var i=0; i&lt;m; i++) &#123; this[i+n] = %_Arguments(i); //复制元素(1) &#125; this.length=n+m; // 修正length属性的值(2) return this.length;&#125;; 通过上述代码可以看出Array.prototype.push方法实际上是一个属性复制的过程，把参数按照下标依次添加到被push的对象上面，顺便修改了这个对象的length属性。至于被修改的对象是谁，到底是数组还是类数组对象，这并不重要。 所以我们可以把”任意”对象传入Array.prototype.push; 1234var a=&#123;&#125;;Array.prototype.push.call(a,&quot;first&quot;,&quot;second&quot;);console.log(a.length); //2console.log(a[0]); //first 其实这里的&quot;任意&quot;对象是有条件限制的： 对象本身要可以存取属性 对象的length属性可读写 如果借用Array.prototype.push方法的不是一个object类型的数据，而是一个number类型的数据，会有什么效果？ 1234var a=0;Array.prototype.push.call(a,&quot;first&quot;,&quot;second&quot;);console.log(a.length); //undefinedconsole.log(a[0]); //firsundefined 我们无法在number类型上存取其他数据，所以一个number类型的数据不可能借用到Array.prototype.push方法 函数的length属性只是一个只读的属性，表示形参的个数，如果把一个函数传入Array.prototype.push会发生什么呢？ 123function func()&#123;&#125;Array.prototype.push.call(func,&quot;first&quot;,&quot;second&quot;);console.log(func.length); //Cannot assign to read only property &apos;length&apos; of function &apos;function func()&#123;&#125;&apos;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"call和apply","slug":"call和apply","date":"2018-05-15T05:20:20.000Z","updated":"2018-10-12T14:47:36.565Z","comments":true,"path":"2018/05/15/call和apply/","link":"","permalink":"http://yoursite.com/2018/05/15/call和apply/","excerpt":"","text":"ECMAScript3给Function的原型定义了两个方法Function.prototype.call或Function.prototype.apply，在一些函数式风格的代码编写中，call()方法和apply方法扮演着及其重要的角色，它们所实现的功能是一模一样的，区别仅仅在于传入参数形式的不同。 1.apply方法apply()方法接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。 1234function func(a,b,c)&#123; console.log([a,b,c]); //[1, 2, 3]&#125;func.apply(null,[1,2,3]) 在上述代码中，参数1、2、3被放在数组中一起传入func函数，它们分别对应func参数列表中的a、b、c。 2.call方法call()方法传入的参数数量不固定，第一个参数同样指定了函数体内this对象的指向，从第二个参数开始往后，每个参数被依次传入函数。 1234function func(a,b,c)&#123; console.log([a,b,c]); //[1, 2, 3]&#125;func.call(null,1,2,3) 当调用一个函数时，JavaScript的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript的参数在内部就是用一个数组来表示的，从这个层面来说，apply比call的使用率更高。 如果我们想要明确地知道函数接受多少参数，而且想一目了然地表达形参和实参的对应关系，可以使用call来传递参数。 使用call或者apply时，如果传入的第一个参数是null，函数体内的this会指向window。 12345function func(a,b,c)&#123; console.log([a,b,c]); //[1, 2, 3] console.log(this==window ); //true&#125;func.call(null,1,2,3) 如果是在严格模式下，函数体内的this为null 123456function func(a,b,c)&#123; &quot;use strict&quot; console.log([a,b,c]); //[1, 2, 3] console.log(this==undefined); //true&#125;func.call(null,1,2,3) 有时使用call和apply的目的并不在于指定this指向，而是可以借用其他对象的方法，我们可以传入null来代替某个具体的对象。 12345Math.max.apply(null,[3,5,6,8,1]); //8Math.min.apply(null,[3,5,6,8,1]); //1Math.random.apply(null,[0,1]) //0.6309077036021082 Math对象是内置对象，不用实例化就可以直接使用。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"this","slug":"this","date":"2018-05-14T06:40:40.000Z","updated":"2018-10-12T14:46:43.518Z","comments":true,"path":"2018/05/14/this/","link":"","permalink":"http://yoursite.com/2018/05/14/this/","excerpt":"","text":"JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 1.this的指向关于this的指向可以分为四种情况 1.作为对象的方法调用 2.作为函数的实例化对象调用 2.作为普通函数调用 3.构造器调用 4.Function.prototype.call或Function.prototype.apply调用 1.1.作为对象的方法调用当函数作为对象的方法被调用时，this指向该对象。 12345678var obj=&#123; name:&quot;张三&quot;, showname:function()&#123; console.log(this.name); //张三 console.log(this==obj) //true &#125;&#125;obj.showname(); //函数作为对象的方法被调用 1.2.作为对象的构造函数 被调用当函数作为对象的构造函数被调用时，this指向实例化的对象。 12345678910function A()&#123; this.name=&quot;张三&quot;; this.showname=function()&#123; console.log(this.name); //张三 console.log(this==a); //true &#125;&#125;var a=new A();console.log(a.showname());//函数作为对象的构造函数被调用时console.log(a.__proto__==A.prototype) //true 1.3.作为普通函数调用当函数不作为对象的属性被调用时，也就是普通函数方法，this指向全局对象，在浏览器的JavaScript里，这个全局对象是window对象。 123456window.name=&quot;张三&quot;;function showname()&#123; console.log(this.name); //张三 console.log(this==window);//true&#125;showname();//普通的函数调用 或者 12345678910window.name=&quot;张三&quot;;var obj=&#123; name:&quot;王五&quot;, showname:function()&#123; console.log(this.name); //张三 console.log(this==window); //true &#125; &#125;var showname=obj.showname;console.log(showname());//普通的函数调用 举例： 在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this这时指向了window，但我们往往想让它指向该div节点。 1234567891011121314&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;script&gt; window.id=&quot;window&quot;; document.getElementById(&quot;div1&quot;).onclick=function()&#123; console.log(this.id); //div1 function callback()&#123; console.log(this==window);//true console.log(this.id) //window &#125; callback(); &#125;&lt;/script&gt; 最简单的解决方案是，用一个变量保存div节点的引用。 123456789101112131415&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;script&gt; window.id=&quot;window&quot;; document.getElementById(&quot;div1&quot;).onclick=function()&#123; console.log(this.id); //div1 var that=this; function callback()&#123; console.log(that==div1);//true console.log(that.id) //div1 &#125; callback(); &#125;&lt;/script&gt; 在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined。 123function func()&#123; &quot;user strict&quot;&#125; 1.4.构造器调用除了内置对象，大部分JavaScript函数都可以当作构造器使用，构造器函数的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this对象就指向返回的这个对象。 12345678function showname()&#123; this.name=&quot;张三&quot;; console.log(this); //showname &#123;name: &quot;张三&quot;&#125;&#125;var getname=new showname();console.log(getname.name);//张三console.log(this==window); //true 如果构造器显示地返回一个Object类型的对象，那么this的指向是显示返回的那个对象，而不是我们之前期待的this。 1234567891011function showname()&#123; this.name=&quot;张三&quot;; return &#123; name:&quot;李四&quot; &#125; console.log(this); //&#123;name: &quot;李四&quot;&#125;&#125;var getname=new showname();console.log(getname.name);//李四console.log(this==window); //true 如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，this的指向就不是改变。 12345678function showname()&#123; this.name=&quot;张三&quot;; return name:&quot;李四&quot; console.log(this); //showname &#123;name: &quot;张三&quot;&#125;&#125;var getname=new showname();console.log(getname.name);//张三console.log(this==window); //true 4.Function.prototype.call或Function.prototype.apply调用 利用Function.prototype.call或Function.prototype.apply可以动态的改变传入函数的this。 12345678910111213141516var obj1=&#123; name:&quot;张三&quot;, showname:function()&#123; console.log(this.name); console.log(this); //第一次调用：this的指向：&#123;name: &quot;张三&quot;, showname: ƒ&#125; //第二次调用：this的指向：&#123;name: &quot;李四&quot;&#125; &#125;&#125;var obj2=&#123;name:&quot;李四&quot;;&#125;console.log(this)//windowconsole.log(obj1.showname());//张三console.log(this) //windowconsole.log(obj1.showname.call(obj2)); //李四 2.丢失的this12345678910var obj=&#123; name:&quot;张三&quot;, showname:function()&#123; console.log(this.name); console.log(this==obj); &#125;&#125;obj.showname(); ////函数作为对象的方法被调用(张三和true)var showname1=obj.showname;console.log(showname1()); //普通的函数调用(undefined和false)this-&gt;window 当调用obj.showname()时，showname()方法是作为obj对象的属性被调用的，此时的this指向obj对象。 当用变量showname1来引用obj.showname，并且调用showname1()时，此时是普通函数调用方式，this是指向全局window的。 3.关于document.getElementById用document.getElementById获取元素ID值时，这个方法名实在是太长了，我们可以封装一下。 1234567window.onload=function()&#123;function getId(id)&#123; return document.getElementById(id);&#125; var div=getId(&quot;div&quot;); //获取到元素的ID值 console.log(div.id); //div&#125; 我们是不是还可以用更加简便的方式： 123var getId=document.getElementById;var div=getId(&quot;div&quot;); //获取到元素的ID值console.log(div.id); //报错 可以尝试在浏览器中运行一下： 123456789&lt;body&gt; &lt;div id=&quot;div&quot;&gt;我是一个div&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload=function()&#123;var getId=document.getElementById;getId(&quot;div&quot;);&#125;&lt;/script&gt; 答案：不可以 浏览器引擎的document.getElementById方法的内部实现中需要用到this，this本来被期望指向document，当getElementById方法当做document对象的属性被调用时，方法内部的this确实指向document，但当用getId来引用document.getElementById之后，再调用getId，此时就成了普通函数调用，函数内部的this指向了window，而不是document。 我们可以使用apply或者call把document当做this传入getId函数，帮助&quot;修正&quot;this. 123456789document.getElementById=(function(func)&#123; return function()&#123; return func.call(document,arguments); &#125;&#125;)(document.getElementById)var getId=document.getElementById;var div=getId(&quot;div&quot;);console.log(div.id); //div","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JavaScript中的原型继承","slug":"JavaScript中的原型继承","date":"2018-05-12T03:20:50.000Z","updated":"2018-10-12T14:47:16.120Z","comments":true,"path":"2018/05/12/JavaScript中的原型继承/","link":"","permalink":"http://yoursite.com/2018/05/12/JavaScript中的原型继承/","excerpt":"","text":"原型继承在JavaScript中有几条原型继承的原则： 1.所有的数据都是对象 2.要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它。 3.对象会记住它的原型 4.如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 1.所有的数据都是对象JavaScript的数据类型分为原始数据类型和引用数据类型， 原始类型的值包括5种，分别是undefined、Null、Bollean、Number、和String。 原始数据类型中除了null、undefined剩下的三个Bollean、Number、和String都是伪对象。 引用数据类型中所有的其他类都是由Object类继承而来，所以所有的引用数据类型都是对象。 1234567891011Array.prototype.__proto__==Object.prototype //trueDate.prototype.__proto__==Object.prototype //trueFunction.prototype.__proto__==Object.prototype //trueString.prototype.__proto__==Object.prototype //trueRegExp.prototype.__proto__==Object.prototype //trueNumber.prototype.__proto__==Object.prototype //true 所以说所有的数据都是对象，一点也不为过吧。 JavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象，JavaScript中的每个对象，实际上都是从Object.prototypr对象克隆来的，Object.prototype对象就是它们的原型。 12345678910var obj1=new Object();var obj2=&#123;&#125;;console.log(Object.getPrototypeOf(obj1)==Object.prototype); //trueconsole.log(Object.getPrototypeOf(obj1)==Object.prototype); //trueconsole.log(obj1 instanceof Object); //trueconsole.log(obj1 instanceof Object); //true 2.要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它。在JavaScript语言中，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的，我们所需要的做的只是显示地调用var obj1=new Object();或者var obj2={};。此时引擎内部会从Object.prototype上面克隆出一个对象出来，我们最终得到的就是这个克隆出来的对象。 构造函数+原型方式创建对象： 12345678910111213function Person(name)&#123; this.name=name;&#125;Person.prototype.showname=function()&#123; console.log(this.name);&#125;var a=new Person(&quot;张三&quot;);console.log(a.name); //张三console.log(a.getname()); //张三console.log(Object.getPrototypeOf(a)==Person.prototype); //trueconsole.log(a instanceof Person); //truea.__proto__==Person.prototype;Person.prototype.__proto__==Object.prototype; 注意：Person表示的不是类，而是函数构造器，JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new运算符来调用函数时，此时的函数就是一个构造器。 用new运算符创建对象的过程，实际上也是先克隆Object.prototype对象，再进行一些其他额外操作的过程。 new运算的过程： 1234567891011121314151617181920function Person(name)&#123; this.name=name;&#125;Person.prototype.showname=function()&#123; console.log(this.name);&#125;;function newPerson()&#123; var obj=new Object(); //从Object.prototype上克隆一个空的对象 Constructor=[].shift.call(arguments); //取得外部传入的构造器(arguments=&gt;Person) obj.__proto__=Constructor.prototype; //指向正确的原型 obj.__proto__==Person.prototype var ret=Constructor.call(obj,arguments); //借用外部传入的构造器给obj设置属性(arguments=&gt;&quot;张三&quot;) return typeof ret === &apos;object&apos; ? ret : obj; //确保构造器总是会返回一个对象&#125;;var a=newPerson(Person,&quot;张三&quot;);console.log(a.name); //张三console.log(a.showname()); //张三console.log(Object.getPrototypeOf(a)==Person.prototype); //trueconsole.log(a instanceof Person); //true 3.对象会记住它的原型对JavaScript的真正实现来说，并不能说对象有原型，只能说对象的构造器有原型。与其说”对象把请求委托给它自己的原型”，还不如说”对象把请求委托给它的构造器的原型”。 __proto__属性:某个对象的__proto__属性默认会指向它的构造器的原型对象{Constructor}.prototype。 var obj=new Object();console.log(obj.proto==Object.prototype) //true __proto__就是对象与”对象构造器的原型”联系起来的纽带，对象通过__proto__属性来记住它的构造器的原型。 4.如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止。 虽然JavaScript的每个对象都是由Object.prototype对象克隆而来的，但对象构造器的原型并不仅限于Object.prototype,而是可以动态指向其他对象。也就是说，当对象a需要借用对象b的能力时，可以有选择性地把对象a的构造器的原型指向b，从而达到继承的效果。 12345678910111213function A(name)&#123;this.name=name;&#125;A.prototype.showname=function()&#123; console.log(this.name);&#125;var a=new A(&quot;张三&quot;);console.log(a.name); //张三console.log(a.__proto__==A.prototype) //true 在执行上述代码时，搜索引擎做了哪些事？ 第一步：尝试遍历对象a中的所有属性，但没有找到name这个属性。 第二步：查找name属性的这个请求被委托给对象a的构造器的原型(A.prototype)。它被a.__proto__记录着并且指向A.prototype。 第三步：在函数A中找到了name属性，并返回它的值。 通过原型的方式实现继承。 1234567891011121314151617function A()&#123;&#125;A.prototype.name=&quot;张三&quot;;function B()&#123;&#125;B.prototype=new A();var b=new B();console.log(b.name); //张三console.log(b.age); //undefinedconsole.log(b.__proto__==B.prototype); //trueconsole.log(B.__proto__==A.prototype); //falseconsole.log(B.prototype.__proto__==A.prototype)//trueconsole.log(B.__proto__==A.__proto__)//true;console.log(A.__proto__==Object.__proto__); //trueconsole.log(A.prototype.__proto__==Object.prototype)//true 在执行上述代码时，搜索引擎又做了哪些事？ 第一步：尝试遍历对象a中的所有属性，但没有找到name这个属性。 第二步：查找name属性的请求被委托给对象B的构造器的原型(B.prototype)。它被b.__proto__记录着并且指向B.prototype。而B.prototype被设置为一个通过new A()创建出来的对象。 第三步：在该对象中依然没有找到name属性，于是请求被继续委托给这个对象构造器的原型A.prototype。 第四步：在A.prototype中找到了name属性，并返回给它的值。 原型链并不是无限长的，假设我们想要访问对象b的age属性，而对象b和它的构造器的原型上都没用age属性，那么这个请求会被最终传递到哪里去呢？ 当请求到达A.prototype，并在A.prototype中也没有找到age属性的时候，请求会被传递给A.prototype的构造器原型Object.prototype，显然Objec.prototype中也没有age属性，并且Objec.prototype的原型是null，所以这次请求就到头了，b.age返回undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"封装","slug":"封装","date":"2018-05-10T07:50:56.000Z","updated":"2018-10-12T14:46:41.925Z","comments":true,"path":"2018/05/10/封装/","link":"","permalink":"http://yoursite.com/2018/05/10/封装/","excerpt":"","text":"面向对象是一种对现实世界理解和抽象的方法，系统中一切事物皆对象，对象是属性及其操作的封装体，实例关系和继承关系是对象之间的静态关系，消息传递是对象之间动态联系的唯一形式，方法是消息的序列。 封装封装的目的是将信息隐藏，封装包括封装数据、封装实现、封装类型和封装变化。 1.封装数据在传统的面向对象语言中，封装数据是由语法解析来实现的，传统的面向对象语言提供了privata、public、protected等关键字来提供不同的访问权限。 但JavaScript并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出public和private这两种封装性。 123456789101112var fengzhuang=(function()&#123; var __name__=&quot;张三&quot;; return &#123; getName:function()&#123; console.log(__name__); &#125;&#125;&#125;)();console.log(fengzhuang.getName()); //张三console.log(fengzhuang.__name__); //undefined 利用闭包，将变量的作用域封装起来，只有函数内部可以访问，外部不能访问。 2.封装实现封装的目的是将信息隐藏，封装应该被视为”任何形式的封装”，不应仅局限于数据层面的封装，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型。 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，对象对它自己的行为负责。其他对象或用户都不关心它的内部实现，封装使得对象之间的耦合变松散，对象之间只通过暴露的API接口来通信。当我们修改一个对象的时候，可以随意修改它的内部实现，只要对外的接口没有变化，就不会影响程序的其他功能。 3.封装类型封装类型是静态类型语言中的一种重要的封装方式，因为JavaScript本身就是动态类型语言，根本没必要封装类型。 4.封装变化封装在更重要的层面体现为封装变化。 “考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情下进行改变。这里的关键在于封装发生变化的概念。” 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"多态","slug":"多态","date":"2018-05-08T11:10:56.000Z","updated":"2018-10-12T14:48:55.798Z","comments":true,"path":"2018/05/08/多态/","link":"","permalink":"http://yoursite.com/2018/05/08/多态/","excerpt":"","text":"面向对象是一种对现实世界理解和抽象的方法，系统中一切事物皆对象，对象是属性及其操作的封装体，实例关系和继承关系是对象之间的静态关系，消息传递是对象之间动态联系的唯一形式，方法是消息的序列。 多态多态的含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。也就是说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 举例： 主人家里养了两只动物，分别是一只鸭和一只鸡，当主人向它们发出”叫”的命令时，鸭会”嘎嘎嘎”地叫，而鸡会”咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样”都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。 1.一段&quot;多态&quot;的JavaScript代码123456789101112131415function makeSound(animal)&#123;if(animal instanceof Duck)&#123; console.log(&quot;嘎嘎嘎&quot;); &#125;else&#123; console.log(&quot;咯咯咯&quot;); &#125;&#125;function Duck()&#123; &#125;function Chicken()&#123;&#125;var duck=new Duck();var chicken=new Chicken();makeSound(duck);//嘎嘎嘎makeSound(chicken);//咯咯咯 上述代码确实体现了&quot;多态性&quot;，当我们分别向鸭和鸡发出&quot;叫&quot;的命令时，它们根据此消息作出了各自不同的反应，但这样的&quot;多态性&quot;是无法令人满意的，如果后来又增加一个动物，比如狗的叫声是&quot;汪汪汪&quot;，我们唯一的办法是改动makeSound函数，修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，mackSound有可能变成一个超级恶心的函数。 多态的思想是要将&quot;不变的事务&quot;与&quot;可能改变的事务&quot;分离开来。 动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给与了我们扩展程序的能力。 2.对象的多态性首先我们把不变的部分隔离出来，所有的动物都会叫。 123function makeSound(animal)&#123; animal.sound();&#125; 然后把可变的部分封装起来，多态性实际上是指对象的多态性。 1234567891011121314151617function Duck()&#123;&#125;Duck.prototype.sound=function()&#123; console.log(&quot;嘎嘎嘎&quot;);&#125;function Chicken()&#123;&#125;Chicken.prototype.sound=function()&#123; console.log(&quot;咯咯咯&quot;);&#125;var duck=new Duck();var chicken=new Chicken();makeSound(duck);//嘎嘎嘎makeSound(chicken);//咯咯咯 现在，当我们分别向鸭和鸡发出&quot;叫&quot;的命令时，它们根据此消息作出了各自不同的反应。现在我们可以方便的添加新的对象，而不用去改变makeSound()函数。 1234567function Dog()&#123;&#125;Dog.prototype.sound=function()&#123; console.log(&quot;汪汪汪&quot;);&#125;var dog=new Dog()makeSound(dog);//咯咯咯 3.类型检查和多态JavaScript的变量类型在运行期是可变的，一个JavaScript对象，即可以表示Duck类型的对象，又可以表示Chicken类型的对象，这意味着JavaScript对象的多态性是与生俱来的。 这种与生俱来的多态性并不难理解，JavaScript作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，也没有检查传递的参数类型。所以我们既可以往makeSound函数里传递duck对象当做参数，也可以传递chicken对象当做参数。 在JavaScript中，我们判断某一种动物能否发出叫声，只取决于它有没有makeSound方法，而不取决于它是某种类型的对象，这正是鸭子类型的思想。 4.多态的作用Martin Fowler在《重构:改善既有代码的设计》里提到： 多态的最根本好处在于，你不必再向对象询问”你是什么类型”而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 也就是说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 Martin Fowler关于多态有一段很经典的话。 在电影的拍摄现场，当导演喊出”action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。 利用对象的多态性，导演在发布消息时，就不必考虑各个对象接收到消息后应该做什么，对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安排在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。 多态的特点：将行为分步在各个对象中，并让这些对象各自负责自己的行为。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"动态类型语言和鸭子类型","slug":"动态类型语言和鸭子类型","date":"2018-05-07T04:10:30.000Z","updated":"2018-10-12T14:46:22.374Z","comments":true,"path":"2018/05/07/动态类型语言和鸭子类型/","link":"","permalink":"http://yoursite.com/2018/05/07/动态类型语言和鸭子类型/","excerpt":"","text":"JavaScript没有提供传统面向对象语言中的类式继承，而是通过prototype原型委托的方式来实现对象与对象之间的继承。JavaScript也没有在语言层面提供对抽象类和接口的支持。那JavaScript是怎么实现面向对象的机制，我们十分有必要的了解一下。 1.动态类型语言1.1.动态类型语言的特点 1.动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 2.动态类型语言的优点是编写的代码数量更少，看起来更加简洁，程序员可以把精力更多地放在业务逻辑上面。 3.动态类型语言的缺点是无法保证变量的类型从而在程序的运行期有可能发生跟类型相关的错误。这好像在商店里买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味 4.动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性，由于无需进行类型检测， 我们可以尝试调用任何对象的任意方法，，而无需去考虑它原本是否被设计为拥有该方法。 5.在JavaScript中当我们对一个变量赋值时，显然不需要考虑它的类型，因此JavaScript是典型的动态类型语言。 1.2.静态类型语言的特点 1、静态类型语言在编译时便已确定变量的类型 2、静态类型语言的优点是在编译时就能发现类型不匹配的错误，编译器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器可以针对这些信息对程序进行一些优化工作。 3、静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段而不是编写程序的目的。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的经理从思考业务逻辑上分散开来。 2.鸭子类型鸭子类型的通俗说法：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。 从前在JavaScript王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全全国，终于找到999只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。 这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为而不关注对象本身也就是关注HAS-A而不是IS-A。 12345678910111213141516171819202122var duck=&#123; //鸭子对象 duckSinging:function()&#123; console.log(&quot;嘎嘎嘎&quot;); &#125;&#125;var chicken=&#123; //鸡对象 duckSinging:function()&#123; consol.log(&quot;嘎嘎嘎&quot;); &#125;&#125;var choir=[];function joinchoir(animal)&#123; if(typeof animal.duckSinging===&quot;function&quot;)&#123; choir.push(animal); console.log(&quot;欢迎加入合唱团&quot;); console.log(&quot;合唱团已有成员数量&quot;+choir.length); &#125;&#125;joinchoir(duck); //欢迎加入合唱团 合唱团已有成员数量1joinchoir(chicken); //欢迎加入合唱团 合唱团已有成员数量2 对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有duckSinging方法。 在动态类型语言中，利用鸭子类型的思想，我们很容易实现&quot;面向接口编程，而不是面向实现编程&quot; 一个对象如果有push和pop方法，并且这些方法提供了正确的实现，它就可以被当做栈来使用。 一个对象如果有length属性，也可以按照下标存取属性，最好还有slice和splice等方法，这个对象就可以被当做数组来使用。 3.补充知识：HAS-A和IS-A传统的面向对象是这样描述IS-A和HAS-A原则的： public继承是一个接口继承，保持is-a原则，每个父类可用的成员对子类也可用，因为每个子类对象也都是一个父类对象。 protetced/private继承是一个实现继承，基类的部分成员并非完全成为子类接口的一部分，是has-a 的关系原则。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-基于库的继承","slug":"xbObjects","date":"2018-05-06T08:01:30.000Z","updated":"2018-10-12T14:04:50.030Z","comments":true,"path":"2018/05/06/xbObjects/","link":"","permalink":"http://yoursite.com/2018/05/06/xbObjects/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228/* * $Id: xbObjects.js,v 1.8 2003/09/14 21:22:26 bc Exp $ * *//* ***** BEGIN LICENSE BLOCK ***** * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an &quot;AS IS&quot; basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * Software distributed under the License is distributed on an &quot;AS IS&quot; basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Bob Clary code. * * The Initial Developer of the Original Code is * Bob Clary. * Portions created by the Initial Developer are Copyright (C) 2000 * the Initial Developer. All Rights Reserved. * * Contributor(s): Bob Clary &lt;http://bclary.com/&gt; * * Alternatively, the contents of this file may be used under the terms of * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;), * in which case the provisions of the GPL or the LGPL are applicable instead * of those above. If you wish to allow use of your version of this file only * under the terms of either the GPL or the LGPL, and not to allow others to * use your version of this file under the terms of the MPL, indicate your * decision by deleting the provisions above and replace them with the notice * and other provisions required by the GPL or the LGPL. If you do not delete * the provisions above, a recipient may use your version of this file under * the terms of any one of the MPL, the GPL or the LGPL. * ***** END LICENSE BLOCK ***** */function _Classes()&#123; if (typeof(_classes) != &apos;undefined&apos;) throw(&apos;Only one instance of _Classes() can be created&apos;); function registerClass(className, parentClassName) &#123; if (!className) throw(&apos;xbObjects.js:_Classes::registerClass: className missing&apos;); if (className in _classes) return; if (className != &apos;xbObject&apos; &amp;&amp; !parentClassName) parentClassName = &apos;xbObject&apos;; if (!parentClassName) parentClassName = null; else if ( !(parentClassName in _classes)) throw(&apos;xbObjects.js:_Classes::registerClass: parentClassName &apos; + parentClassName + &apos; not defined&apos;); // evaluating and caching the prototype object in registerClass // works so long as we are dealing with &apos;normal&apos; source files // where functions are created in the global context and then // statements executed. when evaling code blocks as in xbCOM, // this no longer works and we need to defer the prototype caching // to the defineClass method _classes[className] = &#123; &apos;classConstructor&apos;: null, &apos;parentClassName&apos;: parentClassName &#125;; &#125; _Classes.prototype.registerClass = registerClass; function defineClass(className, prototype_func) &#123; var p; if (!className) throw(&apos;xbObjects.js:_Classes::defineClass: className not given&apos;); var classRef = _classes[className]; if (!classRef) throw(&apos;xbObjects.js:_Classes::defineClass: className &apos; + className + &apos; not registered&apos;); if (classRef.classConstructor) return; classRef.classConstructor = eval( className ); var childPrototype = classRef.classConstructor.prototype; var parentClassName = classRef.parentClassName; if (parentClassName) &#123; var parentClassRef = _classes[parentClassName]; if (!parentClassRef) throw(&apos;xbObjects.js:_Classes::defineClass: parentClassName &apos; + parentClassName + &apos; not registered&apos;); if (!parentClassRef.classConstructor) &#123; // force parent&apos;s prototype to be created by creating a dummy instance // note constructor must handle &apos;default&apos; constructor case var dummy; eval(&apos;dummy = new &apos; + parentClassName + &apos;();&apos;); &#125; var parentPrototype = parentClassRef.classConstructor.prototype; for (p in parentPrototype) &#123; switch (p) &#123; case &apos;isa&apos;: case &apos;classRef&apos;: case &apos;parentPrototype&apos;: case &apos;parentConstructor&apos;: case &apos;inheritedFrom&apos;: break; default: childPrototype[p] = parentPrototype[p]; break; &#125; &#125; &#125; prototype_func(); childPrototype.isa = className; childPrototype.classRef = classRef; // cache method implementor info childPrototype.inheritedFrom = new Object(); if (parentClassName) &#123; for (p in parentPrototype) &#123; switch (p) &#123; case &apos;isa&apos;: case &apos;classRef&apos;: case &apos;parentPrototype&apos;: case &apos;parentConstructor&apos;: case &apos;inheritedFrom&apos;: break; default: if (childPrototype[p] == parentPrototype[p] &amp;&amp; parentPrototype.inheritedFrom[p]) &#123; childPrototype.inheritedFrom[p] = parentPrototype.inheritedFrom[p]; &#125; else &#123; childPrototype.inheritedFrom[p] = parentClassName; &#125; break; &#125; &#125; &#125; &#125; _Classes.prototype.defineClass = defineClass;&#125;// create global instancevar _classes = new _Classes();// register root class xbObject_classes.registerClass(&apos;xbObject&apos;);function xbObject()&#123; _classes.defineClass(&apos;xbObject&apos;, _prototype_func); this.init(); function _prototype_func() &#123; // isa is set by defineClass() to the className // Note that this can change dynamically as the class is cast // into it&apos;s ancestors... xbObject.prototype.isa = null; // classref is set by defineClass() to point to the // _classes entry for this class. This allows access // the original _class&apos;s entry no matter how it has // been recast. // *** This will never change!!!! *** xbObject.prototype.classRef = null; xbObject.prototype.inheritedFrom = new Object(); function init() &#123; &#125; xbObject.prototype.init = init; function destroy() &#123;&#125; xbObject.prototype.destroy = destroy; function parentMethod(method, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) &#123; // find who implemented this method var className = this.isa; var parentClassName = _classes[className].classConstructor.prototype.inheritedFrom[method]; var tempMethod = _classes[parentClassName].classConstructor.prototype[method]; // &apos;cast&apos; this into the implementor of the method // so that if parentMethod is called by the parent&apos;s method, // the search for it&apos;s implementor will start there and not // cause infinite recursion this.isa = parentClassName; var retVal = tempMethod.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10); this.isa = className; return retVal; &#125; xbObject.prototype.parentMethod = parentMethod; function isInstanceOf(otherClassConstructor) &#123; var className = this.isa; var otherClassName = otherClassConstructor.prototype.isa; while (className) &#123; if (className == otherClassName) return true; className = _classes[className].parentClassName; &#125; return false; &#125; xbObject.prototype.isInstanceOf = isInstanceOf; &#125;&#125;// eof: xbObjects.js//&lt;/SCRIPT&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"4-基于库的继承","slug":"4-基于库的继承","date":"2018-05-06T08:00:30.000Z","updated":"2018-10-12T14:47:53.956Z","comments":true,"path":"2018/05/06/4-基于库的继承/","link":"","permalink":"http://yoursite.com/2018/05/06/4-基于库的继承/","excerpt":"","text":"原型链的继承方式实际上是把对象的所有方法给只给类的prototype对象，我们可以利用zInherit库实现继承，不必使用原型链，这个库支持所有的现代浏览器以及比较旧版本的浏览器，我们可以看一下这个库是怎么样使用的。 1.zInherit库下载地址：找了半天没有找个zInherit库的下载地址，好心塞牙，以后有机会碰到的话，在添加吧。 zInherit库给Object类添加了两个方法：inheritFrom()方法和instanceof()方法 inheritFrom()方法:负责复制指定对象的所有方法。 举例： 123B.prototype=new A();可替换成B.prototype.inheritFrom(A); inheritFrom()方法接受一个参数，也就是要复制的方法所属的类，与原型链相对的是，这种方法并未真正创建要继承的类的实例，所以比较安全。 instanceof()方法和instanceof运算符的效果是相同的，不过在该库中不需要使用原型链，所以instanceof运算符根本就检测不出来什么，因此封装了instanceof()方法。 123b instanceof A //true 等价于 b instanceof(A) //true 1.1.混合的对象冒充和原型方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Polygon(iside)&#123; this.sides=iside;&#125;Polygon.prototype.getArea=function()&#123; return 0;&#125;function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125;Triangle.prototype.inheritFrom(Polygon);Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height;&#125;function Rectangle(iside,iwidth,iheight)&#123; Polygon.call(this,iside); this.width=iwidth; this.height=iheight;&#125;Rectangle.prototype=inheritFrom(Polygon);Rectangle.prototype.getArea=function()&#123; return this.width*this.height;&#125;var triangle=new Triangle(3,4,5);var rectangle=new Rectangle(4,4,5);console.log(triangle.sides); //3console.log(triangle.base); //4console.log(triangle.height); //5console.log(triangle.getArea()); //10console.log(rectangle.sides); //4console.log(rectangle.width); //4console.log(rectangle.height); //5console.log(rectangle.getArea());//20console.log(triangle.instanceof(Triangle));//trueconsole.log(triangle.instanceof(Polygon));//trueconsole.log(rectangle.instanceof(Rectangle));//trueconsole.log(rectangle.instanceof(Polygon));//true 1.2.动态原型支持原型链不能满足动态原型主旨，也就是说把类的所有代码放置在它的构造函数中，zInherit库修正了这个问题，它允许在构造函数内部调用inheritForm()方法。 12345678910111213141516171819202122232425262728293031323334353637function Polygon(iside)&#123; this.sides=iside; if(typeof Polygon._initialized==&quot;undefined&quot;)&#123; Polygon.prototype.gerArea=function()&#123; //属性指向函数 return 0; &#125;; Polygon._initialized=true; &#125;&#125;//三角形类function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125; if(typeof Triangle._initialized==&quot;undefined&quot;)&#123; Triangle.prototype.inheritFrom(Polygon);; Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height; &#125; Triangle._initialized=true; &#125;&#125;//矩形类function Rectangle(iside,iwidth,iheight)&#123; Polygon.call(this,iside); this.width=iwidth; this.height=iheight;&#125; if(typeof Rectangle._initialized==&quot;undefined&quot;)&#123; Rectangle.prototype.inheritFrom(Polygon);; Rectangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height; &#125; Rectangle._initialized=true; &#125;&#125; 1.3.多重继承支持zInherit库最有用的特性之一是支持多重继承，原型链不支持这种能力，使这种支持成为可能的关键是inheritFromForm()方法不替换prototype对象。 多重继承示例图： 12345678910111213141516171819202122232425262728293031323334function classX()&#123;this.messagex=&quot;我是classX&quot;; if(typeof classX._initialized==&quot;undefined&quot;)&#123; classX.prototype.showmessagex=function()&#123; console.log(this.messagex); &#125; classX._initialized=true; &#125;&#125;function classY()&#123;this.messagey=&quot;我是classY&quot;; if(typeof classY._initialized==&quot;undefined&quot;)&#123; classY.prototype.showmessagey=function()&#123; console.log(this.messagey); &#125; classY._initialized=true; &#125;&#125;function classZ()&#123; classX.call(this); classY.call(this); this.messagez=&quot;我是classZ&quot;; if(typeof classZ._initialized==&quot;undefined&quot;)&#123; classZ.prototype.inheritFrom(classX); classZ.prototype.inheritFrom(classY); classX.prototype.showmessagez=function()&#123; console.log(this.messagez); &#125; classZ._initialized=true; &#125;&#125; 发生继承的顺序是非常重要的，通常按照继承属性的顺序继承方法比较好，也就是说如果先继承classX的属性，然后继承classY的属性，那么也应该按照这种继承顺序继承它们的方法。 1234var z=new classZ();console.log(z.showshowmessagex()); //我是classXconsole.log(z.showshowmessagey()); //我是classYconsole.log(z.showshowmessagez()); //我是classZ 说明： showshowmessagex()方法是从classX继承而来的，它访问messagex属性，该属性也是从classX继承而来的。 showshowmessagey()方法是从classY继承而来的，它访问messagey属性，该属性也是从classY继承而来的。 showshowmessagez()方法是从classZ继承而来的，它访问messagez属性，该属性也是从classZ继承而来的。 2.xbObjects库2.1.目的xbObjects库为JavaScript提供更强的面向对象泛型，不只支持继承，还支持方法的重载和调用超类方法的能力。 2.1.第一步：注册类需要定义它是由哪个类继承而来的 _classes.registerClass(&quot;Subclass_Name&quot;,&quot;Superclsss_Name&quot;); 子类和父类都以字符串形式传进来，而不是指向它们的构造函数的指针，这个调用必须放在指定子类的构造函数前。 如果新的类未继承任何类，调用registerClass()时也可以只用第一个参数。 2.2.第二步：defineClass()在构造函数内调用defineClass()方法，传给它类名和原型函数的指针，该函数用于初始化对象的所有属性和方法。 12345678_classes.registerClass(&quot;A&quot;);function A(name)&#123; _class.defineClass(&quot;A&quot;,prototypeFunction); function prototypeFunction()&#123; // &#125;&#125; 原型函数prototypeFunction()位于构造函数内部，它的主要用途是在适当的时候把所有方法赋予该类，这一点上与动态原型相似。 2.3.第三步：init()方法创建init()方法，该方法负责该类的所有属性，它必须接受与构造函数相同的参数。作为一种规约，init()方法总是在defineClaaa()方法后调用。 1234567891011_classes.registerClass(&quot;A&quot;);function A(name)&#123; _class.defineClass(&quot;A&quot;,prototypeFunction); this.init(name); function prototypeFunction()&#123; A.prototype.init=function()&#123; this.parentMethod(&quot;init&quot;); this.name=name; &#125; &#125;&#125; parentMethod()方法接受任意多的参数，但是第一个参数总是要调用的类方法的名字(该参数必须是字符串，而不是函数指针)，所有其他参数都是传给父类的方法。 2.4.第四步：添加方法在原型函数内添加其他类的方法 1234567891011121314_classes.registerClass(&quot;A&quot;);function A(name)&#123; _classes.defineClass(&quot;A&quot;,prototypeFunction); this.init(name); function prototypeFunction()&#123; A.prototype.init=function()&#123; this.parentMethod(&quot;init&quot;); this.name=name; &#125; A.prototype.showname=function()&#123; console.log(this.name); &#125; &#125;&#125; 测试： 12var a=new A(&quot;red&quot;);console.log(a.showname()); 2.5.重载多边形2.5.1.Polygon类1234567891011121314151617_classes.registerClass(&quot;Polygon&quot;);function Polygon(sides)&#123; _classes.defineClass(&quot;Polygon&quot;,prototypeFunction); this.init(sides); function prototypeFunction()&#123; Polygon.prototype.init=function(iside)&#123; this.parentMethod(&quot;init&quot;); this.sides=iside; &#125; Polygon.prototype.getArea=function()&#123; return 0; &#125; &#125;&#125; 2.5.2.Triangle类12345678910111213141516171819_classes.registerClass(&quot;Triangle&quot;,&quot;Polygon&quot;);function Triangle(sides,base,height)&#123; _classes.defineClass(&quot;Triangle&quot;,prototypeFunction); this.init(sides,base,height); function prototypeFunction()&#123; Triangle.prototype.init=function(iside,ibase,iheight)&#123; this.parentMethod(&quot;init&quot;); this.sides=iside; this.base=ibase; this.height=iheight; &#125; Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height; &#125; &#125;&#125; 2.5.3.Rectangle类12345678910111213141516171819_classes.registerClass(&quot;Rectangle&quot;,&quot;Polygon&quot;);function Rectangle(sides,width,height)&#123; _classes.defineClass(&quot;Rectangle&quot;,prototypeFunction); this.init(sides,width,height); function prototypeFunction()&#123; Rectangle.prototype.init=function(iside,iwidth,iheight)&#123; this.parentMethod(&quot;init&quot;); this.sides=iside; this.width=iwidth; this.height=iheight; &#125; Rectangle.prototype.getArea=function()&#123; return this.width*this.height; &#125; &#125;&#125; 2.5.4.测试123456789101112var triangle=new Triangle(3,4,5);var rectangle=new Rectangle(4,4,5);console.log(triangle.sides); //3console.log(triangle.base); //4console.log(triangle.height); //5console.log(triangle.getArea()); //10console.log(rectangle.sides); //4console.log(rectangle.width); //4console.log(rectangle.height); //5console.log(rectangle.getArea());//20","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-继承实例","slug":"4-继承实例","date":"2018-05-05T07:05:30.000Z","updated":"2018-10-12T14:47:49.535Z","comments":true,"path":"2018/05/05/4-继承实例/","link":"","permalink":"http://yoursite.com/2018/05/05/4-继承实例/","excerpt":"","text":"继承机制实例关于继承，我们就拿多边形来说明问题吧，三角形、矩形、都是多边形的子类，多边形是它们的超类。 1.确定基类考虑Polygon(多边形)类，应该有哪些属性和方法？ 首先一定要知道多边形的边数，然后需要计算多变形的面积，该类的UML图如下。 Polygon类： 1234567function Polygon(iside)&#123; this.sidesw=iside;&#125;Polygon.prototype.getArea=function()&#123; return 0;&#125; 2.创建子类2.1.Triangle(三角形)类三角形有三条边，因此这个类必须覆盖Polygon类的sides属性，把它设置为3，还需要覆盖getArea()方法，使用三角形的面积公式1/2*底*高，如何得到底和高的值？需要专门输入这两个值，所以必须创建base属性和height属性，该类的UML图如下。 该图只展示了Triangle(三角形)类的新属性及覆盖过的方法，Triangle类没有覆盖的属性和方法，它将被看做从Polygon类保留下来的属性和方法。 在UML中，绝对不会重复显示继承的属性和方法，除非该方法被覆盖或被重载。 Triangle类： 12345678910function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125;Triangle.prototype=new Polygon();Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height;&#125; 在用原型链继承方法之后，Triangle类将覆盖getArea()方法，提供为三角形面积定制的计算。 2.2.Rectangle(矩形)类矩阵有四条边，面积是用长度*宽度计算，长度和宽度成为该类必须的属性，该类的UML图如下。 我们是应该把子类和超类组合起来的。 Rectangle类： 1234567891011function Rectangle(iside,iwidth,iheight)&#123; Polygon.call(this,iside); this.width=iwidth; this.height=iheight;&#125;Rectangle.prototype=new Polygon();Rectangle.prototype.getArea=function()&#123; return this.width*this.height;&#125; 3.测试代码123456789101112var triangle=new Triangle(3,4,5);var rectangle=new Rectangle(4,4,5);console.log(triangle.sides); //3console.log(triangle.base); //4console.log(triangle.height); //5console.log(triangle.getArea()); //10console.log(rectangle.sides); //4console.log(rectangle.width); //4console.log(rectangle.height); //5console.log(rectangle.getArea());//20 4.一波完整的代码123456789101112131415161718192021222324252627282930313233343536373839404142function Polygon(iside)&#123; this.sides=iside;&#125;Polygon.prototype.getArea=function()&#123; return 0;&#125;function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125;Triangle.prototype=new Polygon();Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height;&#125;function Rectangle(iside,iwidth,iheight)&#123; Polygon.call(this,iside); this.width=iwidth; this.height=iheight;&#125;Rectangle.prototype=new Polygon();Rectangle.prototype.getArea=function()&#123; return this.width*this.height;&#125;var triangle=new Triangle(3,4,5);var rectangle=new Rectangle(4,4,5);console.log(triangle.sides); //3console.log(triangle.base); //4console.log(triangle.height); //5console.log(triangle.getArea()); //10console.log(rectangle.sides); //4console.log(rectangle.width); //4console.log(rectangle.height); //5console.log(rectangle.getArea());//20 5.引发的思考可不可以采用动态原型方法实现继承？ 答案：不能，因为prototype对象的唯一性。 1234567891011121314151617181920212223function Polygon(iside)&#123; this.sides=iside; if(typeof Polygon._initialized==&quot;undefined&quot;)&#123; Polygon.prototype.gerArea=function()&#123; //属性指向函数 return 0; &#125;; Polygon._initialized=true; &#125;&#125;//三角形类function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125; if(typeof Triangle._initialized==&quot;undefined&quot;)&#123; Triangle.prototype=new Polygon(); Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height; &#125; Triangle._initialized=true; &#125;&#125; 上述代码用动态原型的方式定义了Polygon类和Triangle类，错误在于&quot;Triangle.prototype=new Polygon();&quot;从逻辑上讲，这个位置是正确的，但从功能上讲，却是无效的。从技术上来说，在代码运行前，对象已经被实例化，并与原始的prototype对象联系在一起了。虽然用极晚绑定可使对原型对象的修改正确地反映出来，但替换prototype对象却不会对该对象产生任何影响，只有未来的对象实例才会反映出这种改变，这就使第一个实例变得不正确。 要正确的使用动态原型实现继承机制，必须在构造函数外赋予新的prototype对象。 12345678910111213function Triangle(iside,ibase,iheight)&#123; Polygon.call(this,iside); this.base=ibase; this.height=iheight;&#125; if(typeof Triangle._initialized==&quot;undefined&quot;)&#123; Triangle.prototype.getArea=function()&#123; return 0.5*this.base*this.height; &#125; Triangle._initialized=true; &#125;&#125;Triangle.prototype=new Polygon(); 这段代码是有效，因为是在任何对象实例化前给prototype对象赋值的，但是，这意味着不能把这段代码完整的封装在构造函数中了。 6.补充知识：极晚绑定从技术上说根本不存在极晚绑定，只是描述在ECMAScript中存在的一种现象：能够在对象实例化后再定义它的方法。 举例： 123456var obj=new Object();Object.prototype.hello=function()&#123; console.log(&quot;hello&quot;);&#125;obj.hello(); 在大多数程序设计语言中，必须在实例化对象之前定义对象的方法，在上述代码中，方法hello()是在创建object类的一各实例后才添加进来的，这就叫做极晚绑定。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"4-继承的实现","slug":"4-继承机制的实现","date":"2018-05-04T02:20:32.000Z","updated":"2018-10-12T14:47:51.774Z","comments":true,"path":"2018/05/04/4-继承机制的实现/","link":"","permalink":"http://yoursite.com/2018/05/04/4-继承机制的实现/","excerpt":"","text":"真正的面向对象语言必须必须支持继承机制，所谓的继承就是一个类能够重用(继承)另一个类的方法和属性。JavaScript中是怎么实现继承的呢？ 继承1.继承机制的实现要用ECMAScript实现继承机制，我们首先要知道什么是基类？ 基类：所有自定义的类都可以作为基类，出于安全考虑，本地类和宿主者不能作为基类，这样可以防止公用访问编辑过的浏览器级的代码。 选定基类后，就可以创建它的子类了，是否使用基类就完全由你决定了，你也可以创建一个不能直接使用的基类，它只是用于给子类提供通用的函数，在这种情况下，基类被看做抽象类。 创建的子类将继承父类的所有属性和方法，包括构造函数及方法的实现。所有属性和方法都是公用的，子类可直接访问这些方法。子类还可以添加超类中没有的新属性和方法，也可以覆盖超类中的属性和方法。 2.继承的方法2.1.对象的冒充构造原始的ECMAScript时，根本没打算设计对象冒充，它是在开发者开始理解函数的工作方式，尤其是如何在函数环境中使用this关键字后才发展而来的。 原理：构造函数使用this关键字给所有属性和方法赋值，因为构造函数只是一个函数，所以可以把构造函数当成参数传递给另外一个函数，然后调用它，这样另外一个函数就有了该构造函数中定义的属性和方法。 12345678910function A(name)&#123; this.name=name; this.showname=function()&#123; console.log(this.name) &#125;&#125;function B()&#123;&#125; 关键this的指向总是构造函数当前创建的对象，在该方法中，this指向的是所属的对象。这个原理是把基类(函数A())作为常规函数来建立继承机制，而不是作为构造函数。 1234567891011function A(name)&#123; this.name=name; this.showname=function()&#123; console.log(this.name); &#125;&#125;function B(name)&#123; this.newextend= A; this.newextend(name); delete this.newextend;&#125; 上述代码中，为函数B()赋予了方法newextend(函数名只是指向它的指针)，然后调用该方法，给它传递参数name，最后删除对函数A()的引用，这样以后就不能再调用它。 所有新属性和新方法都必须在删除了对基函数的引用之后定义，不然会覆盖超类的相关属性和方法。 123456789101112131415function A(name)&#123; this.name=name; this.showname=function()&#123; console.log(this.name); &#125;&#125;function B(name,age)&#123; this.newextend=A; this.newextend(name); delete this.newextend; this.age=age; this.showage=function()&#123; console.log(this.age); &#125;&#125; 我们需要测试一下，这样的继承方式是不是有效的。 12345var a=new A(&quot;张三&quot;);var b=new B(&quot;李四&quot;,&quot;20&quot;);console.log(a.showname()); //张三console.log(b.showname()); //李四console.log(b.showage()); //20 对象冒充可以支持多重继承，是不是很惊喜，很意外。 123456789function ClassZ()&#123; this.newextend=ClassX; this.newextend(); delete this.newextend; this.newextend=ClassY; this.newextend(); delete this.newextend;&#125; 缺点：如果ClassX和ClassY具有同名的属性和方法，ClassY具有高优先级。 2.2.call()方法call()方法与对象冒充机制十分类似，它的第一个参数用作this的对象，其他参数都直接传递给函数自身。 1234567function showcolor(before,after)&#123; console.log(before+this.color+after);&#125;var obj=new Object();obj.color=&quot;pink&quot;;showcolor.call(obj,&quot;颜色是&quot;,&quot;,非常漂亮&quot;); //颜色是pink,非常漂亮 上述函数中，函数showcolor()在对象外定义，它不属于任何对象，this的指向是window。所以调用call()方法，改变该函数的this指向，第一个参数是obj,所以this指向obj对象。第二个参数和第三个参数与showcolor()函数中的参数before和after匹配。 call()方法与对象冒充方式结合使用 123456789101112131415161718function A(name)&#123; this.name=name; this.showname=function()&#123; console.log(this.name); &#125;&#125;function B(name,age)&#123; A.call(this,name); this.age=age; this.showage=function()&#123; console.log(this.age); &#125;&#125;var a=new A(&quot;张三&quot;);var b=new B(&quot;李四&quot;,&quot;20&quot;);console.log(a.showname()); //张三console.log(b.showname()); //李四console.log(b.showage()); //20 2.3.apply()方法apply()方法和call()方法的效果是相同的，都是改变this的指向，唯一的不同就是参数的形式不同。 12345678function showcolor(before,after)&#123; console.log(before+this.color+after); console.log(this);&#125;var obj=new Object();obj.color=&quot;pink&quot;;showcolor.apply(obj,[&quot;颜色是&quot;,&quot;,非常漂亮&quot;]); //颜色是pink,非常漂亮showcolor.apply(obj,new Array(&quot;颜色是&quot;,&quot;,非常漂亮&quot;)); //颜色是pink,非常漂亮 上述函数中，函数showcolor()在对象外定义，它不属于任何对象，this的指向是window。所以调用apply()方法，改变该函数的this指向，第一个参数是obj,所以this指向obj对象。第二个参数是由两个字符串构成的数组与showcolor()函数中的参数before和after匹配。 apply()方法与对象冒充方式结合使用 123456789101112131415161718function A(name)&#123; this.name=name; this.showname=function()&#123; console.log(this.name); &#125;&#125;function B(name,age)&#123; A.apply(this,[name]); this.age=age; this.showage=function()&#123; console.log(this.age); &#125;&#125;var a=new A(&quot;张三&quot;);var b=new B(&quot;李四&quot;,&quot;20&quot;);console.log(a.showname()); //张三console.log(b.showname()); //李四console.log(b.showage()); //20 2.4.原型链在ECMAScript中继承就是基于原型链实现的。 prototype对象是个模板，要实例化的对象都以这个模板为基础，这也就意味着，prototype对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。 1234567891011function A()&#123;&#125;A.prototype.name=&quot;张三&quot;;A.prototype.showname=function()&#123; console.log(this.name);&#125;function B()&#123;&#125;B.prototype=new A(); 原型链的神奇之处就在于B.prototype=new A(); 这行代码，把B的prototype属性设置成A的实例，这是十分有意义的，因为想要A()函数的所有属性和方法，但又不想将它们逐个赋予B的prototype属性，以整体的形式把A的实例设置成B的prototype属性，这是最好的方法了。 注意：我们可能发现，调用A()的构造函数时，没有给它传递参数，也没有必要给它传递参数，这在原型链中是标准做法，要确保构造函数没有任何参数。 与对象冒充的方式相似，子类的所有属性和方法都必须出现在prototype属性被赋值后，因为在它之前赋值的所有方法都会被删除。 原因：因为prototype属性被替换成了新对象，添加了新方法的原始对象将被销毁，不存在了。 1234567891011121314151617181920212223242526function A()&#123;&#125;A.prototype.name=&quot;张三&quot;;A.prototype.showname=function()&#123; console.log(this.name);&#125;function B()&#123;&#125;B.prototype=new A();B.prototype.age=20;B.prototype.showage=function()&#123; console.log(this.age);&#125;var a=new A();var b=new B();b.name=&quot;李四&quot;console.log(a.showname());//张三console.log(b.showname()); //李四console.log(b.showage());//20我们可以使用instanceOf运算符检查给定变量指向的对象的类型。console.log(b instanceof B) //trueconsole.log(a instanceof A) //trueconsole.log(b instanceof A) //true 2.5.混合的对象冒充和原型方式混合的对象冒充和原型方式指的是用对象冒充继承构造函数的属性，用原型链继承prototype对象的方法。 1234567891011121314151617181920function A(name)&#123; this.name=name;&#125;A.prototype.showname=function()&#123; console.log(this.name);&#125;function B(name,age)&#123; A.call(this,name); this.age=age;&#125;B.prototype=new A();B.prototype.showage=function()&#123; console.log(this.age);&#125;var a=new A(&quot;张三&quot;);var b=new B(&quot;李四&quot;,20);console.log(a.showname());//张三console.log(b.showname()); //李四console.log(b.showage());//20 在上述例子中，继承机制主要由下面两句代码实现 12A.call(this,name);B.prototype=new A(); 第一句：在B()构造函数中，用对象冒充继承A()类的name属性第二句：用原型链继承A()类的方法。 我们可以再次使用instanceOf运算符检查给定变量指向的对象的类型。 123console.log(b instanceof B) //trueconsole.log(a instanceof A) //trueconsole.log(b instanceof A) //true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-字符换的链接","slug":"3-字符串的连接","date":"2018-04-30T10:18:45.000Z","updated":"2018-10-12T14:48:01.452Z","comments":true,"path":"2018/04/30/3-字符串的连接/","link":"","permalink":"http://yoursite.com/2018/04/30/3-字符串的连接/","excerpt":"","text":"字符串链接性能问题1.第一种方式：利用运算符&quot;+&quot;12345var str=&quot;hello&quot;;str=str+&quot;world&quot;;console.log(str); //helloworld 执行的步骤： 1.创建存储”hello”的字符串 2.创建存储”world”的字符串 3.创建存储连接结果的字符串 4.把str的当前内容复制到结果中 5.把”world”复制到结果中 6.更新str，使它指向结果。 每次完成字符串连接都会执行步骤2~6，使得这种操作非常消耗资源，如果重复这一过程几百次，甚至几千次，就会造成性能问题。 2.第二种方式：join()方法12345var arr=new Array();arr[0]=&quot;a&quot;;arr[1]=&quot;b&quot;;var str=arr.join(&quot;&quot;);console.log(str); //ab 执行的步骤： 1、创建存储结果的字符串 2、把每个字符串复制到结果中的合适位置 3.第三种方式：StringBuffer类12345678910function StringBuffer()&#123; this.__string__=new Array();&#125;StringBuffer.prototype.append=function(str)&#123; this.__string__.push(str);&#125;StringBuffer.prototype.toString=function()&#123; return this.__string__.join(&quot;&quot;);&#125; string属性是私有属性，StringBuffer类有两个方法append()方法和toString()方法，append()方法有一个参数，它把该参数附加到字符串数组中，toString()方法调用数组的join()方法，返回真正连接成的字符串。我们可以测试一下。 123456789var str=new StringBuffer();str.append(&quot;hello&quot;);str.append(&quot;world&quot;);var result=str.toString();console.log(result); //helloworld 4.检测性能我们可以检测一下StringBuffer对象和传统的字符串连接方法的性能。 传统的连接方法： 123456789var d1=new Date();var time1=d1.getTime();var str=&quot;&quot;;for(var i=0;i&lt;10000;i++)&#123; str=str+&quot;hello&quot;;&#125;var d2=new Date();var time2=d2.getTime();console.log(&quot;程序运行的时长为&quot;+(time2-time1)+&quot;秒&quot;); //程序运行的时长为18秒 StringBuffer对象： 1234567891011121314151617181920function StringBuffer()&#123; this.__string__=new Array();&#125;StringBuffer.prototype.append=function(str)&#123; this.__string__.push(str);&#125;StringBuffer.prototype.toString=function()&#123; return this.__string__.join(&quot;&quot;);&#125;var str=new StringBuffer();var d1=new Date();var time1=d1.getTime();for(var i=0;i&lt;10000;i++)&#123; str.append(&quot;hello&quot;);&#125;var result=str.toString();var d2=new Date();var time2=d2.getTime();console.log(&quot;程序运行的时长为&quot;+(time2-time1)+&quot;秒&quot;); //程序运行的时长为7秒 注意：创建新Date对象时，如果没有参数，赋予对象的是当前的日期与时间。要计算连接操作历经多少时间，把日期的毫秒表示(getTime()方法的返回值)相减即可。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-修改对象","slug":"3-修改对象","date":"2018-04-27T09:17:57.000Z","updated":"2018-10-12T14:48:03.475Z","comments":true,"path":"2018/04/27/3-修改对象/","link":"","permalink":"http://yoursite.com/2018/04/27/3-修改对象/","excerpt":"","text":"修改对象1.创建新方法可用prototype属性为任何已有的类定义新方法。 举例： 1、Number类的toString()方法，如果给它传递一个基数16，它将输出十六进制的字符串。我们可以自定义一个输出十六进制的函数toHexString(). 123456Number.prototype.toHexString=function()&#123; console.log(this); //Number &#123;345&#125; return this.toString(16);&#125;var num=345;console.log(num.toHexString()); //159 这里的this指向Number的实例。 2、给Array类添加enqueue()方法和dequeue()方法 123456Array.prototype.enqueue=function(item)&#123; this.push(item);&#125;Array.prototype.dequeue=function()&#123; return this.shift();&#125; 3、判断某个项在数组中的位置。 12345678Array.indexOf=function(item)&#123; for(var i=0;i&lt;this.length;i++)&#123; if(item==this[i])&#123; return i; &#125; &#125; return -1;&#125; indexOf()方法：在数组中检索每个项,直到发现与传进来的项相等的项为止，如果找到相等的项，就返回该项的位置，否则返回-1. 123var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;];cosole.log(arr.indexOf(&quot;c&quot;)); //2 4、Object.prototype属性 如果想要给ECMAScript中的每个本地对象添加新方法，必须在Object对象的prototype属性上定义它。因为所有的本地对象都继承了Object对象，所以对Object对象做任何改变，都会反映在所有的本地对象中。 1234567Object.prototype.showvalue=function()&#123; console.log(this.valueOf());&#125;var str=&quot;deded&quot;;var num=123;console.log(str.showvalue()); //dededconsole.log(num.showvalue()); ///123 String和Number对象都从Object对象继承了showvalue()方法，分别在它们对象上调用该方法。 2.重定义已有方法我们既然能给已有的类定义新的方法，也可重定义已有的方法。 1、举例：修改Function类的toString()方法。 1234567Function.prototype.toString=function()&#123; return &quot;我是重新定义的方法&quot;;&#125;function hel()&#123; &#125;console.log(hel.toString()); //我是重新定义的方法 我们应该知道Function的toString()方法通常输出的是函数的源代码，但在上述代码中我们修改了toString()方法，让它返回其他的字符串值。 toString()方法的原始功能怎么办？我们就这么轻易地修改了….toString()指向的原始函数将被无用存储单元回收程序回收,完全被废弃了，没有能够恢复原始函数的办法，这样的做法是极其危险的。 解决办法:在覆盖原始方法之前，比较安全的做法是用变量存储它的指针，以方便以后的使用。 12345678910111213141516Function.prototype.newtoString=Function.prototype.toString;Function.prototype.toString=function()&#123; if(this.newtoString().length&gt;100)&#123; return &quot;该函数代码太长了&quot;; &#125;else&#123; return this.newtoString(); &#125;&#125;function hel()&#123; console.log(&quot;helloworld&quot;);&#125;console.log(hel.toString()); 把对当前的toString()方法的引用保存在属性newtoString中，然后新定义的toString()方法覆盖了原始的toString()方法的功能。新方法将检查该函数源代码的长度是否大于100，如果是，就返回提示信息该函数代码太长了，如果不是就返回函数的源代码。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-定义类和对象","slug":"3-定义类或对象","date":"2018-04-25T03:11:00.000Z","updated":"2018-10-12T14:48:08.173Z","comments":true,"path":"2018/04/25/3-定义类或对象/","link":"","permalink":"http://yoursite.com/2018/04/25/3-定义类或对象/","excerpt":"","text":"定义类或对象1.工厂方式一般情况下对象的属性在对象创建后定义。例如下面的代码： 1234567var car=new Object();car.color=&quot;red&quot;;car.doors=4;car.mpg=23;car.showcolor=function()&#123; console.log(this.color);&#125;; 在上述代码中，创建对象car,给它设置了几个属性：颜色、门、时速。最后一个属性实际上是指向函数的指针，意味着该属性是个方法，运行这段代码后，就可以使用对象car。问题是可能需要创建多个car实例。 要解决这个问题，开发者创造了能创建并返回特定类型的对象的工厂函数。 1234567891011121314function createcar()&#123; var car=new Object(); car.color=&quot;red&quot;; car.doors=4; car.mpg=23; car.showcolor=function()&#123; console.log(this.color); &#125;; return car;&#125;var car1=new createcar();var car2=new createcar();car1.showcolor() //redcar2.showcolor() //red 将对象car封装在函数createcar()中，并且返回car对象作为函数值。当调用此函数时，将创建新对象，并赋予它所有必要的属性，复制出一个car对象。使用该方法，可以很容易地创建car对象的两个版本(car1和car2)，它们的属性完全一样，就像是双胞胎。 我们还可以修改createcar()函数，给它传递各个属性的默认值，而不是赋予属性默认值。 123456789101112131415161718function createcar(icolor,idoor,impg)&#123; var car=new Object(); car.color=icolor; car.doors=idoor; car.mpg=impg; car.showcolor=function()&#123; console.log(this.color); &#125;; return car;&#125;var car1=new createcar(&quot;pink&quot;,4,25);var car2=new createcar(&quot;black&quot;,4,30);car1.showcolor() //pinkcar2.showcolor() //black 给createcar()函数加上参数，也就是为创建的car对象color、doors和mpg属性赋值，这使得car1对象和car2对象具有相同的属性，却有不同的属性值。 我们肯定发现了一个问题，每次调用createcar()函数时，都要创建新函数showcolor()，这意味着每个对象都有自己独立的showcolor()版本。但事实上，每个对象都共享了同一个函数showcolor()。 解决办法：在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避开这个问题。 12345678910111213141516171819function showcolor()&#123; console.log(this.color);&#125;function createcar(icolor,idoor,impg)&#123; var car=new Object(); car.color=icolor; car.doors=idoor; car.mpg=impg; car.showcolor=showcolor; return car;&#125;var car1=new createcar(&quot;pink&quot;,4,25);var car2=new createcar(&quot;black&quot;,4,30);car1.showcolor() //pinkcar2.showcolor() //black 在上述代码中，在函数crearcar()前定义了函数showcolor()。在crearcar()内部，赋予对象一个指向已经存在的showcolor()函数的指针。从功能上来说，这样解决了重复创建函数对象的问题，但showcolor()函数看起来不像对象的方法。这些一系列的问题引发了开发者定义的构造函数的出现。 2.构造函数方式12345678910111213141516function createcar(icolor,idoor,impg)&#123; this.color=icolor; this.doors=idoor; this.mpg=impg; this.showcolor=function showcolor()&#123; console.log(this.color); &#125;&#125;var car1=new createcar(&quot;pink&quot;,4,25);var car2=new createcar(&quot;black&quot;,4,30);car1.showcolor() //pinkcar2.showcolor() //black 观察上述代码，我们可以发现在构造函数内部没有创建对象，而是使用this关键字。 使用new运算符调用构造函数时，在执行第一行代码前先创建一个对象，只有用this才能访问该对象，然后可以直接赋予this属性，默认情况下是构造函数的返回值(不必明确使用return运算符)。 同工厂函数一样，构造函数会重复生成函数，为每个对象都创建独立的函数版本。同工厂函数相似，也可以用外部函数重写构造函数，但是这样做没有任何的意义，所以开发者又定义了原型方式。 3.原型方式12345678910111213141516171819function car()&#123;&#125;car.prototype.color=&quot;red&quot;;car.prototype.doors=4;car.prototype.mpg=23;car.prototype.showcolor=function()&#123; //属性指向函数 console.log(this.color);&#125;var car1=new car();var car2=new car();car1.showcolor(); //redcar2.showcolor(); //red 在上述代码中，首先定义构造函数car，然后通过给car的prototype属性添加属性去定义car对象的属性。调用new car()时，原型的所有属性都立即赋予要创建的对象，意味着所有car实例存放的都是指向showcolor()函数的指针。同时，所有属性看起来都属于一个对象，这就解决了工厂函数和构造函数存在着的最大的问题。 我们可以使用instanceOf运算符检查给定变量指向的对象的类型。 12console.log(car1 instanceof car) //trueconsole.log(car2 instanceof car) //true 这下感觉是不是很完美了呢？其实不尽然，还是有着诸多的缺点滴。 第一个缺点：这个构造函数是不能有参数的，也就是说通过原型方式创建对象时，不能通过给构造函数传递参数初始化属性的值，类似这种：var car1=new car(&quot;pink&quot;,4,25);，这意味着必须在对象创建后才能改变属性的默认值，这样也是很无奈了。 第二个缺点：当属性指向对象，而不是指向函数时会出现很大的问题。 一般来说，函数共享是ok的，不会造成任何问题，但对象却是很少被多个实例共享的。 12345678910111213141516171819202122function car()&#123;&#125;car.prototype.color=&quot;red&quot;;car.prototype.doors=4;car.prototype.mpg=23;car.prototype.drivers=new Array(&quot;张三&quot;,&quot;李四&quot;);car.prototype.showcolor=function()&#123; //属性指向函数 console.log(this.color);&#125;var car1=new car();var car2=new car();car1.drivers.push(&quot;王五&quot;);console.log(car1.drivers); //[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]console.log(car2.drivers); //[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;] 哎呀！！这就很尴尬了，我明明只给对象car1添加了内容，为什么对象car2也会有呢？这该作何解释呢？ 解释：属性drivers是指向Array对象的指针，该数组中包含两个名字&quot;张三&quot;和&quot;李四&quot;。由于drivers是引用值,car对象的两个实例car1和car2都指向同一个数组，这意味着给car1.drivers添加值&quot;王五&quot;，在car2.drivers中也能看到，输出这两个指针中的任何一个，结果都是显示字符串。为了解决这个问题，需要联合使用构造函数和原型方式。 4.混合的构造函数和原型方式混合的构造函数和原型方式指的是用构造函数定义对象的所有非函数属性，用原型方式定义对象函数属性。结果所有函数都只创建一次，而且每个对象都有自己的对象属性实例， 1234567891011121314151617181920212223function car(icolor,idoor,impg)&#123;this.color=icolor; this.doors=idoor; this.mpg=impg;this.drivers=new Array(&quot;张三&quot;,&quot;李四&quot;);&#125;car.prototype.showcolor=function()&#123; //属性指向函数 console.log(this.color);&#125;var car1=new car(&quot;pink&quot;,4,25);var car2=new car(&quot;black&quot;,4,30);console.log(car1.showcolor()) //pinkconsole.log(car2.showcolor()) //blackcar1.drivers.push(&quot;王五&quot;);console.log(car1.drivers); //[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]console.log(car2.drivers); //[&quot;张三&quot;, &quot;李四&quot;] 上述代码中，所有的非函数属性都在构造函数中创建，意味着可以用构造函数的参数赋予属性默认值。并且只创建showcolor()函数的一个实例，没有内存浪费。从结果中我们可以看出对象car1改变数组得drivers的值并不会影响对象car2数组的drivers的值。 我们可以使用instanceOf运算符检查给定变量指向的对象的类型。 12console.log(car1 instanceof car) //trueconsole.log(car2 instanceof car) //true 混合的构造函数和原型方式创建对象，算是一种比较完美的方式了。 5.动态原型方法动态原型方法的基本思想与混合的构造函数和原型方式相同，在构造函数定义对象的所有非函数属性，用原型方式定义对象函数属性。唯一的区别就是赋予对象方法的位置。 123456789101112function car(icolor,idoor,impg)&#123;this.color=icolor; this.doors=idoor; this.mpg=impg;this.drivers=new Array(&quot;张三&quot;,&quot;李四&quot;);if(typeof car._initialized==&quot;undefined&quot;)&#123; car.prototype.showcolor=function()&#123; //属性指向函数 console.log(this.color); &#125;; car.initialized=true;&#125; 直到检查typeof car._initialized是否等于&quot;undefined&quot;之前，这个构造函数都未发生变化。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把car._initialized设置为true。如果这个值定义了(它的值为true，typeof为Boolean)，那么就不再创建该方法。也就是说该方法使用标志(_initialized)来判断是否已经给原型赋予了任何方法。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-内置对象","slug":"3-对象的类型-内置对象","date":"2018-04-23T04:10:38.000Z","updated":"2018-10-12T14:41:21.356Z","comments":true,"path":"2018/04/23/3-对象的类型-内置对象/","link":"","permalink":"http://yoursite.com/2018/04/23/3-对象的类型-内置对象/","excerpt":"","text":"内置对象ECMA-262(ECMAScript5.1的规范)把内置对象定义为&quot;由ECMAScript实现提供的、独立于宿主环境的所有对象,在ECMAScript程序开始执行时出现&quot;。也就是说，不必明确实例化内置对象，它已经被实例化了。 1.Global对象Global对象是ECMAScript中最特别的对象，因为实际上它根本不存在。 var g=Gloabl; //ReferenceError: Gloabl is not defined 明明Global是内置对象，为什么会显示错误消息呢？ 原因：因为Global对象实际上它根本不存在，所以不能把它赋值给一个变量。 在ECMAScript，不存在独立的函数，所有函数都必须是某个对象的方法。比如说isNaN()、isFinite()、parseInt()、parseFloat()等看起来都像是独立的函数，但实际上都是Global对象的方法。Global对象还有好多方法。 1.1.encodeURI()方法和encodeURIComponent()方法encodeURI()方法和encodeURIComponent()方法用于编码传递给浏览器的URL，用专门的utf-8编码替换所有的非有效字符，使浏览器仍能够接受并理解它们。 123456789var url=&quot;https://www.baidu.com/s? cl=3&amp;tn=baidutop 10&amp;fr=top 1000&amp;wd&quot;console.log(encodeURI(url))//https://www.baidu.com/s?%20cl=3&amp;tn=baidutop%2010&amp;fr=top%201000&amp;wdconsole.log(encodeURIComponent(url))/https%3A%2F%2Fwww.baidu.com%2Fs%3F%20cl%3D3%26tn%3Dbaidutop%2010%26fr%3Dtop%201000%26wd encodeURL()方法：不对URI中的特殊字符进行编码，如冒号、前斜杠、问号、英镑符号。 encodeURLComponent()方法：对它发现的所有非标准字符进行编码，这个方法基本上使得URL变得无用。 1.2.decodeURI()方法和decodeURIComponent()方法decodeURI()方法和decodeURIComponent()方法用于解码传递给浏览器的URL，decodeURI()方法只对encodeURL()方法替换的字符解码,同样decodeURLComponent()方法只对encodeURLComponent()替换的字符解码。 1234567var url=&apos;https://www.baidu.com/s?%20cl=3&amp;tn=baidutop%2010&amp;fr=top%201000&amp;wd&apos;decodeURI(url) //&quot;https://www.baidu.com/s? cl=3&amp;tn=baidutop 10&amp;fr=top 1000&amp;wd&quot;var url=&apos;https%3A%2F%2Fwww.baidu.com%2Fs%3F%20cl%3D3%26tn%3Dbaidutop%2010%26fr%3Dtop%201000%26wd&apos;decodeURIComponent(url) //&quot;https://www.baidu.com/s? cl=3&amp;tn=baidutop 10&amp;fr=top 1000&amp;wd&quot; 1.3.eval()方法：该方法就像整个ECMAScript的解释程序，接受一个参数，就是要执行的ECMAScript字符串。 1234567eval(&quot;1+3&quot;); //4eval(&apos;console.log(&quot;helloworld&quot;)&apos;) //helloworldeval(&quot;function add()&#123;console.log(5+5)&#125;&quot;)add() //10 当解释程序发现eval()调用时，它将把参数解释为真正的ECMAScript语句，然后把它插入该函数所在的位置，意味着eval()调用内部引用的变量可在参数意外定义。 1.4.Global属性undefined 、NaN、Infinity 、Object、Array 、Function 、Boolean 、String、Number 、Date 、RegExp 、Error EvalError 、RangeError、ReferenceError、SyntaxError 、TypeError 、URIError 2.Math对象2.1.常量 Math.E：常量e，自然对数的底数。 Math.LN10：10的自然对数。 Math.LN2：2的自然对数。 Math.LOG10E：以10为底的e的对数。 Math.LOG2E：以2为底的e的对数。 Math.PI：常量∏。 Math.SQRT1_2：1除以2的平方根。 Math.SQRT2：2的平方根。 2.2.min()方法和max()方法min()方法和max()方法用于判断一组数中的最大值和最小值。 1234567fvar max_num=Math.max(4,56,67,35,27,66)console.log(max_num); //67var min_num=Math.min(4,56,67,35,27,66)console.log(min_num); //4 2.3.abs()方法abs()方法返回数字的绝对值。 123var num=Math.abs(-10)console.log(num); //10 2.4.把小数舍入成整数123456789101112131415161718192021ceil()方法：向上取整var num1=Math.ceil(3.32792)console.log(num1); //4floor()方法：向下取整var num2=Math.floor(3.32792)console.log(num2); //3round()方法：标准的四舍五入var num3=Math.round(3.32792)console.log(num3); //3var num4=Math.round(3.62792)console.log(num4); //4 2.5.三角函数12345678910111213* `Math.acos(x)`：计算反余弦值。* `Math.asin(y)`：计算反正弦值。* `Math.atan(x)`：计算反正切值。* `Math.atan2(y,x)`：计算从X轴到一个点的角度。* `Math.sin(x)`：计算正弦值。* `Math.cos(x)`：计算余弦值。* `Math.tan(x)`：计算正切值。 2.6.random()方法random()方法，返回一个0~1之间的随机数，不包括0和1。 number=Math.floor(Math.random()*total_number_of_choices+first_possible_value) 使用floor()方法的原因是random()返回的都是小数值，但是我们通常需要的是选取一个随机整数值。 选取1~10之间的随机整数(10项) 12var num=Math.floor(Math.random()*10+1)console.log(num); 选取2~10之间的随机整数(9项) 12var num=Math.floor(Math.random()*9+2)console.log(num); 我们可以把选取随机数的这样过程封装成一个函数。 123456789function select(firstValue,lastVaule)&#123; var choices=lastVaule-firstValue+1; return Math.floor(Math.random()*choices+firstValue);&#125;var num=select(2,10); //选取2~10之间的随机整数(9项)console.log(num);var arr=[1,2,3,4,5,6,7,8,9];var result=arr[select(0,arr.length-1)];console.log(result);//随机获取数组arr中的值","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-本地对象","slug":"3-对象的类型-本地对象","date":"2018-04-21T07:20:30.000Z","updated":"2018-10-12T14:48:06.670Z","comments":true,"path":"2018/04/21/3-对象的类型-本地对象/","link":"","permalink":"http://yoursite.com/2018/04/21/3-对象的类型-本地对象/","excerpt":"","text":"本地对象ECMA-262(ECMAScript5.1的规范)把本地对象定义为&quot;独立于宿主环境的ECMAScript实现提供的对象&quot;。也就是说，本地对象就是ECMA-262定义的类(引用类型)。 Object、Function 、Array 、String、Boolean 、Number 、Date 、RegExp 、Error 、EvalError 、RangeError 、ReferenceError、SyntaxError 、TypeError 、URIError 1.Array类创建Array对象：var arr=new Array(); 如果预先知道数组中项的个数，可以用参数传递数组的大小。 1234var arr=new Array();arr[0]=&quot;a&quot;;arr[1]=&quot;b&quot;;arr[2]=&quot;c&quot;; 上述代码创建了一个数组，并定义了三个数组项(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)，每增加一个数组项，数组的大小就动态地增长。 如果知道数组应该存放的值，可以用参数声明这些值，创建大小与参数个数相等的Array对象。 var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); 数组中的第一项位于位置0，第二项位于位置1， 依此类推。可通过使用方括号中放置要读取的项的位置来访问特定的项。 123var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);console.log(arr[0]); // &quot;a&quot; 1.1.属性length可以获取数组的大小。123var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);console.log(arr.length); //3 数组可以根据需要增大或减小，因此，如果要为已定义的数组增加一项，只需要把存放的值放入下一个未使用的位置即可。 1234567var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);console.log(arr.length); //3arr[3]=&quot;d&quot;;console.log(arr.length); //4 其实可以给任意位置新增项，不过未定义的项就都变成了null. 1234567var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);console.log(arr.length); //3arr[15]=&quot;o&quot;;console.log(arr.length); //16 可以使用字面量表示定义Array对象，即使用方括号([和])和逗号分隔符。 1234567var arr=[1,2,3,4]console.log(arr.length); //4arr[4]=&quot;d&quot;;console.log(arr.length); //5 1.2.toString()方法Array对象覆盖了toString()方法，返回特殊的字符串。该字符串是通过对每项调用toString()方法，然后用逗号把它们连接在一起构成的。 123456var arr=[1,2,3,4]arr.toString(); // &quot;1,2,3,4&quot;var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);arr.toString() //&quot;a,b,c&quot; 1.3.join()方法：连接字符串值，将数组转换成字符串，该方法只有一个参数，就是数组项之间使用的字符串。1234567arr.join(&quot; &quot;) //&quot;1 2 3 4&quot;arr.join(&quot;/&quot;) //&quot;1/2/3/4&quot;arr.join(&quot;%&quot;) //&quot;1%2%3%4&quot;arr.join(&quot;-&quot;) //&quot;1-2-3-4&quot; ——————————————-插入题外话：—————————————— 1.4.String类split()方法：把字符串分割成一个字符串数组，该方法只有一个参数，该参数就是被看作数组项之间的分隔符的字符串。 如果由一个逗号分割的字符串，就可以转换成数组。 1234var str=&quot;a,b,c,d&quot;str.split(&quot;,&quot;) //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var str=&quot;1,2,3,4&quot;str.split(&quot;,&quot;) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] 如果把空字符串声明为分隔符，那么split()方法返回的数组中的每个项是字符串的字符。 123var str=&quot;hellowoeld&quot;;str.split(&quot;&quot;) //[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;e&quot;, &quot;l&quot;, &quot;d&quot;] ——————————————————回归正题————————– 1.5.concat()：把一个或多个值连接到Array对象的原始值上1234var arr =new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);var result=arr.concat(&apos;d&apos;)console.log(result); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]console.log(arr) //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 通过结果我们可以发现concat()函数并没有改变原数组的值，只是在操作它的副本。 1.6.slice()方法：分割数组，返回具有特定项的新数组。123456789var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];arr.slice(1); //[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]arr.slice(2,5) //[&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]arr.slice(2,-2) //[&quot;c&quot;, &quot;d&quot;]arr.slice() //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] slice(-2)被转换成了slice(4). Array类提供的方法使数组的行为与其他数据类型的行为相似，Array对象的push()方法和pop()方法的动作就像一个栈，栈是后进先出(LIFO)结构。 1.7.push()方法：用于在Array类结尾添加一个或多个项。1.8.pop()方法：用于删除最后一个数组项，数组的最后一项总是[length-1]。123456789var arr=new Array();arr.push(&quot;a&quot;);arr.push(&quot;b&quot;);arr.push(&quot;c&quot;);arr.toString(); //&quot;a,b,c&quot;var arr1=arr.pop();console.log(arr1); //cconsole.log(arr); //[&quot;a&quot;, &quot;b&quot;] push()方法其实和手动添加数组项是一样的效果。 12345678var arr=new Array();arr[0]=&quot;a&quot;;arr[1]=&quot;b&quot;;arr[2]=&quot;c&quot;;arr.toString(); //&quot;a,b,c&quot;var arr1=arr.pop();console.log(arr1); //cconsole.log(arr); //[&quot;a&quot;, &quot;b&quot;] 1.9.shift()：删除数组中的第一个项，将其作为函数的返回值。1.10.unshfit()：在数组的头部插入一个元素。1234567891011var arr=[1,2,3,4];var arr0=arr.shift();console.log(arr0); //1arr.unshift(&quot;1-1&quot;);console.log(arr); //[&quot;1-1&quot;, 2, 3, 4]console.log(arr.toString()); //1-1,2,3,4 Array对象的push()方法和shift()方法的动作就像一个队列，栈是后进后出(LILO)结构。 1.11.reverse():颠倒数组项的顺序。123var arr=[1,2,3,4];arr.reverse(); //[4, 3, 2, 1] 1.12.sort()：根据数组项的值按升序为它们排序。var arr=[‘r’,’w’,’s’,’g’,’f’] arr.sort() //[“f”, “g”, “r”, “s”, “w”] arr.toString() //“f,g,r,s,w” 注意：要使用sort()方法进行排序，首先必须要调用toString()方法，将所有值转换成字符串，然后根据ASCII比较数组项。 1234567var arr=[2,3,45,4,5,444]arr.sort(); //[2, 3, 4, 444, 45, 5]var arr1=arr.sort();arr1.toString(); //&quot;2,3,4,444,45,5&quot; 在对数字2,3,45,4,5,444进行排序时，是按照字符的ASCII进行比较的，2的ASCII值为50，3的ASCII值为51，4的ASCII值为52，5的ASCII值为53。 1.13.splice()方法：插入、删除或替换一个数组的部分元素。 第一种：删除 只需要声明两个参数，就可以从数组中删除任意多个项，这两个参数是要删除的第一项的位置和要删除的项的个数。类似slice()方法。 123456789var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];arr.splice(1); //[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]arr.splice(2,5) //[&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]`(&quot;因为不够5个数，所以只删除了3个&quot;)`arr.splice(2,-2) //[]arr.splice() //[] 和slice()方法不同的是splice()方法的参数不能是负数，因为splice()方法第二个参数表示的是要删除的项的个数，而不是要删除项的截止位置。 第二种：替换而不删除 声明三个删除就可以把数据项插入指定的位置，这三个参数是起始位置、0(要删除的项的个数)和要插入的项。 123456789var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];arr.splice(1,0,&apos;b-b&apos;) //[]arr.splice(1,0,&apos;b-b&apos;,&apos;b-2b&apos;,&apos;b-3b&apos;) //[]console.log(arr); //[&quot;a&quot;, &quot;b-b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]console.log(arr); //[&quot;a&quot;, &quot;b-b&quot;, &quot;b-2b&quot;, &quot;b-3b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 第三种：替换并删除 声明三个删除就可以把数据项插入指定的位置，这三个参数是起始位置、要删除的项的个数和要插入的项。 123456789var arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];arr.splice(1,1,&apos;b-b&apos;) //[]arr.splice(1,3,&apos;b-b&apos;,&apos;b-2b&apos;,&apos;b-3b&apos;) //[]console.log(arr); //[&quot;a&quot;, &quot;b-b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]console.log(arr); //[&quot;a&quot;, &quot;b-b&quot;, &quot;b-2b&quot;, &quot;b-3b&quot;, &quot;e&quot;, &quot;f&quot;] 2.Date类ECMAScript把日期存储为距离UTC时间1970年1月1日凌晨12点的毫秒数。UTC是通用时间代码，也叫做格林尼治标准时间，是所有时区的基准标准时间。以毫秒数存储时间可以确保ECMAScript免受恐怖的&quot;千年虫&quot;问题的侵害。 创建Date对象：var d=new Date(); 创建新Date对象时，有两种方式设置日期和时间的值。 第一种方式：只声明距离1970年1月1日凌晨12点的毫秒数。 123var d=new Date(0);console.log(d); //Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) 第二种方式：直接声明UTC()方法接受的参数 123var d=new Date(2018,6,11);console.log(d); //Wed Jul 11 2018 08:00:00 GMT+0800 (中国标准时间) 2.1.parse()方法：parse()方法接受字符串为参数，把该字符串转化成日期值(毫秒表示) parse()方法接受的日期格式： 123mm/dd/yyyy(7/11/2018)mmmm dd,yyyy(July 11,2018) 举例：使用parse()方法获取它的毫秒表示 12var d=new Date(Date.parse(&quot;July 11,2018&quot;));console.log(d); //Wed Jul 11 2018 00:00:00 GMT+0800 (中国标准时间) 如果传递给parse()方法的字符串不能转换成日期，该函数返回NaN。 2.2.UTC()方法UTC()方法的参数是日期中的年、月、日、小时、分、秒、毫秒。使用该方法时，必须声明年和月，其他参数可选。 12345var d=new Date(Date.UTC(2018,7,11));console.log(d); //Aug 11 2018 08:00:00 GMT+0800 (中国标准时间)var d=new Date(Date.UTC(2018,6,11));console.log(d); //Wed Jul 11 2018 08:00:00 GMT+0800 (中国标准时间) 注意： 月份的取值范围是从0~11。也就是说0表示1月，11表示12月。 参数小时，采用24小时制，而不是12小时制。 123var d=new Date(2018,6,11,14,22);console.log(d); //Wed Jul 11 2018 14:22:00 GMT+0800 (中国标准时间) 获取2018年7月11日下午2点22分的毫秒值。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-宿主对象","slug":"3-对象的类型-宿主对象","date":"2018-04-20T02:10:50.000Z","updated":"2018-10-12T14:48:05.233Z","comments":true,"path":"2018/04/20/3-对象的类型-宿主对象/","link":"","permalink":"http://yoursite.com/2018/04/20/3-对象的类型-宿主对象/","excerpt":"","text":"宿主对象所有非本地对象都是宿主对象，由ECMAScript实现的宿主环境提供的对象。 所有的BOM和DOM对象都是宿主对象。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-面向对象","slug":"3-面向对象","date":"2018-04-19T09:15:30.000Z","updated":"2018-10-12T14:41:27.541Z","comments":true,"path":"2018/04/19/3-面向对象/","link":"","permalink":"http://yoursite.com/2018/04/19/3-面向对象/","excerpt":"","text":"ECMA-262(ECMAScript5.1的规范)把对象定义为&quot;属性的无序集合&quot;，每个属性存放一个原始值、对象或函数。也就是说，对象是无特定顺序的值的数组。但它更通用的定义是基于代码的名词(人、地点或事物)表示。 对象定义存放在构造函数中，构造函数并不是一种特殊函数，它只不过是用于创建对象的常规函数。 1.面向对象特征封装—把相关的信息（无论数据或方法）存储在对象中的能力 聚集—把一个对象存储在另一个对象内的能力 继承—由另一个类得到另一个对象内的能力 多态—编写以多种方法运行的函数或方法的的能力 2.对象的构成在ECMAScript中，对象由特性(attribute)构成，特性可以是原始值，也可以是引用值，如果特性存放的是函数，它将被看作是对象的方法，否则该特性被看作属性。 3.对象应用3.1.声明和实例化对象是由关键字new后跟要实例化的类的名字创建的。 1var obj=new Object(); 创建了一个Object类的实例，并把它存储在变量obj中 1var str=new String(); 创建了一个String类的实例，并把它存储在变量str中 如果构造函数无参数，括号则不是必须的。 123var obj=new Object;var str=new String; 3.2.对象引用在ECMAScript中，不能访问对象的物理表示，只能访问对象的引用。每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。 3.3.对象废除ECMAScript有&quot;无用存储单元收集程序&quot;，意味着不必专门销毁对象来释放内存。当再没有对该对象的引用时，称该对象被废除了。 运用&quot;无用存储单元收集程序&quot;时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序都会自动运行，释放所有的局部变量，还有在一些其他不可预知的情况下，无用存储单元收集程序也会运行。 把对象的所有引用都设置为null，可以强制性的废对象。 123var obj=new Object();obj=null; 当变量obj设置为null后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。 3.4.早绑定和晚绑定不太懂，还有待研究。 绑定：把对象的接口与对象实例结合在一起的方法。 早绑定：在实例化对象之前定义它的特定和方法，这样编译器或解释程序就能提前转换机器代码。 晚绑定：指的是编译器或解释程序在运行前，不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。ECMAScript中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"3-作用域","slug":"3-作用域","date":"2018-04-17T13:10:35.000Z","updated":"2018-10-12T14:47:59.568Z","comments":true,"path":"2018/04/17/3-作用域/","link":"","permalink":"http://yoursite.com/2018/04/17/3-作用域/","excerpt":"","text":"作用域作用域：某些变量的使用范围 1.公用、受保护和私有作用域在传统的面向对象程序语言中存在公用、受保护和私有作用域。 公用作用域中的对象属性和方法可以从对象外部访问。 私有作用域中的属性和方法只能在对象内部访问，并且它的子类也不能访问这些属性和方法。 受保护作用域的属性和方法外部不能访问，对象内部和它的子类可以访问。 在ECMAScript中只存在就是公有作用域，这就意味着所有对象的所有属性和方法都是公用的。 但是在ECMAScript中存在着一个约定俗成的规约，”有效的属性作用域模式”，说明哪些属性和方法应该被看做是私有的。这种规约规定在属性名前后加下划线。 1obj.__name__=&quot;张三&quot;; //属性name是私有的。 注意：下划线并不改变这些属性是公用属性的事实，只是人为的约定应该把该属性看作是私有的。 2.静态作用域并非静态的静态作用域定义的属性和方法任何时候都能从同一个位置访问。 严格来说，ECMAScript并没有静态作用域，不过它可以给构造函数提供属性和方法。 1234567891011function a()&#123; console.log(&quot;a&quot;);&#125;a.aside=function()&#123; console.log(&quot;aside&quot;);&#125;a(); //aa.aside(); //aside 方法aside()实际上是函数a的方法，可以调用a()函数输出&quot;a&quot;，也可以调用a.aside()方法输出&quot;aside&quot;，即便如此，aside()也是a()公用作用域的方法，而不是静态方法。 重申一下：构造函数只是函数、函数是对象，对象可以有属性和方法。 3.关键字this关于this，会有一个另外专门的一个文章，链接地址：https://yingy0.github.io/2018/07/14/this/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"meの天使在人间","slug":"meの天使在人间","date":"2018-04-16T09:01:15.000Z","updated":"2018-10-12T13:47:34.745Z","comments":true,"path":"2018/04/16/meの天使在人间/","link":"","permalink":"http://yoursite.com/2018/04/16/meの天使在人间/","excerpt":"","text":"关于我の杨颖 基本信息姓名：杨颖博客：天使在人间联系方式：17868812265邮箱：17868812265@163.com目标：web前端工程师座右铭：衣带渐宽终不悔 ，为伊消得人憔悴大学时光感悟我是杨颖，我的专业是软件工程，算是误打误撞的进入了这个行业，还记得刚上大一的时候，学的就是C语言，在上机的时候就照着书上的代码编译出了helloworld就觉得这是一件很厉害的事情，随着学习的深入我学到了函数、指针、数组、真的是不太能理解，只是理解了一些基础的概念，我天真的以为学好一门语言就是学校里面发的一本[C语言从入门到精通]，在现在的我看来，所谓的精通不过只是皮毛而已，可是大一的我却不能准确的认识到这一点。大学的时光总是过的那么快，接下来我就学到了数据结构这本书了，各种各样数据的结构真是让人眼花缭乱，不知所踪，只知其然而不知其所以然，会的也只是生搬硬套，根本就不会灵活运用，比如链表、栈、队列、树、图等，根本就不会用到实际生活当中。现在的我已经大三了，马上就要大四了，压力也一直很大，害怕找不到比较满意的工作，害怕父母为我的工作着急，现在我有了明确的目标，不再浑浑噩噩的活着，也在一直努力着，感觉自己每天都学到着新知识，但是想到我还是不会灵活运用Html+Javascript+Jquery+Css+ajax，有时也会很烦躁，但也会安慰自己，慢慢来，新急吃不了热豆腐，现在时常会焦躁不安，也时常会安慰自己，你也没有那么差。现在的我还年轻，还可以努力，还可以吃苦。 希望并且期待着以后的我会比现在我的优秀。 自述我是杨颖，目前是一名大三的学生，马上就要步入大四，对于找工作这件事，充满着期待又有些担忧。回归这三年以来，每天上课、下课、到图书馆学习、偶尔出去做做兼职，时间也确实过得很快，从大三开始确定了以后工作的方向，就是从事 Web前端，也为此而努力着，想要成为一名合格的前端工程师，学习HTML、css、JavaScript、jQuery等和前端相关的知识，每天都在忙碌着，偶尔碰到不懂得问题也会感到迷茫，但不可思议的发现其实有些不会的知识点随着你学习的深入，再回过头看的时候发现原来那个问题并没有那么的难…… 从有了自己的博客后，每天记录着自己学习的知识点和遇到的问题，我相信这样慢慢积累着会有着不一样的收获，不是常说量变会达到质变，而且把一些东西记录下来会发现自己会记得更加牢固，我会继续坚持在前端的道路上，我发现它会变得越来越有趣。 学习方式 学习任何东西，看人家的官网总是没错的，别的教程总是参考着官网展开的。 博客在这里我推荐一些自认为比较好的学习网站和博客，cssgarden、GitHub、博客园、2次方、张鑫旭的个人主页、W3Cschool、haorooms的博客、Bootstrap作者、手册网、 书籍 实在是有太多好的关于web前端的书分享……… 我的简历","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"me","slug":"me","permalink":"http://yoursite.com/tags/me/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"2-运算符","slug":"2-运算符","date":"2018-04-15T02:04:28.000Z","updated":"2018-10-12T14:48:29.323Z","comments":true,"path":"2018/04/15/2-运算符/","link":"","permalink":"http://yoursite.com/2018/04/15/2-运算符/","excerpt":"","text":"运算符1.一元运算符1.1.delete运算符：删除对以前定义的对象属性或方法的引用12345var str=new String();str.name=&quot;张三&quot; //&quot;张三&quot;str.name //&quot;张三&quot;delete str.name //truestr.name //undefined 运算符不能删除未定义的属性和方法 123var str=new String();delete str.add() //删除add()方法时将会报错，因为add()方法没有定义。 1.2.void运算符：对任何值都返回undefined，该运算符通常用于避免输出不应该输出的值。举例：从HTML的&lt;a&gt;元素调用JavaScript函数时，函数不能返回有效值，否则浏览器将清空页面的所有效果只显示函数的结果。 12345678&lt;a href=&quot;&quot;&gt;我是链接&lt;/a&gt;&lt;script&gt;window.onload=function()&#123; var a=document.getElementById(&quot;a&quot;); var test=window.open(&quot;about:black&quot;); document.write(test);&#125;&lt;/script&gt; 从图中可以看到显示&quot;[Object window]&quot;，因为window.open()方法反回了对新打开的窗口的应用，然后该对象被转换成要显示的字符串。 解决方法：用void运算符调用window.open()函数，这时window.open()调用返回undefined，它不是有效的值，所以不会显示在浏览器窗口中。 12345678&lt;a href=&quot;&quot;&gt;我是链接&lt;/a&gt;&lt;script&gt;window.onload=function()&#123; var a=document.getElementById(&quot;a&quot;); var test=void (window.open(&quot;about:black&quot;)); document.write(test);&#125;&lt;/script&gt; 1.3.前增量/前减量运算符增量/减量运算都发生在计算表达式之前。 1.4.后增量/后减量运算符后缀式运算符是在计算过包含它们的表达式后才进行增量或减量运算的。 12345678910111213var num=10num-- //10num //9--num //8num //8num-- //8num //7 总结：前缀式运算符先++/--在计算表达式的值，后缀式运算符先计算表达式的值在++/--。 1.5.一元加法一元加法本质上对数字无任何影响; 123var num=10+num //10 虽然一元加法本质上对数字无任何影响，但可以把字符串转化为数字。 1234567var num=&apos;10&apos;typeof num //&quot;string&quot;snum=+num //10typeof snum //&quot;number&quot; 1.6.一元减法与一元加法运算符相似，一元减法运算符也会把字符串转换成近似的数字，并且还会对值求负。 1234567var num=&apos;10&apos;typeof num //&quot;string&quot;snum=-num //-10typeof snum //&quot;number&quot; 注意：当函数无明确返回值时，返回值也是undefined。 2.位运算符2.1.关于整数ECMAScript整数有两种类型：有符号整数和无符号整数。 在ECMAScript中，所有整数字面量默认都是有符号位整数。 有符号位整数使用前31位表示整数的数值，用第32位表示整数的符号，0表示正数，1表示负数。数值的范围从-2147483648~2147483647。 两种方式存储二进制形式的有符号位整数： 存储正数：前31位中的每一位都表示2的幂，从第一位开始，表示2的零次方，第二位表示2的一次方，依次类推。 举例：18的二进制只用了前5位，它们是这个数字的有效位，把数字转换成二进制字符串，就只能看到有效位。 123var num=18num.toString(2) //&quot;10010&quot; 存储负数：采用二进制补码的形式 第一步：确定该数字的非负版本的二进制表示(-18-&gt;18) 第二步：求得二进制反码，也就是说把0替换为1，把1替换为0; 第三步：在二进制反码上加1 举例：求-18的二进制表示 第一步：确定18的二进制表示：0000 0000 0000 0000 0000 0000 0001 0010 第二步：计算二进制的反码：1111 1111 1111 1111 1111 1111 1110 1101 第三步：反码+1：1111 1111 1111 1111 1111 1111 1110 1110 所以-18的二进制表示为1111 1111 1111 1111 1111 1111 1110 1110 举例： 123var num=-18num.toString(2) //&quot;-10010&quot; 大家是不是很奇怪结果输出”-10010”，而非二进制的补码形式1111 1111 1111 1111 1111 1111 1110 1110，这是为了避免开发者访问第31位。 无符号整数的数值范围为0~4294967295。 注意：所有整数字面量都默认存储为有符号位整数，只有用ECMAScript的位运算符才能创建无符号整数。 2.2.位运算NOT位运算NOT由否定号(~)表示,它的处理过程分为三步： 第一步：把运算数转换成32位数字 第二步：把二进制形式转换成它的二进制反码。 第三步：把二进制反码转换成浮点数。 12345var num=18 //0000 0000 0000 0000 0000 0000 0001 0010var num1=~18 //1111 1111 1111 1111 1111 1111 1110 1101num1 //-19 位运算符实质上是对数字求负，然后减1。 12345var num=18var num1=-num-1num1 //-19 2.3.位运算AND位运算由和号(&amp;)表示，直接对数字的二进制形式进行运算。 AND的运算规则，只有两个都为1时才为1，其余情况都为0; 举例： 123var s=25&amp;18 ;console.log(s); //16 25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001 18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010 结果：0000 0000 0000 0000 0000 0001 0000 //16 2.4.位运算OR位运算由竖线(|)表示，直接对数字的二进制形式进行运算。 OR的运算规则，只有两个都为0时才为0，其余情况都为1; 123var s=25|18 ;console.log(s); //16 25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001 18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010 结果：0000 0000 0000 0000 0000 0001 1011 //27 2.5.位运算XOR位运算由符号(^)表示，直接对数字的二进制形式进行运算。 XOR的运算规则，相同为0，不同为1。 123var s=25^18 ;console.log(s); //16 25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001 18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010 结果：0000 0000 0000 0000 0000 0000 1011 //11 2.6.左移运算左移运算由两个小于号表示(&lt;&lt;)，它把数字中的所有位数向左移动指定的数量。 12345var num=2 //10var num1=num&lt;&lt;5 //1000000console.log(num1) //64 注意：左移操作保留数字的符号位。所以，如果把-2左移5位为-64，而不是64。 12345var num=-2 //-10var num1=num&lt;&lt;5 //-1000000console.log(num1) //-64 注意：为了避免开发者访问31位，所以-2显示为-10，而不是1111 1111 1111 1111 1111 1111 1111 1110，-64显示为-1000000而不是1111 1111 1111 1111 1110 0000 2.7.有符号右移运算左移运算由两个大于号表示(&gt;&gt;)，它把数字中的所有位数向右移动指定的数量。 12345var num=64 //1000000var num1=num&gt;&gt;5 //10console.log(num1) //2 移动数位后会造成空位，这些空位位于数字的左侧，但是位于符号位之前。 2.8.无符号右移运算无符号左移运算由三个大于号表示(&gt;&gt;&gt;)，它把无符号32位数中的所有位数整体右移。 对于正数，无符号右移运算结果和有符号右移运算结果相同。 12345var num=64 //1000000var num1=num&gt;&gt;&gt;5 //10console.log(num1) //2 对于负数，那就呵呵了！！！ 12345var num=-64 //1000000var num1=num&gt;&gt;&gt;5 //111111111111111111111111110num1 //134217726 怎么会出现这种结果呢？ 无符号右移运算用0填充所有空位，对于负数由于无符号右移运算的结果是一个32位的正数，所有负数的无符号右移运算得到的总是一个非常大的数字。如何得到这种结果？ 12345var num=-64&gt;&gt;&gt;5num.toString(2) //&quot;111111111111111111111111110&quot;num //134217726 3.Boolean运算符Boolean运算符有三种，NOT、AND、OR 3.1.逻辑NOTBoolean运算符NOT由感叹号(~)表示，逻辑NOT运算符的行为如下： 如果运算数是对象，返回false 如果运算符是数字0，返回true 如果运算符是0以外的任何数字，返回false 如果运算符是null,返回true 如果运算符是NaN,返回true 如果运算符是undefined，发生错误 举例：该运算符用于控制循环 123456789var bFound=false;var i=0;while(!bFound)&#123; if(aValues[i]==vSearchValue)&#123; bFound=true; &#125;else&#123; i++; &#125;&#125; Boolean变量(bFound)用于记录检索是否成功，找到问题的数据项时，bFound将被设置为true,!bFound将等于false，意味着运行将跳出while循环。 3.2.逻辑AND运算符时逻辑AND运算符用双和号(&amp;&amp;)表示，逻辑AND运算符的行为，只有两个都为true时才为true，其余情况都为false; 如果一个运算符是对象，另一个是Boolean值，返回该对象。 如果两个运算符都是对象，返回第二个对象 如果某个运算符是null，返回null 如果某个运算符是NaN，返回NaN 如果运算符是undefined，发生错误 如果第一个运算数决定了结果，就不再计算第二个运算数，对于逻辑AND运算来说，如果第一个运算数是false,那么无论第二个运算数的值是什么，结果都不可能等于true。 12345var a=truevar s=a&amp;&amp;b //报错(b没有被定义)console.log(s)//这句将不会被执行 报错的原因：a的值true，逻辑AND运算将继续计算变量b的值，由于变量b是未定义的，不能用于逻辑AND运算，这样做就会引发错误。 12345var a=falsevar s=a&amp;&amp;bconsole.log(s) //false 第一个运算数是false,即使第二个变量的值是未定义的，结果都是false，这一点很重要。 3.3.OR位运算由双竖线(||)表示，逻辑OR运算符的行为，只有两个都为false时才为false，其余情况都为true; 如果一个运算符是对象，另一个是Boolean值，返回该对象。 如果两个运算符都是对象，返回第一个对象 如果某个运算符是null，返回null 如果某个运算符是NaN，返回NaN 如果运算符是undefined，发生错误 如果第一个运算数决定了结果，就不再计算第二个运算数，对于逻辑OR运算来说，如果第一个运算数是true,那么无论第二个运算数的值是什么，结果都不可能等于false。 12345var a=truevar s=a||bconsole.log(s) //true 第一个运算数是true,即使第二个变量的值是未定义的，结果都是true。 12345var a=falsevar s=a||b //报错(b没有被定义)console.log(s)//这句将不会被执行 报错的原因：a的值为false，逻辑OR运算将继续计算变量b的值，由于变量b是未定义的，不能用于逻辑OR运算，这样做就会引发错误。 4.乘性运算符4.1.乘法运算符乘法运算符由星号(*)表示，用于表示两个数相乘。 规则： 如果运算数都是数字，执行常规的乘法运算，即两个整数或两个负数相乘结果为正数，两个运算数符号不同，结果为负数。如果运算结果太大生成的结果是Infinity，如果运算结果太小生成的结果是-Infinity。 如果某个运算数是NaN，结果为NaN。 Infinity乘以0,结果为NaN Infinity乘以0以外的任何数字，结果为Infinity或-Infinity(由第二个运算数的符号决定) Infinity乘以Infinity，结果为Infinity。 4.2.除法运算符除法运算符由斜线(/)表示，用第二个运算数除第一个运算数。 规则： 如果运算数都是数字，执行常规的除法运算，即两个整数或两个负数除法结果为正数，两个运算数符号不同，结果为负数。如果运算结果太大生成的结果是Infinity，如果运算结果太小生成的结果是-Infinity。 如果某个运算数是NaN，结果为NaN。 Infinity被Infinity除,结果为NaN Infinity被任何数除，结果为Infinity。 0除以一个非无穷大的数字，结果为NaN。 Infinity被0以外的任何数字除，结果为Infinity或-Infinity(由第二个运算数的符号决定) 4.3.取模运算符取模运算符由斜线(%)表示。 规则： 如果运算数都是数字，执行常规的除法运算，返回除法运算得到的余数。 如果被除数是Infinity，或者除数是0，结果为NaN。 Infinity被Infinity除,结果为NaN 如果除数是无穷大的数，结果为被除数。 如果被除数为0，结果为0。 5.加性运算符5.1.加法运算符加法运算符由符号(+)表示。 规则： 某个运算数是NaN,结果为NaN Infinity加Infinity，结果为Infinity。 -Infinity加-Infinity，结果为-Infinity。 Infinity加-Infinity，结果为NaN。 +0加+0，结果为+0。 -0加+0，结果为+0。 -0加-0，结果为-0。 如果某个运算符是字符串，将采用以下规则： 如果两个运算数都是字符串，把第二个字符串连接到第一个字符串上。 如果只有一个运算符是字符串，把另一个运算符转换成字符串，结果是两个字符串连接成的字符串。 1234567var str=5+5console.log(str); //10var str=5+&apos;5&apos;console.log(str) //&quot;55&quot; 5.2.减法运算符减法运算符由符号(-)表示。 规则： 某个运算数是NaN,结果为NaN Infinity减Infinity，结果为NaN。 -Infinity减-Infinity，结果为NaN。 Infinity减-Infinity，结果为Infinity。 -Infinity减Infinity，结果为-Infinity。 +0减+0，结果为+0。 -0减-0，结果为-0。 某个运算符不是数字，结果为NaN. 6.关系运算符关系运算符小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)执行的是两个数的比较运算，每个关系运算符都返回一个Boolean值。 举例： 123var s=&quot;Bdedee&quot;&lt;&quot;aldee&quot;console.log(s); //true 字母”Bdedee”小于”aldee”，原因是字母B的ASCII是66，字母a的ASCII是97。如果要强制性得到按照真正的字母顺序比较的结果，必须把这两个运算符转换成相同的大小写形式(全大写或者全小写)，然后在进行比较，才可以得到比较正常的数据。 123var s=&quot;Bdedee&quot;.toLowerCase()&lt;&quot;aldee&quot;.toLowerCase()console.log(s); //false 当我们比较两个字符串形式的数字时，会发生什么呢？ 123var s=&quot;51&quot;&lt;&quot;6&quot;console.log(s) //true 原因：两个运算符都是字符串，所以比较的是它们的ASCII值。(字符串”51”的ASCII值为53，字符串”6”的ASCII值为54) 当我们比较的一个为字符串，一个为数字时，又会发生什么呢？ 123var s=&quot;51&quot;&lt;6console.log(s) //false 这就有趣了，字符串”51”被转换成了数字51,然后和数字6进行比较，肯定是数字51比较大了。 我们再来看一种令人不可思议的情况 123var s=&quot;a&quot;&lt;6console.log(s) //false 为什么会输出false呢？我真是不能理解了，字母”a”不能转换成有意义的数字，如果对它调用parseInt()方法，返回值为NaN，根据规则，任何包含NaN的关系运算都要返回false。 7.等性运算符判断两个变量是否相等，在处理原始值时，这种运算相当简单，但涉及到对象，任务就有些复杂。 7.1.等号和非等号等号由双等号(==)表示，当且仅当两个运算数相等时，它返回true。 非等号由感叹号加等号(!=)，当且仅当两个运算数不相等时，它返回true。 规则： 如果一个运算数是Boolean值，在检查相等性之前，把它转换成数字值，false转换成0，true抓换成1. 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串(调用toString()方法) 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字(调用valueOf()方法) 注意： 值null和undefined相等 在检查相等性时，不能把null和undefined转换成其他值 如果两个运算符都是对象，那么比较的是它们的引用值，如果两个运算数指向同一个对象，那么返回true，否则返回false。 如果某个运算数是NaN,等号将返回false,非等号将返回true。(NAN它与自身不相等) NaN==NaN //false 我们可以使用isNaN()函数来判断一个数的数据类型是不是非数。 举例： 1234567891011121314151617181920212223var obj=&#123;age:18&#125;obj.age==18 //trueobj.name=&quot;zhangsan&quot;obj.name==&quot;zhangsan&quot; //truenull==undefined //true&quot;NaN&quot;==NaN //false0==NaN //falseNaN==NaN //falsefalse==0 //truetrue==1 //trueNaN!=NaN //truetrue==2 //false(true==1!=2) 7.2.全等号和非全等号全等号和非全等号运算符所做的与等号和非等号相同，只是它们在类型检查相等性前，不执行类型转换。 全等号由三个等号(===)表示，只有在无需类型转换运算数就相等的情况下，才返回true。 非全等号由三个等号(!==)表示，只有在无需类型转换运算数不相等的情况下，才返回true。 举例： 123456789101112131415var s= &quot;5&quot;===5console.log(s) //falsevar s= &quot;5&quot;==5console.log(s) //truevar s= &quot;5&quot;!==5console.log(s) //truevar s= &quot;5&quot;!=5console.log(s) //false 7.3.总结：全等(“===”) 1、如果类型不同，就[不相等] 2、如果两个都是数值，并且是同一个值，那么[相等]；(!例外)的是，如果其中至少一个是NaN，那么[不相等]。 3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 4、如果两个值都是true，或者都是false，那么[相等]。 5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 6、如果两个值都是null，或者都是undefined，那么[相等]。 等号(“==”) 1、如果两个值类型相同，进行 === 比较。 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么[相等]。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 d、如果一个是对象，另一个是数值或字符串，把引用类型转换成原始类型类型的值再比较，利用它的toString()或者valueOf()方法。 e、任何其他组合，都[不相等]。 8.条件运算符variable=boolean_expression?true_value:false_value; 该表达式主要是根据boolean_expression的计算结果有条件的为变量赋值。如果boolean_expression为true,就把true_value赋给变量，如果它为false，就把false_value赋给变量。 9.赋值运算符简单的赋值运算由等号(=)实现，只是把等号右边的值赋给等号左边的变量。 复合赋值运算是由乘性运算符、加性运算符或者移位运算符加等号(=)实现的。 每种主要的算术运算以及其他几个运算都要符合赋值运算符： 乘法/赋值：(* =) 除法/赋值：(/ =) 取模/赋值：(% =) 加法/赋值：(+ =) 减法/赋值：(- =) 左移/赋值：(&lt;&lt; =) 有符号右移/赋值：(&gt;&gt; =) 无符号右移/赋值：(&gt;&gt;&gt; =) 10.逗号运算符用逗号运算符可以再一条语句中执行多个运算。 var a=1,b=2,c=3;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-转换","slug":"2-转换","date":"2018-04-12T11:19:09.000Z","updated":"2018-10-12T14:48:24.593Z","comments":true,"path":"2018/04/12/2-转换/","link":"","permalink":"http://yoursite.com/2018/04/12/2-转换/","excerpt":"","text":"1.转换原始类型的值的转化 1.1.转换成字符串我们首先应该知道原始值Boolean、Number、String字符串都是伪对象，也就是说它们具有Object对象的属性和方法。 举例：获取字符串的长度： 12var color=&quot;red&quot;color.length //3 所以，我们应该记住原始值Boolean、Number和String字符串都有toString()方法。 Bollean类型的toString()方法只是输出”true”或者”false”，结果由变量的值决定。 1234567var val=true;val.toString; //ƒ toString() &#123; [native code] &#125;val.toString(); //&quot;true&quot;var val=false;val.toString; //ƒ toString() &#123; [native code] &#125;val.toString() //&quot;false&quot; Number类型的toString()方法有两种模式：默认模式和基模式。 默认模式：无论最初采用什么表示法声明数字，Number类型的toSring()方法都是数字的十进制表示，也就是说，以八进制或十六进制字面量形式声明的数字输出时都是十进制形式的。 123456789101112131415var inum=10;inum.toString() //&quot;10&quot;var inum=10.0;inum.toString() //&quot;10&quot;var inum=070;inum.toString() //&quot;56&quot;var inum=0xab;inum.toString() //&quot;171&quot; 基模式：可以用不同的基输出数字，例如二进制的基为2，八进制的基为8，十六进制的基为16，基是toStiring()方法的参数。 1234567var inum=10;inum.toString(16) //&quot;a&quot;inum.toString(10) //&quot;10&quot;inum.toString(2) //&quot;1010&quot; 1.2.转换成数字parseInt()：把非数字的原始值转换成整数。 parseInt()方法首先查看位置0处的字符，判断它是否是个有效数字;如果不是,该方法返回将返回NaN,不再继续执行其他操作。但如果该字符是有效字符，将继续查看位置1处的字符，进行同样的测试，这一过程将持续到发现第一个非有效数字的字符为止。此时parseInt()将把该字符之前的字符串转换成数字。 1234567parseInt(&quot;3434frfr&quot;) //3434parseInt(&quot;0xA&quot;) //10parseInt(&quot;25.7&quot;) //25parseInt(&quot;hththf&quot;) //NaN parseInt()方法同样有基模式,基是由该方法的第二个参数指定的。 1234567parseInt(&apos;DA&apos;,16) //218parseInt(&apos;100&apos;,8) //64parseInt(&apos;100&apos;,2) //4parseInt(&apos;100&apos;,10) //100 parseFloat()：把非数字的原始值转换成浮点数 parseFloat():首先查看位置0处的字符，这一过程将持续到发现第一个非有效数字的字符为止，然后把该字符之前的字符串转换成数字，比较特殊的是，第一个出现的小数点是有效字符，如果有两个小数点，第二个小数点将被看做是无效的。 parseFloat()方法没有基模式，该方法的字符串必须是以十进制形式表示的浮点数，而不存在二进制、八进制或者十六进制的形式，并且该方法会返回前导0。 1234567891011parseFloat(&apos;45.6.7&apos;) //45.6parseFloat(&apos;deedef&apos;) //NaNparseFloat(&apos;0786&apos;) //786parseFloat(&apos;373dheude&apos;) //373parseFloat(&apos;77.5&apos;) //77.5parseFloat(&apos;0xA&apos;) //NaN 1.3.强制类型转换Boolean():把给定的值转换成Boolean型 当要转换的值是至少有一个字符的字符串、非0数字或对象时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null时，它将返回0。 1234567891011121314var Boolean(1) //trueBoolean(&quot;a&quot;) //trueBoolean(&quot;new Object()&quot;) //trueBoolean(&apos;&apos;) //falseBoolean(null) //falseBoolean(0) //falseBoolean(undefined) //false Number()：把给定的值转换成数字 Number()的强制类型转换与parseInt()和parseFloat()的处理过程相似，只是它的转换’对象’是整个值而不是部分值，也就是说，它不会舍弃部分值，而是当做整体对待。 1234567891011121314151617Number(3.2) //3.2Number(&apos;3.2.1&apos;) //NaNNumber(100) //100Number(&apos;32&apos;) //32#Number(new Object()) //NaNNumber(false) //0Number(true) //1Number(null) //0Number(undefined) //NaN String()：把给定的值转换成字符串。 1234567891011String(1) //&quot;1&quot;String(true) //&quot;true&quot;String(&quot;1.099&quot;) //&quot;1.099&quot;String(&quot;-34.4&quot;) //&quot;-34.4&quot;String(null) //&quot;null&quot;String(undefined) //&quot;undefined&quot;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-语句","slug":"2-语句","date":"2018-04-09T06:15:20.000Z","updated":"2018-10-12T14:48:33.971Z","comments":true,"path":"2018/04/09/2-语句/","link":"","permalink":"http://yoursite.com/2018/04/09/2-语句/","excerpt":"","text":"语句，通常是采用一个或多个关键字完成给定的任务。语句可以非常简单，例如通知函数退出，也可以非常复杂，如声明一组要反复执行的命令。 1.if语句2.迭代语句2.1.do-while语句2.2.while语句2.3.for语句2.4.for-in语句for-in语句是严格的迭代语句，用于枚举对象的属性。 12345var s=&quot;abc&quot;;for(s in window)&#123; console.log(s);&#125; 输出window对象的所有属性。 3.有标签的语句4.break语句和continue语句break语句： 12345678var num=0;for(var i=1;i&lt;10;i++)&#123; if(i%5==0)&#123; break; &#125; num++;&#125;console.log(num); //4 continue语句： 12345678var num=0;for(var i=1;i&lt;10;i++)&#123; if(i%5==0)&#123; continue; &#125; num++;&#125;console.log(num); //8 5.with语句with语句用于设置代码在特定对象中的作用域。 语法：with (expression) statement; 举例: 12345var str=&quot;helloworld&quot;;with(str)&#123; console.log(toUpperCase());&#125; //HELLOWORLD 上述代码中,with语句用于字符串,在调用toUpperCase()方法时,解释程序将检查该方法是否是本地函数.如果不是,它将检查伪对象str,看它是否为该对象的方法,然后输出相应的结果.(HELLOWORLD) 6.switch语句","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-引用类型","slug":"2-引用类型","date":"2018-04-06T18:12:10.000Z","updated":"2018-10-12T14:48:37.898Z","comments":true,"path":"2018/04/07/2-引用类型/","link":"","permalink":"http://yoursite.com/2018/04/07/2-引用类型/","excerpt":"","text":"1.引用类型引用类型通常叫做类，也就是说当遇到引用值时，所处理的就是对象。 对象是由new运算符加上要实例化的类的名字创建的。 123var o=new Object();var o=new Object; 1.1.Object类ECMAScript中的所有的其他类都是由Object类继承而来，Object类中的所有属性和方法都会出现在其他类中。 属性： constructor：对创建对象的函数的引用（指针），对于Object类，该指针执行原始的object()函数。 prototype：对该对象的对象原型的引用。 方法： HasOwnPropertype(property)：判断某个对象是否有某个特定的属性，必须用字符串指定该属性。 IsPrototypeOf(object)：判断该对象是否为另一个对象的原型。 PropertyIsEnumerable(prototype)：判断给定的属性是否可以用for...in语句进行枚举。 ToString()：返回对象的原始字符串表示。 ValueOf()：返回与该对象相关的原始值。 这些属性和方法都会被其他的类覆盖。 1.2.Boolean类Bollean类是Boolean原始类型的引用类型。 创建一个Boolean对象，只需要传递Boolean值作为参数。 1var bool=new Boolean(true) Boolean对象将覆盖Object类的valueOf()方法，返回原始值(true,false). 123var bool=new Boolean(true)bool.valueOf() //true 1.3.Number类Number类是Number原始类型的引用类型。 创建一个Number对象：var num=new Number(30); 获取数字对象的Number原始值： 123var num=new Number(30);num.valueOf(); //30 toFixed()方法：返回的是具有指定位数小数的数字的字符串表示。 123var num=new Number(300);num.toFixed(3) //&quot;300.000&quot; toExponential()方法：返回的是用科学计数法表示的数字的字符串的形式。 12var num=new Number(300);num.toExponential(2) //&quot;3.00e+2&quot; toPrecision()方法：根据最有意义的形式来返回数字的预定形式或指数形式。 12var num=new Number(300);num.toPrecision(2) //&quot;3.0e+2&quot; 1.4.String类String类是String原始类型的引用类型。 创建一个String对象：var str=new String(&quot;hello&quot;); String对象的valueof()方法和toString()方法都会返回String型的原始值。 123var str=new String(&quot;hello&quot;);str.valueOf()==str.toString() //true 属性：length 方法： charAt()：访问字符串中的单个字符 抽取字符串中指定位置处的字符，第一个字符的位置是0，第二个字符的位置是1，以此类推。 12var str=new String(&quot;hello&quot;);str.charAt(2) //&quot;l&quot; charCodeAt()：访问字符串中的单个字符 返回字符串中指定位置处的字符编码 12var str=new String(&quot;hello&quot;);str.charCodeAt(2) //108 concat()：把一个或多个值连接到String对象的原始值上 1234var str=new String(&quot;hello&quot;);var result=str.concat(&apos;world&apos;)console.log(result); //&quot;helloworld&quot;console.log(str) //String &#123;&quot;hello&quot;&#125; 通过结果我们可以发现concat()函数并没有改变原字符串的值，只是在操作它的副本。更常见的是我们使用&#39;+&#39;来连接字符串，这种形式从逻辑上表现了真正的行为。 1234var str=new String(&quot;hello &quot;);var result=str+&apos;world&apos;;console.log(result); //&quot;helloworld&quot;console.log(str) //String &#123;&quot;hello&quot;&#125; &quot;+&quot;运算符连接字符串的运算规则： 如果两个运算数都是字符串，把第二个字符串连接到第一个字符串上。 如果只有一个运算符是字符串，把另一个运算符转换成字符串，结果是两个字符串连接成的字符串。 indexOf()：从字符串开头(位置0)开始检索子串 lastIndexOf()：从字符串结尾开始检索子串。 12345var str=new String(&quot;helloworld&quot;);str.indexOf(&apos;o&apos;); //4str.lastIndexOf(&apos;o&apos;) //6 localeCompare()：对字符串进行排序。 如果String对象按照字母顺序排在参数值的字符串之前，返回负数。(真正的返回值是由实现决定的) 如果String对象等于参数中的字符串，返回0。(真正的返回值是由实现决定的) 如果String对象按照字母顺序排在参数值的字符串之后，返回正数。(真正的返回值是由实现决定的) 1234567var str=new String(&quot;hello&quot;);str.localeCompare(&apos;agde&apos;) //1str.localeCompare(&apos;oilk&apos;) //-1str.localeCompare(&apos;hello&apos;) //0 注意：localeCompare()函数的返回值并不是是先定义好的，而是由实现决定的，所以最好是由if…else形式判断的调用。 1234567891011121314151617var str=new String(&quot;hello&quot;);var str1=new String(&quot;agde&quot;);var str2=new String(&quot;oilk&quot;);var str3=new String(&quot;hello&quot;);var result=TextString.localeCompare(&quot;hello&quot;);if(result&lt;0)&#123; console.log(str1+&quot;在&quot;+str+&quot;之前&quot;); //agde在hello之前&#125;else if(result&gt;0)&#123; console.log(str2+&quot;在&quot;+str+&quot;之后&quot;); //oilk在hello之后&#125;else&#123; console.log(str3+&quot;等于&quot;+str); //hello等于hellos&#125; slice()：把字符串分割成一个字符串数组。 substring()：从字符串中抽取一个子串。 这两个方法返回的都是要处理的字符串的子串，都接受一个或者两个参数。第一个参数是要获取的子串的起始位置，第二个参数是要获取子串终止前的位置。 123456789var str=new String(&quot;hello world&quot;);str.slice(2) //&quot;llo world&quot;str.slice(2,7) //&quot;llo w&quot;str.substring(2) //&quot;llo world&quot;str.substring(2,7) //&quot;llo w&quot; 从上述结果中可以看出，对于正数参数slice()方法和substring()方法返回的值完全相同，那我们看一下对于负数参数，slice()方法和substring()方法是不是也能返回同样的值呢？ 12345678910111213var str=new String(&quot;hello world&quot;);str.slice(-2) //&quot;ld&quot;str.substring(-2) //&quot;hello world&quot;str.slice(-2,5) //&quot;&quot;str.substring(-2,5) //&quot;hello&quot;str.slice(5,-2) //&quot; wor&quot;str.substring(5,-2) //&quot;hello&quot; 从结果中我们可以发现对于负数参数，slice()方法和substring()方法返回的值是完全的不一样呀！！！ 原因：对于字符串&quot;hello world&quot;，str.slice(-2)被转换成了str.slice(9)，而str.substring(-2)被转换成了str.substring(0)，同理str.slice(-2,5)被转化成了str.slice(9,5)，str.slice(5,-2)被转换成了str.slice(5,9)，str.substring(-2,5)和str.substring(5,-2) 被转换成了str.substring(0,5)。 toLowerCase()：将字符串中的所有字符都转换成小写的，然后返回一个副本 toUpperCase()：将字符串中的所有字符都转换成大写的，然后返回一个副本 12345var str=new String(&quot;hggAFhhv&quot;)str.toLowerCase() //&quot;hggafhhv&quot;str.toUpperCase() //&quot;HGGAFHHV&quot;。 注意：String类的所有属性和方法都可应用于String原始值上，因为它们都是伪对象。 2.instanceof运算符对于引用类型的值typeof运算符只能返回object，所以我们可以使用instanceof来解决这个问题。 instanceof运算符用于识别正在处理的对象的类型，要求必须明确的确认对象为某种特定的类型。 1234567[ ] instanceof Array //true(/[0-9]/) instanceof RegExp //truevar str=new String(&quot;hello&quot;);str instanceof String; //true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-原始类型","slug":"2-原始类型","date":"2018-04-05T04:18:10.000Z","updated":"2018-10-12T14:48:31.019Z","comments":true,"path":"2018/04/05/2-原始类型/","link":"","permalink":"http://yoursite.com/2018/04/05/2-原始类型/","excerpt":"","text":"1.原始值和引用值原始值是存储在栈中的简单数据段，它们的值直接存储在变量访问的位置。 引用值是存储在堆中的对象，存储在变量处的值是一个指针，执行存储对象的内存处。 为变量赋值时，ECMAScript解释程序必须判断该值是原始类型的，还是引用类型的。 ECMAScript原始类型的值包括5种，分别是undefined、Null、Bollean、Number、和String。 ECMAScript引用类型包括：Object类、Array类、Date类、RegExp类和Function类等。 当遇到引用值时，所处理的就是对象。 如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反的，放在变量的栈空间中的值是该对象存放在堆中的地址。因为地址的大小是固定的，把它存储在栈中对变量性能无任何负面影响。 判断变量的类型的几种方式： 1.1.typeof：对于变量或值调用typeof运算符将返回下列值之一： &#39;undefined&#39;：如果变量时Undefined类型 &#39;boolean&#39;：如果变量是Boolean类型 &#39;number&#39;：如果变量是Number类型 &#39;string&#39;：如果变量是String类型 &#39;object&#39;：如果变量是一种引用类型或Null类型。 大家可能对typeof null的结果为&quot;object&quot;持有怀疑态度，这实际上是JavaScript最初实现中的一个错误，然后被ECMAScript沿用了。现在NULL被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。 注意：比较适合用于检查原始值的类型，不适合用于检查原始值得数组类型，原因大家也看到了，对于引用类型的值它只能返回object。 1.2.toString.call()123toString.call([]) // &quot;[object Array]&quot;toString.call(&apos;&apos;) // &quot;[object String]&quot;toString.call(/[^9]/) //&quot;[object RegExp]&quot; 1.3.constructor1234var arr=[];arr.constructor; //f Array() &#123; [native code] &#125;var str=&apos;12&apos;str.constructor //f String() &#123; [native code] &#125; 注意：constructor是不太严谨的，它是一个可读可写的属性 1.4.instanceof123[ ] instanceof Array //true(/[0-9]/) instanceof RegExp //true在旧的浏览器不太支持 2.原始类型2.1.Undefined类型Undefined类型只有一个值，也就是undefined.当声明的变量未初始化时，该变量的默认值为undefined。 12345var ying; //声明变量ying，但是没有赋初值，该变量将被赋值给undefined。ying==undefined //truetypeof ying //&quot;undefined&quot; 注意：值undefined并不同于未定义的值，未定义的值就是没有用var声明的值，但是typeof运算符并不会区分这两种值，仍然返回的是undefined。 前提：并没有用var声明变量yang 123yang // &quot;undefined&quot;yang==undefined //Uncaught ReferenceError: yang is not defined 从结果中我们可以明显的看出即使是未定义的值，它的typeof的返回值也是undefined，但是如果对未定义过的变量使用除了typeof之外的运算符的话(==)，会报错,因为其他运算符只能用于已声明的变量上。 注意：当函数无明确返回值时，返回值也是undefined。 12345function fun()&#123;&#125; //该函数没有明确的返回值fun()==undefined //truetypeof fun //&quot;function&quot; 2.2.NULL类型Null类型也只有一个值，也就是null。值undefined实际上是从值null派生来的，因此ECMAScript把它们定义为相等。 1null==undefined //true 注意：尽管这两个值相等，但它们的含义不同。undefined是声明了变量但未对其初始化时赋予该变量的值，null则用于表示尚未存在的对象。 2.3.Boolean类型Boolean类型它有两个值true和false,即使false不等于0，0也可以在必要时被转换成false。 2.4.Number类型Number类型既可以表示32位的整数，还可以表示64位的浮点数。直接输入的任何数字都被看做是Number类型的字面量。 var num=1; typeof整数也可以表示为八进制或者十六进制的字面量 123num=070; //八进制var num=0x1f; //十六进制 注意：尽管所有整数都可以表示为八进制或者十六进制的字面量，但所有数学运算返回的都是十进制结果。 浮点值必须要包括小数点和小数点后的一位数字。 var num=1.0; 对于非常大或非常小的数，可以用科学计数法表示浮点值。科学计数法可以把一个数表示为数字(包括十进制数字)加e(或E)，后面加乘以10的倍数。 123var num=3.125e10;var num=3-e17; 关于特殊值： Number.MIN_VALUE //5e-324 Number.MAX_VALUE //1.7976931348623157e+308 定义了Number值集合的外边界，所有ECMAScript数都必须在这两个值中间,但是计算生成的数值结果可以不落在这两个数之间。 当计算生成的数大于Number.MAX_VALUE，它将被赋予值Number.POSITIVE_INFINITY 当计算生成的数小于Number.MIN_VALUE，它将被赋予值Number.NEGATIVE_INFINITY 123Number.POSITIVE_INFINITY==Infinity //trueNumber.NEGATIVE_INFINITY==Infinity //true isFinit()方法：判断一个数是有穷的还是无穷的 1234567var num=some_really_large_number;if(isFinit(num))&#123; console.log(&quot;这个数是有穷的&quot;)&#125;else&#123; console.log(&quot;这个数是无穷的&quot;)&#125; NAN:表示非数 NAN是个奇怪的特殊值，一般来说在不同数据类型之间转换失败时，比如把字符串类型(&quot;blue&quot;)转换成数值就会失败，因为没有与之等价的数值。 Number(&quot;blue&quot;) //NaN (将字符串&quot;blue&quot;转换成Number类型,转换失败) NAN它与自身不相等。 NaN==NaN //false 我们可以使用isNaN()函数来判断一个数的数据类型是不是非数。 12345isNaN(&quot;blue&quot;) //trueisNaN(&quot;1&quot;) //falseisNaN(1) //false 2.5.String类型String类型，它是唯一没有固定大小的原始类型，可以用字符串存储0或更多的Unicode字符，由16位整数表示。 字符串中每个字符都有特定的位置，首字符从位置0开始，第二个字符在位置1，以此类推，这意味着字符串中的最后一个字符的位置一定是字符串的长度减1。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"2-函数","slug":"2-函数","date":"2018-04-02T14:12:10.000Z","updated":"2018-10-12T14:48:39.443Z","comments":true,"path":"2018/04/02/2-函数/","link":"","permalink":"http://yoursite.com/2018/04/02/2-函数/","excerpt":"","text":"函数函数是一组可以随时随地运行的语句，函数是由关键词function、函数名加一组参数以及置于括号中的要执行的代码声明的。 123functionName(arg0,arg1,...,argN)&#123; statements;&#125; 函数在执行过return语句后会停止执行代码，所以return语句后的代码都不会被执行。 12345function sum(num1,num2)&#123; return num1+num2; //3 console.log(num1-num2); //不会被执行&#125;sum(1,2); //3 一个函数中可以有多个return语句 12345678function diff(num1,num2)&#123; if(num1&gt;num2)&#123; return num1-num2; &#125;else&#123; return num2-num1; &#125;&#125;diff(2,3); //1 如果函数无返回值，那么可以调用没有参数的return运算符，随时退出函数。 123456789function func(str)&#123; if(str==&quot;hello&quot;)&#123; return; &#125; console.log(str);&#125;func(&quot;hello&quot;); //undefinedfunc(&quot;ddje&quot;); //deje 上述代码中，如果str的值等于字符串&quot;hello&quot;,那么就会在控制台输出undefined，如果str的值不等于字符串&quot;hello&quot;,那么就会在控制台输出str字符串的值。 注意：如果函数无明确返回值，或调用了没有参数的return语句，那么它真正的返回值为undefined。 1.无重载ECMAScript中的函数不能重载，我们可以看一下如果用相同的函数名会发生什么情况？ 123456789function add(num1,num2)&#123; console.log(num1+num2);&#125;function add(num1,num2)&#123; console.log(num1-num2);&#125;add(2,1); //1 从上述代码我们可以知道，可用相同的名字在同一个作用域中定义两个函数，而不会引发错误，但真正起作用的是后一个函数，后一个函数将前一个函数给覆盖了。可以使用arguments对象避开这种限制。 2.arguements对象在函数代码中，使用特殊对象arguments，无需明指出参数名，就能访问函数的参数。第一个参数用arguments[0]访问，第一个参数用arguments[1]访问，以此类推。 12345678910function func()&#123; if(arguments[0]==&quot;hello&quot;)&#123; return; &#125; console.log(arguments[0]);&#125;func(&quot;hello&quot;); //undefinedfunc(&quot;ddje&quot;); //deje 可用arguements.length检测传递给函数的参数个数。 1234567function howmanyArgs()&#123; console.log(arguments.length);&#125;howmanyArgs(); //0howmanyArgs(3); //1howmanyArgs(&quot;sde&quot;,0); //2howmanyArgs(&#123;a:18&#125;,[1,2],0); //3 用arguements对象判断传递给函数的参数个数，即可模拟函数重载。 12345678910function add()&#123; if(arguments.length==1)&#123; console.log(arguments[0]+&quot;1&quot;);&#125;else&#123; console.log(arguments[0]+arguments[1]); &#125;&#125;add(1); //11add(1,2); //3 3.Function类在ECMAScript中函数实际上是功能完整的对象，Function类可以表示任何函数。 语法： 1var function_name=new Function(arguments1,arguments2,......,argumentsN,function_body); 每个arguments都是一个参数，最后一个参数是函数主体，这些参数必须是字符串。 123456789function add(num1,num2)&#123; console.log(num1+num2);&#125;function add(num1,num2)&#123; console.log(num1-num2);&#125;add(2,1); //1 上述代码，第二个函数重载了第一个函数，所以add(2,1)输出1而不是输出3。如果以下面的形式重写代码块，关于重载就更清楚了。 12345var add=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;console.log(num1+num2)&quot;);var add=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;console.log(num1-num2)&quot;);add(2,1);//1 很显然，add的值被改成了指向不同对象的指针。也就是说，函数名只是指向函数对象的引用值，行为就像其他指针一样。 可以使两个变量指向同一个函数。 1234567var add=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;console.log(num1+num2)&quot;);var alsoadd=add;add(2,1);//3alsoadd(2,1);//3 变量add被定义为函数，同时alsoadd变量被声明为指向同一个函数的指针。所以这两个变量都可以执行该函数的代码，输出相同的结果。因此，如果函数名只是指向函数的变量，那么可以把函数作为参数传递给另一个函数。 1234567function callAnotherFunc(fn,vArg1,vArg2)&#123; fn(vArg1,vArg2);&#125;var add=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;console.log(num1+num2)&quot;);callAnotherFunc(add,1,2); //3 因为函数是引用类型，所以它们也有属性和方法。ECMAScript定义的length属性声明了函数期望的参数个数。 1234567891011function sum(num1,num2)&#123; console.log(num1+num2); //3&#125;sum(1,2); function add(num)&#123; console.log(num+&apos;10&apos;) //110&#125;add(1);console.log(sum.length); //2console.log(add.length); //1 Fnuction对象也有与所有对象共享的标准的valueOf()方法和toString()方法，这两个方法返回的都是函数的源代码。 1234567891011function sum(num1,num2)&#123; console.log(num1+num2); //3&#125;sum(1,2); function add(num)&#123; console.log(num+&apos;10&apos;) //110&#125;add(1);console.log(sum.valueOf());console.log(add.toString()); 4.闭包关于闭包，会有一个另外专门的一个文章。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Hexo+Github搭建个人博客","slug":"Hexo-Github搭建个人博客","date":"2018-04-01T08:35:14.000Z","updated":"2018-10-12T14:47:25.667Z","comments":true,"path":"2018/04/01/Hexo-Github搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/04/01/Hexo-Github搭建个人博客/","excerpt":"","text":"这是我的第一篇博客，我就说说我是怎么利用Hexo和GitHub搭建博客的吧，可以在外网上访问我的博客，心情还是很激动的。 1.所需的软件 1.nodeJs 2.Git(Git Bash) 3.GitHub账号 2.Hexo官网的操作 2.1.进入Hexo官网，进入之后往最下面拉，总有五条命令,这个时候Git Bash就派上用场了。 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 2.2.新建一个文件夹Hexo，点击右键，就可以看到Git Bash的快捷键方式， 单击之后就进入到了可以安装Hexo环境了，这五条指令一条一条的依次输入执行，不能一次性粘贴复制，否则会报错。 2.3.输入hexo server后就可以在浏览器输入localhost:4000查看,如果出现了一个简易的博客页面而不是一个404页面，恭喜你这是成功的第一步。 3.GitHub官网的操作 3.1.GitHub官网，进入之后，首先得登录就不用说了，进去之后你会发现右上角会有一个加号➕，鼠标放上去会出现四个选项，首先选择第四个[new organization]也就是新建一个组织，随便起一个名字就可以了，然后选择第一个[new repository]，也就是新建一个仓库，填入仓库的名字。 注意：仓库的名字和组织的名字一定要相同，一定要是name.github.io格式，不然会出错，大家一定要记住。 3.2.生成SSH密钥 在这里又要用到GitBush了，ssh-keygen -t rsa输入该命令之后，一路回车，就会生成密钥了。是不是特别想知道生成的密钥的位置，就在C\\用户\\你的电脑.ssh文件夹里面，其中有两个密钥，用记事本打开其中的id_rsa.pub复制即可,然后回到GitHub中，点击右上角图片的位置，会出现settings(设置)点击进去，在鼠标下拉的过程中你会发现SSH and GPG keys这个按钮，不要犹豫，赶紧点进去，然后点击new ssh key，将你刚才复制的密钥粘贴进去，点击保存。 3.3.配置文件 配置文件的路径是F:\\Hexo\\blog中的_config.yml，可以参考官网的配置文件，官网的配置文件特别详细，如果是第一次修改的，就改改网站(site)里面的标题、副标题、网站的名字其他的不要乱改，最重要的配置是文件的最后一行deploy的配置如下图所示。 注意： repository中的地址Github的远程仓库的地址，每个人的肯定都不一样，大家根据情况自行修改。配置文件时，大家可以一步一步来配置，不断地利用hexo s，然后刷新localhost:4000页面检查自己是否配置的正确 4.上传文件 4.1.上传文件的操作上传文件时又要用到Git Bash了，大家应该知道Git的重要性以及方便性，上传到GitHub上面的命令是： 123$ hexo clean$ hexo g$ hexo d 注意：在Git Bash里面输入这三条代码之前，你首先必须确认你有没有安装node，检测node有没有安装的指定是，如果没有安装node,请输入指令npm install node -g全局安装 4.2.GitHub Pages的设置 这时候，你可以看到在你的Github中看到你所传上去的代码了，这时候你还需要点击设置Settings按钮，找到GitHub Pages设置你的source为master分支，点击Save存储按钮，如果你可以看到Your site is published at https://yingy0.github.io/这段提示信息，说明你可以在外网上访问你的博客了，我的博客的地址https://yingy0.github.io/， 因为每个人的name都不一样，大家就只需要改下名字就好。 5.上传博客 5.1.新建md文件 在Github中的默认文件就是md文件，至于md文件的优点我也就不啰嗦了，新建md文件的指令是hexo new &quot;postName&quot;其中postName为文件标题名称,新建的md文件默认有标题信息和创建的日期信息等，新建文件的默认路径在 F:\\Hexo\\blog\\source\\_posts 5.2.md文件的编写 md文件的写法是有一定要求的，大家就自行百度，编写完成hexo s之后就可以在本地浏览器看一下效果localhost:4000，确定没有问题之后上传到GitHub上面。 123$ hexo clean$ hexo g$ hexo d 6.换主题 6.1.下载主题 当你可以在外网上面访问你的主题时，你是不是会觉得你的网站有些许难看，不像别人的那么炫酷，当然你可做到，首先在官网上面下载一个你喜欢的主题，下载好的主题放在F:\\Hexo\\blog\\themes，现在就开始来配置吧，主题的配置文件的路径不同，不要和上面提到的配置文件搞混了. 6.2.主题的配置文件 打开主题的配置页，路径是F:\\Hexo\\blog\\themes\\cyanstyle我下载的主题是cyanstyle，每个人的喜好不同，大家自行参考，该主题的menu中默认有Home和Archives，我在我的menu菜单中添加了About。 1234menu: Home: / Archives: /archives About: /about 在不同的主题中还可以添加categories等，配置文件中只需要该个menu，其他的也不需要在动了。 6.3.设置Tags标签页 输入hexo new page tags该命令之后，在F:\\Hexo\\blog\\themes\\cyanstyle\\source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件。 6.4.设置About 输入$ hexo new page about该命令之后，在F:\\Hexo\\blog\\themes\\cyanstyle\\source下会新生成一个新的文件夹about,在该文件夹下会有一个index.md文件。 现在当你新建一个md文件时hexo new &quot;postName&quot;，就会出现tags、title、日期等，当你填上不同的标题、不同的标签页之后，浏览器会自动的为你归档。 123title: Hexo+Github搭建个人博客date: 2018-04-22 18:14:02tags: Hexo Github 在编写主题的配置文件时，一定要参考你所下载的官方主题的说明文档，不能只看着参考教程写，因为你参考的教程可能与你下载的主题不是一一对应的，这样可能会产生冲突，带来很严重的后果。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Hexo Github","slug":"Hexo-Github","permalink":"http://yoursite.com/tags/Hexo-Github/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之适配器模式","slug":"设计模式之适配器模式","date":"2018-03-30T07:12:01.000Z","updated":"2018-10-12T14:40:11.171Z","comments":true,"path":"2018/03/30/设计模式之适配器模式/","link":"","permalink":"http://yoursite.com/2018/03/30/设计模式之适配器模式/","excerpt":"","text":"适配器模式 1.1定义：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 1.2结构图图 41 目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。 源(Adapee)角色：现在需要适配的接口。 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 ① 类的适配器模式把适配的类的API转换成为目标类的API。 ② Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的。图42 ③ 类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 ④ Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 ⑤ 类适配器和对象适配器的权衡：类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式；对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓；对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法；对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源；对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee；对于对象适配器，需要额外的引用来间接得到Adaptee；建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。 ⑥ 缺省适配模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。在很多情况下，必须让一个具体类实现某一个接口，但是这个类又用不到接口所规定的所有的方法。通常的处理方法是，这个具体类要实现所有的方法，那些有用的方法要有实现，那些没有用的方法也要有空的、平庸的实现。这些空的方法是一种浪费，有时也是一种混乱。除非看过这些空方法的代码，程序员可能会以为这些方法不是空的。即便他知道其中有一些方法是空的，也不一定知道哪些方法是空的，哪些方法不是空的，除非看过这些方法的源代码或是文档。缺省适配模式可以很好的处理这一情况。可以设计一个抽象的适配器类实现接口，此抽象类要给接口所要求的每一种方法都提供一个空的方法。 图 43 ⑦ 接口AbstractService要求定义三个方法，分别是serviceOperation1()、serviceOperation2()、serviceOperation3()；而抽象适配器类ServiceAdapter则为这三种方法都提供了平庸的实现。因此，任何继承自抽象类ServiceAdapter的具体类都可以选择它所需要的方法实现，而不必理会其他的不需要的方法。 ⑧ 适配器模式的用意是要改变源的接口，以便于目标接口相容。缺省适配的用意稍有不同，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。 1.3适用场景 适用于想使用一个已经存在的类，而其接口不符合要求的情况 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 需要一个统一的输出接口，而输入端的类型不可预知。 1.4优缺点 更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 （缺点） 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 1.5实例 描述：我手中有个ps2插头的设备，但是主机上只有usb插头的插口，怎么办呢？弄个转换器，将ps2插头转换成为USB插头就可以使用了。接口Ps2：描述ps2接口格式；接口Usb：描述USB接口格式；类Usber：是接口Usb的实现类，是具体的USB接口格式；Adapter：用于将ps2接口格式转换成为USB接口格式。 1.5.1.2016A某软件系统中，已设计并实现了用于显示地址信息的类Address（如图5-1所示），现要求提供基于Dutch语言的地址信息显示接口。为了实现该要求并考虑到以后可能还会出现新的语言的接口，决定采用适配器（Adapter）模式实现该要求，得到如图44所示的类图。图44 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt; using namespace std; class Address&#123; public: void stree() &#123; /* 实现代码省略 */ &#125; void zip() &#123; /* 实现代码省略 */ &#125; void city() &#123; /* 实现代码省略 */ &#125; ∥其他成员省略 &#125;; class DutchAddress &#123; public: virtual void straat()=0; virtual void postcode()=0; virtual void plaats()=0; //其他成员省略 &#125;; class DutchAddressAdapter : public DutchAddress &#123; private: Address* address ; public: DutchAddressAdapter(Address *addr) &#123; address = addr; &#125; void straat() &#123; addr-&gt;stree() ; &#125; void postcode()&#123; addr-&gt;zip() ; &#125; void plats()&#123; addr-&gt;city(); &#125; //其他成员省略 &#125;; void testDutch(DutchAddress *addr)&#123; addr-&gt;straat(); addr-&gt;postcode(); addr-&gt;plaats(); &#125; int main()&#123; Address*addr = new Address(); DutchAddress *addr=new DutchAddressAdaptor(addr); cout&lt;&lt; \"\\n The DutchAddress\\n\"&lt;&lt; endl; testDutch(addrAdapter); return 0; &#125;； 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之访问者模式","slug":"设计模式之访问者模式","date":"2018-03-28T17:01:10.000Z","updated":"2018-10-12T14:40:49.403Z","comments":true,"path":"2018/03/29/设计模式之访问者模式/","link":"","permalink":"http://yoursite.com/2018/03/29/设计模式之访问者模式/","excerpt":"","text":"访问者模式 1.1定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 1.2结构图图45 访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。访问者模式的简略图如图46所示。 图46 数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。 抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。 具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。 抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。 具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。 结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。 ① 在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。这正是访问者模式的功能强大之处。 ② 先来看第一句话，说是一个作用于某对象结构中的各元素的操作，这里提到了三个事物，一个是对象结构，一个是各元素，一个是操作。那么我们可以这么理解，有这么一个操作，它是作用于一些元素之上的，而这些元素属于某一个对象结构。好了，最关键的第二句来了，它说使用了访问者模式之后，可以让我们在不改变各元素类的前提下定义作用于这些元素的新操作。这里面的关键点在于前半句，即不改变各元素类的前提下，在这个前提下定义新操作是访问者模式精髓中的精髓。 1.3适用场景 访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。 1.4优缺点 好的扩展性：能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 好的复用性：可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。 分离无关行为：可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。 （缺点）对象结构变化很困难：不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。 （缺点）破坏封装：访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。 1.5实例 描述：用户去访问博客,分析：用户可以通过电脑上的Web方式（访问者）或者手机Wap方式（访问者）去访问博客，每篇博客是一个元素，然后博客列表是一个对象结构类。 1.5.1 2015A 某图书管理系统中管理着两种类型的文献：图书和论文。现在要求统计所有馆藏文献的总页码（假设图书馆中有一本540页的图书和两篇各25页的论文，那么馆藏文献的总页码就是590页）。采用Visitor（访问者）模式实现该要求，得到如图47所示的类图。 图47 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class LibraryVisitor;class LibraryItemInterface&#123;public:virtual void accept(LibraryVisitor* visitor)=0;&#125;;class Article : public LibraryItemInterface &#123;private:string m_title; //论文名string m_author; //论文作者int m_start_page;int m_end_page;public:Article(string p_author, string p_title, int p_start_page,int p_end_page );int getNumber()fPages();void accept(Library Visitor* visitor);&#125;;class Book : public LibraryItemInterface &#123;private:string m_title; //书名string m_author; //作者int m_pages; //页数public:Book(string p_author, string p_title, int p_pages);int getNumber()fPages(); void accept(LibraryVisitor* visitor);&#125;;class LibraryVisitor &#123;public:virtual void visit(Book* p_book)=0; virtual void visit(Article* p_article)=0 virtual void printSum() = 0;&#125;;class LibrarySumPrintVisitor : public LibraryVisitor &#123; //打印总页数private:int sum;public:LibrarySumPrintVisitor();void visit(Book* p_book);void visit(Article* p_article);void printSum();&#125;;// visitor.cppint Article: :getNumber()fPages()&#123;retum m_end_page - m_start_page;&#125;void Article::accept(LibraryVisitor* visitor) &#123; (LibraryVisitor*)visitor‐&gt;visit(this); &#125;Book: :Book(string p_author, string p_title, int p_pages ) &#123;m_title = p_title;m_author = p_author;m_pages = p_pages;&#125;int Book::getNumberOfPages()&#123; return m_pages; &#125;void Book::accept(LibraryVisitor* visitor)&#123; (LibraryVisitor*)visitor‐&gt;visit(this);&#125; 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之观察者模式","slug":"设计模式之观察者模式","date":"2018-03-27T03:12:11.000Z","updated":"2018-10-12T14:40:43.384Z","comments":true,"path":"2018/03/27/设计模式之观察者模式/","link":"","permalink":"http://yoursite.com/2018/03/27/设计模式之观察者模式/","excerpt":"","text":"观察者模式 1.1定义：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 1.2结构图 图 25 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 ① 在观察者模式中，又分为推模型和拉模型两种方式。推模型是指主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。拉模型是指主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 ② 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 ③ 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 ④ 应用事件委托来彻底解除通知者和观察者之间的耦合。委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的。事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。 ⑤ 在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。 ⑥ 在运行时，客户端会首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的registerObserver()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。这时，客户端调用主题的update()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。 1.3适用场景 当一个对象的数据更新时需要通知其他对象，但这个对象又不希望和被通知的那些对象形成紧耦合。 当一个对象的数据更新时，这个对象需要让其他对象也各自更新自己的数据，但这个对象不知道具体有多少对象需要更新数据。 1.4优缺点 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不会依赖于具体，从而使得各自的变化都不会影响另一边的变化。 （缺点）依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。 （缺点）在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。 1.5实例： 观察者模式多用于实现订阅功能的场景，例如微博的订阅，当我们订阅了某个人的微博账号，当这个人发布了新的消息，就会通知我们。 观察者模式这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。 1.5.1.2014A某实验室欲建立一个实验室环境监测系统，能够显示实验室的温度、温度以及洁净度等环境数据，当获得到最新的环境测量数据时，显示的环境数据能够及时更新，现在采用观察者（Observer）模式来开发该系统，观察者模式的类图如图21所示。图21 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt; #include(vector)using namespace std;class Observer&#123; public: virtual void update(float temp,float humidity,float cleanness)=0;&#125;; class Subject&#123; public: virtual void registerObserver(Observer *o)=0;//注册对主题感兴趣的观察者 virtual void removeObserver(Observer *o)=0;//删除观察者 virtual void notifyObserver(Observer *o)=0//当主题变化时通知观察者 &#125;;class EnvironmentData:public Subject&#123; private: vector&lt;Observer*&gt;observers; float temperature,humidity,cleanness; public: void registerObserver(Observer *o)&#123; observers.push_back(0); &#125; void removeObserver(Observer *o)&#123; &#125; void notifyObserver&#123; for(vector&lt;Observer*&gt;::const_iterator it=observers.begin(); it!=observers.end();it++) &#123; (*it)‐&gt;update(temperature,humidity,cleanness) &#125;&#125; void measurementsChanged()&#123; notifyObservers(); &#125; void setMeasurements(float temp,float humidity,float cleanness)&#123; this-&gt;temperature=temperature; this-&gt;humidity=humidity; this-&gt;cleanness=cleanness; measurementsChanged() &#125;&#125;;class CurrentConditionDisplay:public Observer&#123; private: float temperature, humidity,cleanness Subject* envData; public: CurrentConditionDisplay&#123; this-&gt;envData=envData; this-&gt;envData-&gt;registerObserver(this); &#125; void update(float temp,float humidity,float cleanness)&#123; this-&gt;temperature=temperature; this-&gt;humidity=humidity; this-&gt;cleanness=cleanness; display(); &#125; void display()&#123; &#125;; int main()&#123; EnvironmentData *envData=new EnvironmentData(); CurrentConditionDisplay currentDisplay=new CurrentConditionDisplay(); envData-&gt;setMeasurements(80,15,30,4f); return 0; &#125; &#125;; 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之装饰器模式","slug":"设计模式之装饰器模式","date":"2018-03-25T03:12:11.000Z","updated":"2018-10-12T14:39:52.814Z","comments":true,"path":"2018/03/25/设计模式之装饰器模式/","link":"","permalink":"http://yoursite.com/2018/03/25/设计模式之装饰器模式/","excerpt":"","text":"装饰器模式 1.1定义：以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 1.2结构图 图20 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。 ① 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 ② 如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如21所示： 图21③ 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。 图 22 ④ 装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 ⑤ 实际情况中，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。 ⑥ 半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。 ⑦ 装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。 ⑧ 这个结构中最关键的是，装饰角色持有一个构件对象的实例。这样，需要装饰的实例，才能够传入到装饰器中，让装饰器对其进行装饰。同时，在多个装饰器共同装饰的情况下，还可以把前面的装饰器传入到后面的装饰器中，由最后的装饰器调用动作。因为它们实现了同样的接口，这样做是允许的。例如：对象A，需要装饰器A,B进行装饰。那么，可以把A传给装饰器A，装饰后，再把A传给装饰器B，继续装饰。也可以把A传给装饰器A之后，再把装饰器A传给装饰器B，由B完成所有的装饰动作（实际上只是调用了A的装饰动作，具体实现仍是在装饰器A当中）。 ⑨ 装饰器模式能够动态地为对象添加功能，是从一个对象外部来给对象添加功能，相当于改变了对象的外观。从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列装饰器装饰过后的对象。这样就能够灵活的改变一个对象的功能，只要动态组合的装饰器发生了改变，那么最终所得到的对象的功能就发生了改变。另一个好处是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器来装饰不同的对象。而且符合面向对象设计中的一条基本规则：”尽量使用对象组合，而不是对象继承”. 1.3适用场景 扩展一个类的功能。 动态增加功能，动态撤销。 想透明并动态地给对象增加新的职责 1.4优缺点 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 有效避免了使用继承方式扩展对象功能而带来的灵活性差，子类无限制扩展的问题 装饰者与被装饰者之间虽然都是统一类型，但是它们彼此是完全独立并可以独立任意改变的。 （缺点） 由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。 1.1实例描述： 需要根据配置文件，动态地生成一个Excel模板。模板有首页，内容页，链接页等几个页签。 假设我们现在去咖啡店要了一杯咖啡，可以加奶、加糖等等。咖啡和奶、糖分别有不同的价格。 咖啡就是我们的组件，奶和糖是我们的装饰者，现在我们要计算调制这样一杯咖啡花费多少。 如果我们要实现一个咖啡屋的订单系统，设计类时，如果要为m种咖啡（浓缩、深焙。。。）搭配的n种调料（豆浆、摩卡、糖、牛奶。。） 分别设计一个类。。简直是一个噩梦，这还没有考虑可能的新的需求变动。 1.1.1.2012A 某咖啡店卖咖啡时，可以根据顾客的要求在其中加入各种配料，咖啡店会根据所加入的配料来计算费用。咖啡店所供应的咖啡及配料的种类和价格如表3所示。 表3 咖啡及配料的种类和价格 图23 1234567891011121314151617181920212223242526272829303132333435363738#include ＜iostream＞#include ＜string＞using namespace std;consr int ESPRESSO_PRICE = 21;const int DRAKROAST_PRICE = 20;const int MOCHA_PRICE = 10;const int WHIP_PRICE = 8;class Beverage &#123; //饮料 protected: string description; public: virtual string getDescription() &#123;return description;&#125; virtual int cost()=0;&#125;;class CondimentDecorator: public Beverage &#123; //配料 protected:Beverage*beverage;&#125;;class Espresso: public Beverage &#123; //蒸馏咖啡 public: Espresso () &#123; description=\"Espresso\"; &#125; int cost () &#123; return ESPRESSO_PRICE; &#125;&#125;;class DarkRoast: public Beverage &#123; //深度烘培咖啡 public: DarkRoast() &#123; description = \"DardRoast\"; &#125; int cost()&#123; return DRAKROAST_PRICE; &#125;&#125;;class Mocha: public CondimentDecorator &#123; //摩卡 public: Mocha (Beverage*beverage) &#123; this-＞beverage=beverage; &#125; string getDescription()&#123; return beverage-＞getDescription()+\",Mocha\"; &#125; int cost()&#123; return MOCHA_PRICE+beverage-＞cost(); &#125;&#125;;class Whip: public CondimentDecorator &#123; //奶泡 public: Whip (Beverage*beverage) &#123; this-＞beverage=beverage; &#125; string getDescription() &#123; return beverage-＞getDescription()+\",Whip\"; &#125; int cost()&#123; return WHIP_PRICE+beverage-＞cost(); &#125;int main()&#123; Beverage* beverage = new DarkRoast() ; beverage=new Mocha(beverage) ; beverage=new Whip (beverage) ; cout＜＜beverage-＞getDescription()＜＜\"￥\"＜＜beverage-＞cost() end1; return 0;&#125; 1.1.2.2016B某发票（lnvoice）由抬头（Head）部分、正文部分和脚注（Foot）部分构成。现采用装饰（ Decorator）模式实现打印发票的功能，得到如图24所示的类图。 图24 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std；class invoice&#123;public： virtual void printinvoice()&#123; cout《 \"This is the content of the invoice!\"《 endl; &#125;&#125;;class Decorator : public invoice &#123; Invoice *ticket;public: Decorator（lnvoice *t） &#123; ticket = t; &#125; void printinvoice()&#123; if（ticket != NULL） ticket-&gt;printInvoice(); &#125;&#125;;class HeadDecorator : public Decorator&#123;public: HeadDecorator（lnvoice*t）: Decorator（t） &#123; &#125; void printinvoice() &#123; cout《 \"This is the header of the invoice! \"&lt;&lt; endl; Decorator::printInvoice(); &#125;&#125;； class FootDecorator : public Decorator&#123;public: FootDecorator（invoice *t）: Decorator（t） &#123; &#125; void printlnvoice（） &#123; Decorator::printInvoice(); cout《 \"This is the footnote of the invoice!\"《 endl; &#125;&#125;;int main（void） &#123; Invoice t; FootDecorator f（&amp;t）; HeadDecorator h（&amp;f）; H.printlnvoice（）; cout&lt; &lt; “_____”&lt; &lt; endl; FootDecorator a(NULL); HeadDecorator b((&amp;a)); B．printinvoice(); return 0;&#125;； 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之组合模式","slug":"设计模式之组合模式","date":"2018-03-23T07:12:11.000Z","updated":"2018-10-12T14:42:27.064Z","comments":true,"path":"2018/03/23/设计模式之组合模式/","link":"","permalink":"http://yoursite.com/2018/03/23/设计模式之组合模式/","excerpt":"","text":"组合模式 1.1定义：组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 1.2结构图： 图1 Client：通过 Component 接口操作结构中的对象。 Component:组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 Component 的子部件。 Composite:定义枝节点行为，用来存储子部件，在 Component 接口中实现与子部件相关的操作。 Leaf:表示叶节点对象。叶子节点没有子节点。 ① 组合模式它描述了如何构造一个类层次结构，这一结构由两种类型的对象所对应的类构成，其中的组合对象使得用户可以组合基元以及其他的组合对象，从而形成任意复杂的结构。 ② 组合模式对单个对象(Leaf)和组合对象(Compostie)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(Leaf)和复杂元素(Composite)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。 ③ 从模式结构中我们看出了叶子节点和容器对象都实现Component接口，这也是能够将叶子对象和容器对象一致对待的关键所在。 ④ 组合模式必须满足叶子对象和组合对象实现相同的接口 1.3适用场景 想要表示对象的部分-整体层次结构，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。 让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。 1.4优缺点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。 客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。 更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。 （缺点）使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联 1.5实例 说明：在文件系统中，可能存在很多不同目录的文件，C盘、D盘、E盘、F盘等等，这些不同的目录文件的打开方式不同，同时对文件夹的浏览就是对文件夹中文件的浏览，但是对于客户而言都是浏览文件，两者之间不存在什么差别。 1.5.1.2009B 现欲构造一文件/目录树，采用组合(Composite)设计模式来设计，得到的类图下图所示： 图2 1234567891011121314151617181920212223242526272829303132333435363738 class AbstractFile &#123; protected： string name； //文件或目录名称 public： void printName()&#123;cout＜＜name;＞ //打印文件或目录名称 virtual void addChild(AbstractFile *file)=0； //给一个目录增加子目录或文件 virtual void removeChild(AbstractFile*file)=0； //删除一个目录的子目录或文件 virtual list＜AbstractFile*＞*getChildren()=0； //获得一个目录的子目录或文件&#125;； class File：public AbstractFile&#123; public： File(string name) &#123;this.name=name；&#125; void addChild(AbstractFile*file) &#123;return； &#125; void removeChild(AbstractFile*file) &#123;return； &#125; list＜AbstractFile*＞*getChildren() &#123;return null；&#125;&#125;； class Folder：public AbstractFile&#123; private： list＜AbstractFile*＞childList； //存储子目录或文件 public： Folder(string name)&#123;this.name=name；&#125; void addChild(AbstractFile*file)&#123;childList.push_back(file)；&#125; void removeChild(AbstractFile*file) &#123;childList.remove(file)；&#125; list＜AbstractFile*＞*getChildren()&#123;return &amp;childList；&#125;&#125;； void main()&#123; //构造一个树形的文件/目录结构 AbstractFile*rootFolder=new Folder(\"c:＼＼\")； AbstractFile*compositeFolder=new Folder(\"compositel\")； AbstractFile*windw File(\"TestComposite.java\")； rootFolder-＞addChildowsFolder=new Folder(\"windows\")； AbstractFile*file=ne(compositeFolder)； rootFolder-＞addChild(windowsFolder)； compositeFolder-＞addChild(file)；&#125; 1.5.2.2010B 某公司的组织结构图如图3所示，现采用组合(Composition)设计模式来构造该公司的组织结构，得到如图4所示的类图。其中Company为抽象类，定义了在组织结构图上添加(Add)和删除(Delete)分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部。 图3 图4 12345678910111213141516171819202122232425262728293031323334353637 class Company &#123; //抽象类 protected: string name; public: Company(string name) &#123;this.name=name;&#125; virtual void Add(Company* children)=0; //增加子公司、办事处或部门 virtual void Delete (Company* children)=0;//删除子公司办事处或部门&#125;; class ConcreteCompany: public Company &#123; private: list＜ Company*＞children; //存储子公司、办事处或部门 public: ConcreteCompany(string name):Company(name) &#123;&#125; void Add(Company* children) &#123; children. push_back(c); &#125; void Delete(Company* children) &#123; children. remove(c); &#125;&#125;; class HRDepartment : public Company &#123; public: HRDepartment(string name): Company(name) &#123;&#125; //其他代码省略&#125;; class FinanceDepartment: public Company &#123; public: FinanceDepartment(string name): Company(name) &#123;&#125; //其他代码省略&#125;; void main()&#123; ConcreteCompany *root=new ConcreteCompany(\"北京总公司\"); root-＞Add(new HRDepartment(\"总公司人力资源部\")); root-＞Add(new FinanceDepartment(\"总公司财务部\")); ConcreteCompany *comp=new ConcreteCompany(\"上海分公司\"); comp-＞Add(new HRDepartment(\"上海分公司人力资源部\")); comp-＞Add(new FinanceDepartment(\"上海分公司财务部\")); root-&gt;Add(comp) ; ConcreteCompany *comp1=new ConcreteCompany(\"南京办事处\"); comp1-＞Add(new HRDepartment(\"南京办事处人力资源部\")); comp1-＞Add(new FinanceDepartment(\"南京办事处财务部\")); comp-&gt;Add(comp1) ; &#125; 1.5.3.2011A 某饭店在不同的时段提供多种不同的餐饮，其菜单的结构图如图5所示。 图5 现在采用组合(Composition)模式来构造该饭店的菜单，使得饭店可以方便地在其中增加新的餐饮形式，得到如图6所示的类图。其中MenuComponent为抽象类，定义了添加(add)新菜单和打印饭店所有菜单信息(print)的方法接口。类Menu表示饭店提供的每种餐饮形式的菜单，如煎饼屋菜单、咖啡屋菜单等。每种菜单中都可以添加子菜单，例如图5中的甜点菜单。类MenuItem表示菜单中的菜式。 图6 12345678910111213141516171819202122232425262728293031323334353637 class MenuComponent &#123; protected: string name; public: MenuComponent(string name) &#123;this-＞name=name; &#125; String getName()&#123;return name;&#125; virtual void add(MenuComponent* menuComponent)=0//添加新菜单 virtual void print()=0; //打印菜单信息&#125;; class MenuItem: public MenuComponent &#123; private: double price; public: Menultem(string name, double price): MenuComponent(name)&#123;this-＞price=price;&#125; double getPrice()&#123;return price;&#125; void add(MenuComponent* menuComponent) &#123;return; &#125; //添加新菜单 void print() &#123; cout＜＜\" \"＜＜getName()＜＜\", \"＜＜getPrice()＜＜end1;&#125;&#125;; class Menu: public MenuComponent &#123; private: list＜MenuComponent*＞ menuComponents; pubiic: Menu(string name): MenuC0mponent(name)&#123;&#125; void add(MenuComponent* menuComponent) //添加新菜单 &#123; menuComponents.add(menuComponent); &#125; void print()&#123; cout＜＜\"\\n\"＜＜getName()＜＜\"\\n-------------------------\"＜＜end1; std::list＜MenuC0mponent*＞::iterator iter; for(iter=menuComponents.begin(); iter!=menuComponents. end(); iter++) (*iter)-＞print(); &#125;&#125;; void main()&#123; MenuComponent* allMenus=new Menu(\"ALL MENUS\"); MenuComponent* dinerMenu=new Menu(\"DINER MENU\"); …//创建更多的Menu对象，此处代码省略 allMenus-＞add(dinerMenu); //将dinerMenu添加到餐厅菜单中 …//为餐厅增加更多的菜单，此处代码省略 allMenus-＞print(); //打印饭店所有菜单的信息 &#125; 1.6 总结 组合模式定义由Leaf对象和Compostie对象组成的类结构。 组合模式使得客户端变得简单。 组合模式使得添加或删除子部件变得很容易。 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之策略模式","slug":"设计模式之策略模式","date":"2018-03-21T04:12:11.000Z","updated":"2018-10-12T14:41:10.806Z","comments":true,"path":"2018/03/21/设计模式之策略模式/","link":"","permalink":"http://yoursite.com/2018/03/21/设计模式之策略模式/","excerpt":"","text":"策略模式 1.1定义：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 1.2结构图 图15 环境(Context)角色：持有一个Strategy的引用。 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 ① 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换” ② 策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 ③ 策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。策略算法是相同行为的不同实现。 图16 ④ 算法的平等性强调的是可替换性，大家是同一行为的不同描述或实现，运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。 ⑤ 经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口，典型的将代码向继承等级结构的上方集中的标准做法。 图17 ⑥ 策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由用户决定的。 1.3适用场景 多个类只区别在表现行为不同，可以使用Strategy模式在运行时动态选择具体要执行的行为 需要在不同的情况下使用不同的策略（算法）,或者策略（算法）还可能在未来用其他方式来实现 对客户隐藏具体策略（算法）的实现细节，彼此完全独立。 1.1优缺点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 （缺点）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 （缺点）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。 1.5实例 描述：假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。根据描述，折扣是根据以下的几个算法中的一个进行的：算法一：对初级会员没有折扣。算法二：对中级会员提供10%的促销折扣。算法三：对高级会员提供20%的促销折扣。 1.5.1.2010A 某软件公司现欲开发一款飞机飞行模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征。需要模拟的飞机种类及其特征如表2所示. 为支持将来模拟更多种类的飞机，采用策略设计模式(strategy)设计的类图如图18所示。 在图中，AirCraft为抽象类，描述了抽象的飞机，而类Helicopter、AirPlane、Fighter和Harrier分别描述具体的飞机种类，方法fly31和takeOff31分别表示不同飞机都具有飞行特征和起飞特征；类FlyBehavior与TakeOffBehavior为抽象类，分别用于表示抽象的飞行行为与起飞行为；类SubSonicFly与SuperSonicFly分别描述亚音速飞行和超音速飞行的行为；类VerticalTakeOff与LongDistanceTakeOff分别描述垂直起飞与长距离起飞的行为。 图18 1234567891011121314151617181920212223242526272829303132333435363738class FlyBehaVior &#123; public: virtual void fly()=0; &#125;; class SubSonicFly: public FlyBehaVior&#123; public: void fly()&#123;cout＜＜\"亚音速飞行!\"＜＜endl;) &#125;; class SupersonicFly: public FlyBehaVior&#123; public: void fly()&#123;cout＜＜\"超音速飞行!\"＜＜endl;) &#125;; class TakeOffBehavior&#123; publie: virtual void takeOff()=0; &#125;; class VerticalTakeOff: public TakeOffBehavior&#123; public: void takeOff()&#123;cout＜＜\"垂直起飞!\"＜＜endl' &#125; &#125;; class LongDistanceTakeOff: public TakeOffBehavior&#123; public: void takeOff()&#123;cout＜＜\"长距离起飞!\"＜＜endl;&#125; &#125;; class AirCraft&#123; protected: FlyBehaVior *flyBehaVior; TakeOffBehavior *takeoffBehavior; public: void fly()&#123; flyBehaVior-&gt;fly(); &#125; void takeoff() &#123;takeoffBehavior-&gt; takeoff(); &#125;; &#125;; class Helicopter: public AirCraft &#123; public: Helicopter ()&#123; flyBehavior=new SubSonicFly() ; takeoffBehavior=new VerticalTakeOff() ; &#125; &lt;!--C++中的\"~\"符号代表析构函数，--&gt; ~Helicopter&#123; if(!flyBehaVior) delete flyBehaVior(); if(!takeoffBehavior) delete takeoffBehaVior; &#125; &#125;; 1.5.2.2015 某大型购物中心欲开发一套收银软件，要求其能够支持购物中心在不同时期推出的各种促销活动，如打折、返利（例如，满3 00返1 00）等等。现采用策略( Strategy)模式实现该要求，得到如图19所示的类图。 图19 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; Using namespace std; enum TYPE&#123;NORMAL, CASH_DISCOUNT, CASH_RETURN&#125;; class CashSuper&#123; public: virtual double acceptCash(double money)=0；&#125;; class CashNormal : public CashSuper &#123; ／／正常收费子类 public: double acceptCash(double money) &#123; retum money; &#125; &#125;; class CashDiscount : public CashSuper &#123; private: double moneyDiscount; // 折扣率public: CashDiscount(double discount) &#123; moneyDiscount= discount; &#125; double acceptCash(double money) &#123; retum money * moneyDiscount; &#125; &#125;; class CashRetum : public CashSuper &#123; // 满额返利private: double moneyCondition; // 满额数额 double moneyReturn; // 返利数额public: CashRetnm(double;m otieyCondition, double moneyReturn) &#123; this=&gt;moneyCondition - moneyCondition; this=&gt;m oneyRetumF moneyRetum; &#125; . double acceptCash(double money) &#123; double result = money; if(money＞=moneyCondition) result = money - (int)(money moneyCondition ) * moneyRetum; Return result &#125; &#125;; class CashContext &#123; private: CashSuper *cs; public: CashContext(inttype) &#123; switch(type) &#123; case NORMAL: ／／正常收费 cs-&gt;new CashNormal(); case RETURN ／／满300返100 cs-&gt;new CashRetum(); Break; case CASH DISCOUNT: ／／打八折 cs-&gt;new CashDiscount(); break; &#125; &#125; double GetResult(double money) &#123; return cs-&gt;acceptCash(money); &#125; &#125;； 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之生成器模式","slug":"设计模式之生成器模式","date":"2018-03-19T02:12:11.000Z","updated":"2018-10-12T14:40:17.448Z","comments":true,"path":"2018/03/19/设计模式之生成器模式/","link":"","permalink":"http://yoursite.com/2018/03/19/设计模式之生成器模式/","excerpt":"","text":"生成器模式 1.1定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。1.2结构图图 29 Builder：为创建一个Product对象的各个部件指定抽象接口 ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件；定义并明确它所创建的表示；提供一个检索产品的接口。 Director：构造一个使用Builder接口的对象 Product：表示被构造的复杂对象。 ConcreteBuilder创建该产品的内部表示并定义它的装配过程；包含定义组成部件的类，包括将这些部件装配成最终产品的接口 ① 当系统准备为用户提供一个内部结构复杂的对象时，使用生成器模式，使用该模式可以逐步地构造对象，使得对象的创建更具有弹性。 ② 生成器模式的关键是将一个包含有多个组件对象的创建分为若干个步骤，并将这些步骤封装在一个称为生成器的接口中。③ 生成器模式的重心还是在于分离整体构建算法与子部件的构建，分步骤构建对象只不过是整体构建算法的一个简单表现，或者说是一个附带产物。 ④ 生成器模式的本质：分离整体构建算法和部件构造。 ⑤ 虽然在生成器模式的整体构建算法中，会一步一步引导Builder来构建对象，但这并不是说生成器主要就是用来实现分步骤构建对象的。生成器模式的重心还是在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单表现，或者说是一个附带产物。 ⑥ “将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示”。有这么几个关键点：对象比较复杂，内部可能包含多个元素或者多个其他对象的组合；对象的表示可能有多种，并且有需求在多种表示中进行切换；使用同样的构造过程来创建可能的不同表示。 1.3适用场景 当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式； 当构造过程必须允许构造的对象有不同的表示； 需要创建的复杂对象内部的各个子部分有一定的关联性或者依赖性，这样在可以通过生成器来强迫生成一定的创建和组装顺序 1.4优缺点 松散耦合：生成器模式可以用同一个构建算法构建出表现上完全不同的产品，实现产品构建和产品表现的分离。正是将产品的构建过程独立开来，才使得生成器模式与具体产品的表现松散耦合，从而使得构建算法可以复用，而具体产品表现也可以灵活地、方便地扩展和切换。 可以很容易地改变产品的内部表示：在生成器模式中，由于指导者只是通过Builder来构建具体产品，但是具体产品中的各个子部件的创建和装配方式却被builder接口隐藏起来，Director并不清楚这些具体实现细节。也正是因为这样，需要改变产品的内部表象时，我们只需要切换不同的Builder实现对象即可，而Director角色无需作出任何的改变。 复用性更好：生成器模式分离了构建算法和具体产品实现，这样使得“稳定”的构建算法可以达到复用的效果，同样的效果，具体产品的子部件的实现亦可以复用，一个相同的子部件实现可以配合不同的构建算法来使用。 （缺点） 1.5实例描述： 造一艘船”这个事件中，复杂对象指的是不同种类“船”，“船”的内部可能包括其他对象：“鱼雷”、“飞机”等；“船”有多种表示；相同的构建过程则是描述“造船”这个事件的抽象过程，隐藏具体的构造细节，这样才能通过相同的构造过程得到不同的“船”的表示。 快餐店制作儿童餐。典型的儿童餐包括一个主食，一个辅食，一杯饮料和一个玩具（例如汉堡、炸鸡、可乐和玩具车）。这些在不同的儿童餐中可以是不同的，但是组合成儿童餐的过程是相同的（这是关键点）。无论顾客点的是汉堡，三名治还是鸡肉，过程都是一样的。柜台的员工直接把主食，辅食和玩具放在一起。这些是放在一个袋子中的。饮料被倒入杯中，放在袋子外边。这些过程在相互竞争的餐馆中是同样的。在这样一种场景中，主食、辅食、饮料和玩具根据所选择的套餐种类的不同而不同，但是不管何种套餐，都具有这几大部分。 1.5.1. 2017A某快餐厅主要制作并出售儿童套餐，一般包括主餐(各类比萨)、饮料和玩具，其餐品种类可能不同，但其制作过程相同。前台服务员(Waiter)调度厨师制作套餐。现采用生成器(Builder) 模式实现制作过程，得到如图30所示的类图。 图30 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;class Pizza &#123; private: string parts; public: void setParts(string parts) &#123; this-&gt;parts=parts; &#125; string getParts() &#123; return parts; &#125; &#125;;class PizzaBuilder &#123; protected:Pizza* pizza; public: Pizza* getPizza() &#123; retum pizza; &#125; void createNewPizza() &#123; pizza = new Pizza(); &#125; virtual void buildParts();&#125;class HawaiianPizzaBuilder :public PizzaBuilder &#123; public: void buildParts() &#123; pizza-&gt;setParts(\"cross +mild + ham&amp;pineapple\"); &#125;&#125;class SpicyPizzaBuider: public PizzaBuilder &#123; public: void buildParts() &#123; pizza-&gt;setParts(\"pan baked +hot + ham&amp;pineapple\"); &#125;&#125;Class Waiter&#123; Private: PizzaBuilder* pizzaBuilder; public: void setPizzaBuilder(PizzaBuilder* pizzaBuilder) &#123; /*设置构建器*/ this-&gt;pizzaBuilder=pizzaBuilder;&#125;Pizza* getPizza() &#123; return pizzaBuilder-&gt;getPizza(); &#125; void construct() &#123; /*构建*/ pizzaBuilder-&gt;createNewPizza(); pizzaBuilder-&gt;builderParts(); &#125;&#125;;int main()&#123; Waiter*waiter=new Waiter(); PizzaBuilder*hawaiian pizzabuilder=new HawaiianPizzaBuilder() waiter-&gt;setPizzaBuilder(hawaiian_pizzabuilder); waiter-&gt;construct(); cout&lt;&lt; \"pizza: \"&lt;&lt; waiter-&gt;getPizza()-&gt;getParts()&lt;&lt; endl;&#125;; 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之状态模式","slug":"设计模式之状态模式","date":"2018-03-17T11:12:11.000Z","updated":"2018-10-12T14:39:26.721Z","comments":true,"path":"2018/03/17/设计模式之状态模式/","link":"","permalink":"http://yoursite.com/2018/03/17/设计模式之状态模式/","excerpt":"","text":"状态模式 1.1定义：状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样 1.2结构图图 37 环境(Context)角色，也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。 抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。 具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。 ① 状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。 ② 状态模式主要解决的是控制一个对象转换的条件表达式过于复杂的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 ③ 状态和行为，所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。 ④ 状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。 ⑤ 行为的平行性，注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。图 38 ⑥ 在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 ⑦ 在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。 ⑧ 客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。 1.3适用场景 if else(或switch case)语句，且这些分支依赖于该对象的状态。 1.4优缺点 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 枚举可能的状态，在枚举状态之前需要确定状态种类。 封装了转换规则 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 （缺点） 状态模式的使用必然会增加系统类和对象的个数。 （缺点）状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 （缺点）状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 1.5实例 描述： 就绪状态-阻塞状态-运行状态-挂起状态-激活状态 按钮来控制一个电梯的状态，一个电梯开们，关门，停，运行。每一种状态改变，都有可能要根据其他状态来更新处理。例如，开门状体，你不能在运行的时候开门，而是在电梯定下后才能开门。门敞状态—按了电梯上下按钮，电梯门开，这中间有5 秒的时间（当然你也可以用身体挡住电梯门，那就不是5 秒了），那就是门敞状态；在这个状态下电梯只能做的动作是关门动作；门闭状态—电梯门关闭了，在这个状态下，可以进行的动作是：开门（我不想坐电梯了）、停止（忘记按路层号了）、运行；运行状态—电梯正在跑，上下窜，在这个状态下，电梯只能做的是停止；停止状态—电梯停止不动，在这个状态下，电梯有两个可选动作：继续运行和开门动作； 我们给一部手机打电话，就可能出现这几种情况：用户开机，用户关机，用户欠费停机，用户消户等。 所以当我们拨打这个号码的时候：系统就要判断，该用户是否在开机且不忙状态，又或者是关机，欠费等状态。但不管是那种状态我们都应给出对应的处理操作。 1.5.1.2011B 某大型商场内安装了多个简易的纸巾售卖机，自动出售2元钱一包的纸巾，且每次仅售出一包纸巾。纸巾售卖机的状态图如图39所示。图39 采用状态(State)模式来实现该纸巾售卖机，得到如图39所示的类图。其中类State为抽象类，定义了投币、退币、出纸巾等方法接口。类SoldState、SoldOutState、NoQuarterState和HasQuarterState分别对应图40中纸巾售卖机的4种状态：售出纸巾、纸巾售完、没有投币、有2元钱。图40 12345678910111213141516171819202122232425262728293031323334353637383940414243#include ＜iostream＞ using namespace std; //以下为类的定义部分 class TissueMachine; //类的提前引用 class State &#123; public： virtual void insertQuarter()=0; //投币 virtual void ejectQuarter()=0; //退币 virtual void turnCrank()=0; //按下“出纸巾”按钮 virtual void dispense()=0; //出纸巾 &#125;; /*类SoldOutState、NoQuarterState、HasQuarterState、SoldState的定义省略， 每个类中均定义了私有数据成员TissueMachine* tissueMachine;*/ class TissueMachine &#123; private： State *soldOutState, *noQuarterState, *hasQuarterState,*soldState, *state; int count; //纸巾数 public： TissueMachine (int numbers); void setState (State* state); State* getHasQuarterState(); State* getNoQuarterState(); State* getSoldState(); State* getSoldOutState(); int getCount(); //其余代码省略 &#125;; //以下为类的实现部分 void NoQuarterState ::insertQuarter()&#123; tissueMachine-＞setState(tissueMachine-&gt;getHasQuarterState()); &#125; void HasQuarterState ::ejectQuarter()&#123; tissueMachine-＞setState(tissueMachine-&gt;getNoQuarterState()); &#125; void SoldState ::dispense()&#123; if (tissueMachine-＞getCount()＞0) &#123; tissueMachine-＞setState(tissueMachine-&gt;getNoQuarterState()); &#125; else &#123; tissueMachine-＞setState(tissueMachine-&gt;getSoldOutState()); &#125; &#125; //其余代码省略 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之模板方法模式","slug":"设计模式之模板方法模式","date":"2018-03-15T03:12:11.000Z","updated":"2018-10-12T14:40:28.999Z","comments":true,"path":"2018/03/15/设计模式之模板方法模式/","link":"","permalink":"http://yoursite.com/2018/03/15/设计模式之模板方法模式/","excerpt":"","text":"模板方法模式 1.1定义：模板方法定义了一个操作中的算法的骨架，而将一些特定步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 1.2结构图图 21 抽象模板(Abstract Template)角色有如下责任：定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任：实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑 ① 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)。 ② 模板方法中的方法可以分为两大类：模板方法和基本方法。 ③ 模板方法：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 ④ 基本方法：基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 ⑤ 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。将主要的方法定义为final，防止子类修改算法骨架，将子类必须实现的方法定义为abstract。而普通的方法（无final或abstract修饰）则称之为钩子。 ⑥ 钩子作用：作为可选内容，子类可以重写或者置之不理，让子类有机会对模板方法中即将发生的或者已经发生的步骤做出反应，作为控制条件，使得子类可以影响到抽象类中的算法流程 ⑦ 关联：在模板方法中，首先父类会定义一个算法的框架，即实现算法所必须的所有方法，共性代码放在父类的具体方法中，各个子类特殊性的代码放在子类的具体声明中，但是父类中要有对应抽象方法声明，钩子方法可以让子类决定是否对算法的不同点挂钩。 1.3适用场景 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。即“重分解以一般化”，首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“Hook Method（钩子方法）”操作，这样就只允许在这些点进行扩展。 1.4优缺点: 模板方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。 模板方法模式导致一种反向的控制结构，这种结构有时被称为“好莱坞法则” ，即“别找我们，,我们找你”通过一个父类调用其子类的操作(而不是相反的子类调用父类)，通过对子类的扩展增加新的行为，符合“开闭原则” （缺点）每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。 1.5实例 描述： 考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。 工厂发工资 ：工厂名称和工资发放时间是一定的，可以在抽象类（基类）中完成，员工的姓名、实发工资等可以放在子类中完成，只需添加各个员工的走子类就可以了。 1.5.1.2008B 已知某类库开发商提供了一套类库，类库中定义了Application类和Document类，它们之间的关系如下图所示。其中，Application类表示应用程序自身，而Document类则表示应用程序打开的文档。Application类负责打开一个已有的以外部形式存储的文档，如一个文件，一旦从该文件中读出信息后，它就由一个Document对象表示。当开发一个具体的应用程序时，开发者需要分别创建自己的Application和Document子类， 图28例如上图中的类MyApplication和类MyDocument，并分别实现Application和Document类中的某些方法。已知Application类中的openDocument方法采用了模板方法(Template Method)设计模式，该方法定义了打开文档的每一个主要步骤。 首先检查文档是否能够被打开，若不能打开，则给出出错信息并返回；创建文档对象；通过文档对象打开文档；通过文档对象读取文档信息；将文档对象加入到Application的文档对象集合中。 12345678910111213141516171819202122232425262728293031323334#include＜iostream＞#include＜vector＞using namespace std；class Document&#123;public： void save()&#123;/*存储文档数据，此处代码省略*/) void open(string docName)&#123; /*打开文档，此处代码省略*/) void close()&#123; /*关闭文档，此处代码省略*/) virtual void read(string docName) ＝0；&#125;；class Appplication&#123;private： vector＜Document *＞ docs； /*文档对象集合*/public： bool canOpenDocument(string docName)&#123; /*判断是否可以打开指定文档，返回真值时表示可以打开， 返回假值表示不可打开，此处代码省略*/ &#125; void addDocument(Document * aDocument)&#123; /*将文档对象添加到文档对象集合中*/ docs.push_back(aDocument)； &#125; virtual Document * doCreateDocument()＝0；/*创建一个文档对象*/ void openDocument(string docName)&#123;/*打开文档*/ if (!canOpenDocument(docName)&#123; cout＜＜“文档无法打开!”＜＜endl； return; &#125; Document *adoc＝doCreateDocument() ; adoc-&gt;open(docName) ; adoc-&gt;read(docName); addDocument(adoc); &#125;&#125;; 1.6 总结 使用模板方法模式，可以将代码的公共行为提取，以达到复用的目的 对于特殊化的行为在子类中实现，父类的模板方法可以控制子类中的具体实现 子类无需了解整体算法框架，只需实现自己的业务逻辑即可。 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之桥接模式","slug":"设计模式之桥接模式","date":"2018-03-11T07:01:11.000Z","updated":"2018-10-12T14:42:43.143Z","comments":true,"path":"2018/03/11/设计模式之桥接模式/","link":"","permalink":"http://yoursite.com/2018/03/11/设计模式之桥接模式/","excerpt":"","text":"桥接模式 1.1定义：将抽象部分与它的实现部分分离开来，使他们都可以独立变化。 1.1结构图 图7 Abstraction：抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。 RefinedAbstraction：扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。 Implementor：定义实现部分的接口，这个接口不用和Abstraction里面的方法一致，通常是由Implementor接口提供基本的操作，而Abstraction里面定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的较高层次的操作。 ConcreteImplementor：真正实现Implementor接口的对象。 ① 所谓桥接，通俗点说就是在不同的东西之间搭一个桥，让他们能够连接起来，可以相互通讯和使用。那么在桥接模式中到底是给什么东西来搭桥呢？就是为被分离了的抽象部分和实现部分来搭桥。 ② 在桥接模式中的桥接是单向的，也就是只能是抽象部分的对象去使用具体实现部分的对象，而不能反过来。 ③ 桥接模式的意图：使得抽象和实现可以独立变化，都可以分别扩充。也就是说抽象部分和实现部分是一种非常松散的关系，从某个角度来讲，抽象部分和实现部分是可以完全分开的，独立的，那抽象和实现为何还要组合在一起呢？原因是在抽象部分和实现部分还是存在内部联系的，抽象部分的实现通常是需要调用实现部分的功能来实现的。 ④ 桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。 实现化：针对抽象化给出的具体实现。它和抽象化是一个互逆的过程，实现化是对抽象化事物的进一步具体化。 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。 抽象化：将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程。在面向对象就是将对象共同的性质抽取出去而形成类的过程。 ⑤ 桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。 ⑥ 桥接模式的主要目的是将一个对象的变化因素抽象出来，不是通过类继承的方式来满足这个因素的变化，而是通过对象组合的方式来依赖因素的抽象，这样当依赖的因素的具体实现发生后，而我们的具体的引用却不用发生变化，因为我们的对象是依赖于抽象的，而不是具体的实现 1.3适用场景 想避免在抽象及实现之间存在永久的绑定 抽象及其实现可以使用子类扩展， 抽象的实现改动应该对客户端没有影响 1.4优缺点 分离抽象接口及其实现部分。提高了比继承更好的解决方案。 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 实现细节对客户透明，可以对用户隐藏实现细节。 （缺点）桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程 （缺点）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。 1.5实例 说明：有两个纬度的变化，一个纬度是抽象的消息这边，包括普通消息、加急消息和特急消息，这几个抽象的消息本身就具有一定的关系，加急消息和特急消息会扩展普通消息；另一个纬度在具体的消息发送方式上，包括站内短消息、Email和手机短信息，这几个方式是平等的，可被切换的方式。这两个纬度一共可以组合出9种不同的可能性来。 图8 存在的问题：消息的抽象和实现是混杂在一起的，势必会引起一个纬度的变化，会引起另一个纬度进行相应的变化，从而使得程序扩展起来非常困难。 解决办法：就必须把这两个纬度分开，也就是将抽象部分和实现部分分开，让它们相互独立。 1.5.1.2009A 现欲实现一个图像浏览系统，要求该系统能够显示BMP、3PEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和 GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，采用桥接(Bridge)设计模式进行设计，所得类图如图9所示。 图9 采用该设计模式的原因在于：系统解析BMP、GIF与JPEG文件的代码仅与文件格式相关，而在屏幕上显示像素矩阵的代码则仅与操作系统相关。 1234567891011121314151617181920212223242526272829303132333435363738394041 class Matrix&#123; // 各种格式的文件最终都被转化为像素矩阵 &#125;； class Imagelmp&#123; public： virtual void doPaint (Matrix m)=0； // 显示像素矩阵m &#125;； class WinImp ：public ImageImp&#123; public： void doPaint (Matrix m) &#123; /*调用Windows系统的绘制函数绘制像素矩阵*/) &#125;； class LinuxImp : public ImageImp&#123; public: void doPaint(Matrix m) &#123; /*调用 Linux系统的绘制函数绘制像素矩阵*/ &#125; &#125;; class Image &#123; public: void setImp (Image Imp *imp)&#123;this.imp = imp;&#125; virtual void parseFile(string file Name)=0; protected:ImageImp; &#125;; class BMP : public Image&#123; public: void parse File(string fileName) &#123; // 此处解析BMP文件并获得一个像素矩阵对象m imp-&gt;doPaint (fileName);// 显示像素矩阵m &#125; &#125;; class GIF : public Image&#123; // 此处代码省略 &#125;; class JPEG : public Image&#123; // 此处代码省略 &#125;; void main()&#123; //在Windows操作系统上查看demo. bmp图像文件 Image *imagel = new BMP(); ImageImp *imageImpl = new WinImp(); imagel-＞setImp(imageImpl) ; imagel-＞parseFile(\"demo.bmp\")； &#125;//现假设该系统需要支持10种格式的图像文件和5种操作系统，不考虑类Matrix，若采用桥接设计模式则至少需要设计17个类 1.5.1.2013B 欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。以绘制直线和圆形为例，对应的绘图程序如表1所示。 表1 该绘图软件的扩展性要求，将不断扩充新的图形和新的绘图程序。 为了避免出现类爆炸的情况，先采取桥接（Bridge）模式来实现上述要求，得到如图10所示的类图。 图10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class DP1&#123;public:static void draw_aline(double x1,double y1,double x1,double y1)&#123;/*代码省略*/&#125;static void draw_a_circle(double x,double y,double r)&#123;/*代码省略*/&#125;&#125;;class DP1&#123;public:static void drawline(double x1,double x1,double y1,double y1)&#123;/*代码省略*/&#125;static void drawcircle(double x,double y,double r)&#123;/*代码省略*/&#125;&#125;;class Drawing&#123;public:virtual void drawLine(double x1,double y1,double x1,double y1);virtual void drawCircle(double x,double y,double r);&#125;;class V1Drawing:public Drawing&#123;public:void drawLine(double x1,double y1,double x1,double y1)&#123;/*代码省略*/&#125;void drawCircle(double x,double y,double r)&#123; DP1::V1Drawing(x,y,r);&#125;&#125;;class V1Drawing:public Drawing&#123;public:void drawLine(double x1,double y1,double x1,double y1)&#123;/*代码省略*/&#125;void drawCircle(double x,double y,double r)&#123; DP1::V1Drawing(x,y,r);&#125;&#125;;class shape&#123;public:virtual void draw()=0 ;Shape(Drawing *dp)&#123;_dp=dp;&#125;void drawLine(double x1,double y1,double x1,double y1)&#123;_dp-&gt;drawLine(x1,y1,x1,y1);&#125;void drawCircle(double x,double y,double r)&#123;_dp-&gt;drawCircle(x,y,r);&#125;private:Drawing *_dp;&#125;;class Rectangle:public Shape&#123; public:void draw()&#123;/*代码省略*/&#125;//其余代码省略&#125;;class Circle:public Shape&#123;private:double _x,_y,_r;public:Circle(Drawing *_dp,double x,double y,double r): Shape(dp) &#123; _x=x;_y=y;_r=r;&#125;;void draw()&#123;drawCircle(_x,_y,_r); &#125;&#125;; 1.5.3.2017B 某图像预览程序要求能够查看BMP，JPEG和GIF三种格式的文件，且能够在Windows和Linux两种操作系统上运行。程序需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，现采用桥接 （Bridge）模式进行设计，得到如图11所示的类图。 图11 1234567891011121314151617181920212223242526272829303132333435363738394041424344class matrix&#123;//各种格式的文件最终都被转化为像素矩阵//此处代码省略&#125;；class Implement&#123;Public:Virtual Void doPaint(Matrix m)=0;//显示像素矩阵m&#125;；class WinImp:public Implementor&#123;Public:Void doPaint(Matrix m)&#123;/*调用Windows系统的绘制函数绘制像素矩阵*/&#125;&#125;;class LinuxImp: public Implementor&#123;public:Void doPaint(Matrix m)&#123;/*调用Linux系统的绘制函数绘制像素矩阵*/&#125;&#125;;class Imag&#123;public:void setImp(Implementor *imp)&#123;this.imp=imp;&#125;virtual void parseFile(String fileName)=0;protected: Implenentor *imp;&#125;;class BMPImage:public Image&#123;//此处代码省略&#125;；class GIFImage:public Image&#123;public:void parseFile(String fileName)&#123;//此处解析GIF文件并获取一个像素矩阵对象m imp-&gt;doPaint(Matrix m);//显示像素矩阵m&#125;&#125;；class JPEGImage:public Image&#123;//此处代码省略&#125;;int main()&#123;public static void main(String[] args)&#123;//在Linux操作系统上查看demo.gif图像文件Imag imag= new GIFImage();Implementor imageImp= new LinuxImp() ;imp.setImp(\"imageImp\");image.parseFile(“demo.gif”);&#125; &#125; 1.6 总结 桥接模式实现了抽象化与实现化的脱耦。他们两个互相独立，不会影响到对方。 对于两个独立变化的维度，使用桥接模式再适合不过了。 对于“具体的抽象类”所做的改变，是不会影响到客户。 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之抽象工厂模式","slug":"设计模式之抽象工厂模式","date":"2018-03-08T07:12:11.000Z","updated":"2018-10-12T14:40:55.480Z","comments":true,"path":"2018/03/08/设计模式之抽象工厂模式/","link":"","permalink":"http://yoursite.com/2018/03/08/设计模式之抽象工厂模式/","excerpt":"","text":"抽象工厂模式 1.1定义：抽象工厂模板提供一个创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类。1.2结构图 图31 AbstractProduct(抽象产品类)：为各种产品声明抽象接口或抽象类。 ConcreteProduct(具体产品类)：抽象产品类的实现类，为实现某个具体产品的对象。 AbstractFactory(抽象工厂类)：声明了一组用于创建一种产品（每一个方法对应一种产品）的方法。 ConcreteFactory(具体工厂类)：继承抽象工厂类，生成一组具体产品。 ① 抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。 ② 产品族和产品等级。所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：图32 ③ 显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。 ④ 图32的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图：图33 ⑤ 是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。图 34 ⑥ 抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。这就带来非常大的灵活性，切换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换。 图35 1.3适用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组） 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 1.4优缺点 分离接口和实现：客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦 使切换产品族变得容易：因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。 （缺点）不太容易扩展新的产品：如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。 1.5实例描述：装电脑，我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、硬盘、内存、主板、电源、机箱等。为讨论使用简单点，只考虑选择CPU和主板的问题。事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求，也就是我们每个人自己拟定的装机方案。 1.5.1.2012B 现欲开发一个软件系统，要求能够同时支持多种不同的数据库，为此采用抽象工厂模式设计该系统。以SQL Server和Access两种数据库以及系统中的数据库表Department为例，其类图如图36所示。图36 12345678910111213141516171819202122232425262728293031323334353637383940#include＜iostream＞using namespace std;class Department&#123;/*代码省略*/&#125;;class IDepartment&#123;public: virtual void Insert(Department* department)=0; virtual Department GetDepartment(int id)=0;&#125;;class SqlserverDepartment: public IDepartment&#123;public: void Insert(Department* department)&#123; cout＜＜\"Insert a record into Department in SQL Server!\\n\"; //其余代码省略 &#125; Department GetDepartment(int id)&#123; &#125;&#125;;class AccessDepartment: public IDepartment&#123;public: void Insert(Department* department)&#123; cout＜＜\"Insert a record into Department in ACCESS!\\n\"; //其余代码省略 &#125; Department GetDepartment(int id)&#123; /*代码省略*/ &#125;&#125;;class IFactory&#123;public:virtual IDepartment* CreateDepartment()=0;&#125;;class SqlServerFactory: public IFactory&#123;public: IDepartment* CreateDepartment() &#123;return new SqlserverDepartment(); &#125;&#125;;class AccessFactory:public IFactory&#123;public: IDepartment* CreateDepartment() &#123; return new AccessDepartment() ; &#125; //其余代码省略&#125;; 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之命令模式","slug":"设计模式之命令模式","date":"2018-03-05T06:42:11.000Z","updated":"2018-10-12T14:40:35.152Z","comments":true,"path":"2018/03/05/设计模式之命令模式/","link":"","permalink":"http://yoursite.com/2018/03/05/设计模式之命令模式/","excerpt":"","text":"命令模式 1.1定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 1.2结构图 图12 Command：为所有命令声明了一个接口，调用命令对象的execute()方法就可以让家守着进行相关的动作。 ConcreteCommand：命令接口实现对象，定义了动作和接受者之间的绑定关系，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 Client：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 ① 在软件系统中，行为请求者与行为实现者之间通常呈现一种紧耦合的关系，但在某些场合，比如要对行为进行记录、撤销、重做事务等处理，这种无法抵御变化的紧耦合是不合适的。 ② 从类关系图可以简单地看出：命令模式其实是把需求（Invoker）和具体实现类（Receiver）通过命令层（Command）进行解耦合。 ③ 在命令模式中，会定义一个命令的接口，用来约束所有的Command对象，然后提供具体的命令实现，每个ConcreteCommand对象是对客户端某个请求的封装。 ④ 在命令模式中，命令对象并不知道如何处理命令，会有相应的Reveiver对象来真正执行命令。 ⑤ 在命令模式中，命令对象和接收者对象的关系，并不是与生俱来的，需要有一个装配的过程，命令模式中的Client对象就来实现这样的功能。 ⑥ 命令模式还会提供一个Invoker对象来持有命令对象，用户就可以通过Invoker来触发并要求执行相应的命令了。 1.1适用场景 抽象出待执行的动作以参数化某对象 在不同的时刻指定、排列和执行请求 支持取消操作 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍 用构建在原语操作上的高层操作构造一个系统 1.4优缺点 它能比较容易地设计一个命令队列； 在需要的情况下，可以较容易地将命令记入日志； 允许接收请求地一方决定是否要否决请求； 可以容易地实现对请求地撤销和重做； 由于加进新地具体命令类不影响其他的类，因此增加新的具体命令类很容易； 把请求一个操作的对象与知道怎么执行一个操作的对象分隔开； （缺点）可能会导致系统具有过多的具体命令类。 1.5实例 说明： 当我们按下启动按钮，电源开始向主板和其它设备供电，主板的系统BIOS（基本输入输出系统）开始加电后自检，主板的BIOS会依次去寻找显卡等其它设备的BIOS，并让它们自检或者初始化，开始检测CPU、内存、硬盘、光驱、串口、并口、软驱、即插即用设备等等，BIOS更新ESCD（扩展系统配置数据），ESCD是BIOS和操作系统交换硬件配置数据的一种手段，等前面的事情都完成后，BIOS才按照用户的配置进行系统引导，进入操作系统里面，等到操作系统装载并初始化完毕，就出现我们熟悉的系统登录界面了。 在命令模式中，会定义一个命令的接口，用来约束所有的Command对象，然后提供具体的命令实现，每个ConcreteCommand对象是对客户端某个请求的封装，对应于机箱上的按钮，一个机箱上可以有很多按钮，也就相当于会有多个具体的命令实现对象。 在命令模式中，命令对象并不知道如何处理命令，会有相应的Reveiver对象来真正执行命令。就像电脑的例子，机箱上的按钮并不知道如何处理功能，而是把这个请求转发给主板，由主板来执行真正的功能，这个主板就相当于命令模式的接收者。 在命令模式中，命令对象和接收者对象的关系，并不是与生俱来的，需要有一个装配的过程，命令模式中的Client对象就来实现这样的功能。这就相当于在电脑的例子中，有了机箱上的按钮，也有了主板，还需要有一个连接线把这个按钮连接到主板上才行。 * 命令模式还会提供一个Invoker对象来持有命令对象，就像电脑的例子，机箱上会有多个按钮，这个机箱就相当于命令模式的Invoker对象。用户就可以通过Invoker来触发并要求执行相应的命令了，这也相当于真正的客户是按下机箱上的按钮来操作电脑一样。 机箱上的按钮就相当于是命令对象，机箱相当于是Invoker，主板相当于接收者对象。命令对象持有一个接收者对象，就相当于是给机箱的按钮连上了一根连接线，当机箱上的按钮被按下的时候，机箱就把这个命令通过连接线发送出去。主板类才是真正实现开机功能的地方，是真正执行命令的地方，也就是“接收者”。 命令的实现对象，其实是个“虚”的实现，就如同那根连接线，它哪知道如何实现啊，还不就是把命令传递给连接线连到的主板。把客户的开机请求封装成为一个OpenCommand对象，客户的开机操作就变成了执行OpenCommand对象的方法了？如果还有其它的命令对象，比如让机器重启的ResetCommand对象；那么客户按下按钮的动作，就可以用这不同的命令对象去匹配，也就是对客户进行参数化。 1.5.1.2008A 已知某企业欲开发一家用电器遥控系统，即用户使用一个遥控器即可控制某些家用电器的开与关。遥控器如左下所示。该遥控器共有4个按钮，编号分别是0至1，按钮0和2能够遥控打开电器1和电器2，按钮1和1则能遥控关闭电器1和电器2。由于遥控系统需要支持形式多样的电器，因此，该系统的设计要求具有较高的扩展性。现假设需要控制客厅电视和卧室电灯，对该遥控系统进行设计所得类图如图11所示。 图11 在图11中，类RomoteController的方法onPressButton(int button)表示当遥控器按键按下时调用的方法，参数为按键的编号；Command接口中on和off方法分别用于控制电器的开与关；Light中turnLight(int degree)方法用于调整电灯灯光的强弱，参数 degree值为0时表示关灯，值为100时表示开灯并且将灯光亮度调整到最大；TV中 setChannel(int channel)方法表示设置电视播放的频道，参数channel值为0时表示关闭电视，为1时表示开机并将频道切换为第1频道。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Light&#123; //电灯类public: void trunLight(int degree)&#123;//调整灯光亮度，0表示关灯，100表示亮度最大)；&#125;;class TV&#123;//电视机类public:vold setChannel(int channel]&#123;//调整电视频道，0表示关机，1表示开机并切换到1频道&#125;；&#125;;class Command&#123;//抽象命令类public: virtual void on()=0; virtual void off()=0;&#125;;class RemoteController&#123; //遥控器类protected: Command* commands [4];//遥控器有4个按钮，按照编号分别对应4个Command对象public： void onPressButton(int button)&#123; //按钮被按下时执行命令对象中的命令 if(button % 2==0)commands[button]-＞on(); else commands[button]-＞off(); &#125; void setCommand(int button，Command* command)&#123; commands[button] =command;//设置每个按钮对应的命令对象&#125;&#125;;class LightCommand：public Command&#123; //电灯命令类protected：Light* light; //指向要控制的电灯对象public： void On()&#123;light-＞trunLight(100);); void off()[light-＞ trunLight(0);); LightCommand(Light * light)&#123;this-＞light=light;);&#125;;class TVCommand：public Command&#123;//电视机命令类protected: TV*tv; //指向要控制的电视机对象public: void on()&#123;tv-＞ setChannel(1);&#125;; void off()&#123;tv-＞setChannel(0);); TVCommand(TV *tv)&#123;this-＞tv=tv;);&#125;;void main()&#123; Light light;TV tv;//创建电灯和电视对象 LightCommand lightCommand (&amp;light); TVCommand tVCommand(&amp;tv); RemoteController remoteController; remoteController. setCommand(0，&amp;lightCommand);//设置按钮0的命令对象&#125; 1.5.2.2014B 某灯具厂商欲生产一个灯具遥控器，该遥控器具有7个可编程的插槽，每个插槽都有开关按钮，对应着一个不同的灯。利用该遥控器能够统一控制房间中该厂商所有品牌灯具的开关，现采用Command（命令）模式实现该遥控器的软件部分。Command模式的类图如图14所示。 图14 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Light &#123;public: Light(string name) &#123; /* 代码省略 */ &#125; void on() &#123; /* 代码省略 */ &#125; // 开灯 void off() &#123; /* 代码省略 */ &#125; // 关灯&#125;;class Command &#123;public: virtual void execute()&#123;&#125;; &#125;；class LightOnCommand:public Command &#123; // 开灯命令private: Light* light;public: LightOnCommand(Light* light) &#123; this-&gt;light=light; &#125; void execute() &#123;light-&gt;on(); &#125;&#125;;class LightOffCommand:public Command &#123; // 关灯命令private: Light *light;public: LightOffCommand(Light* light) &#123; this-&gt;light=light; &#125; void execute() &#123;loght-&gt;off() ; &#125;&#125;;class RemoteControl&#123; // 遥控器private: Command* onCommands[7]; Command* offCommands[7];public: RemoteControl() &#123; /* 代码省略 */ &#125; void setCommand(int slot, Command* onCommand, Command* offCommand) &#123; onCommands[slot]=onCommand; offCommands[slot]=offCommand; &#125; void onButtonWasPushed(int slot) &#123; onCommands[slot]-&gt;execute() ; &#125; void offButtonWasPushed(int slot) &#123; offCommands[slot]-&gt;execute() ; &#125;&#125;;int main() &#123; RemoteControl* remoteControl=new RemoteControl(); Light* livingRoomLight=new Light(\"Living Room\"); Light* kitchenLight=new Light(\"kitchen\"); LightOnCommand* livingRoomLightOn=new LightOnCommand(livingRoomLight); LightOffCommand* livingRoomLightOff=newLightOffCommand(livingRoomLight); LightOnCommand* kitchenLightOn=new LightOnCommand(kitchenLight); LightOffCommand* kitchenLightOff=new LightOffCommand(kitchenLight); remoteControl-&gt;setCommand(0, livingRoomLightOn, livingRoomLightOff); remoteControl-&gt;setCommand(1, kitchenLightOn, kitchenLightOff); remoteControl-&gt;onButtonWasPushed(0); remoteControl-&gt;offButtonWasPushed(0); remoteControl-&gt;onButtonWasPushed(1); remoteControl-&gt;offButtonWasPushed(1); /* 其余代码省略 */ return 0;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"设计模式之原型模式","slug":"设计模式之原型模式","date":"2018-03-03T09:12:10.000Z","updated":"2018-10-12T14:40:02.815Z","comments":true,"path":"2018/03/03/设计模式之原型模式/","link":"","permalink":"http://yoursite.com/2018/03/03/设计模式之原型模式/","excerpt":"","text":"原型模式 1.1定义：通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。 1.2结构图图 48 客户(Client)角色：客户类提出创建对象的请求。 抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。 具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。 ① 原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。 ② 原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。图 49③ 作为原型模式的第二种形式，它多了一个原型管理器(PrototypeManager)角色，该角色的作用是：创建具体原型类的对象，并记录每一个被创建的对象。 ④ 简单形式和登记形式的原型模式各有其长处和短处：如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。 1.3适用场景 当一个系统应该独立于它的产品创建，构成和表示时； 当要实例化的类是在运行时刻指定时，例如，通过动态装载； 为了避免创建一个与产品类层次平行的工厂类层次时； 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 1.4优缺点 原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。 （缺点） 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。 1.5实例现要求实现一个能够自动生成求职简历的程序，简历的基本内容包括求职者的姓名、性别、年龄及工作经历。希望每份简历中的工作经历有所不同，并尽量减少程序中的重复代码。现采用原型模式(Prototype)来实现上述要求，得到如图50所示的类图。图50 1234567891011121314151617181920212223242526272829303132333435363738394041424344# include＜string＞ Using namespace std; Class Clonealole&#123; Public: virtual Cloneable*Clone()=0; Class WorkExperience:public Cloneable&#123; //经历 Private: String workDate; String company; Public: Cloneable*Clone()&#123; WorkExperience *obj=new WorkExperience(); Obj-＞workDate=this-＞workDate; Obj-＞company=this-＞company; Return obj; &#125; //其余代码省略 &#125;; Class Resume:public Cloneable&#123; //简历 Private: String name; string sex; string age; WorkExperience*work; Resume(WorkExperience*work)&#123; This-＞work=( WorkExperience*)work-&gt;clone(); Public: Resume(string name)&#123; /*实现省略*/ &#125; Void SetPersonallnfo(string sex, string age)&#123; /*实现省略*/ &#125; Void setWorkExperience(string workDate,string company) &#123; /*实现省略*/ &#125; Cloneable*Clone()&#123; Resume *obj=new Resume(); obj-＞name=this-＞name; obj-＞sex=this-＞sex; 0bj-＞age=this-＞age; Return obj; &#125; &#125;; Int main()&#123; Resume*a=new Resrune(\"张三\"); A-＞SetPersonalInfo(\"男\", \"29\"); A-＞SetWorkExperience(\"1998～2000\", \"XXX公司\"); Resume*b=(Reasume*)a-&gt;Clone(); B-＞SetWorkExperience(\"2001～2006\",\"YYY公司\"); Return 0; &#125; 1.6总结Prototype模式同工厂模式，同样对客户隐藏了对象的创建工作，但是，与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的，达到了“隔离类对象的使用者和具体类型（易变类）之间的耦合关系”的目的。 完整源代码见：https://github.com/255255255255/design-mode","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}